Numeric Python
NumPy это open-source модуль для python, который предоставляет общие
математические и числовые операции в виде пре-скомпилированных, быстрых функций.

import numpy as np  # принятое соглашение
ndarray             # массив схожий с list но все элементы одного типа

# документация
help(np.max) # информация по объекту
np.max?      # используется как короткая замена help в IPython
np.max??     # source code

# Создание массивов
array()             # принимает любой объект похожий на последовательность
asaray()            # если на входе ndarray - не копирут, в отлич от array
arange()            # аналог range() возвращает массив
linspace(0, 100, 5) # разб отрезок от 0 до 100 на 5 частей включая 0 и 100
zeros((3, 2))       # 3 на 2 нулями
zeros_like()        # на вход принимает массив, на выходе массив такой же
                      размерностью и типа, но заполненный нулями
ones, like_ones     # то же что и zeros но зап-ся единицами
empty, like_empty   # то же но без иниц-ии (будет мусор)
eye, identity       # единич квадрат матрица(диаганаль - 1, остальные нули)

# Индексы, срезы - создается новый массив
a[-1] b[0, 0]   # индексы b[0][0] == b[0,0]
a[0:-1:1]       # срезы [from:to:step]
arr[:,::2]      # все строки, все столбцы с шагом 2
a[0] = 3        # присваивание
a[[0,2]]        # вывод определенных 
a[0:9:2]        # Извлечение элементов с определенным шагом
a[a<5]          # вывод с опред условием 
(a<5)|(a%2==0)  # можно и так замутить - булев массив
a[(a<5)&(a!=0)] # булев массив в качестве индексов
a[b]            # целочисленный массив в качестве индексов
nonzero(a<5)    # вернет кортеж массивов с номерами индексов где условие верно 
                  на каждую ось 1 массив

# Типы данных
+--------------+---------+--------------------------------------------------+
|int8,  uint8  |i1, u1   |Знаковое и беззнаковое 8-разрядное(1 байт) целое  |
|int16, uint16 |i2, u2   |Знаковое и беззнаковое 16-разрядное(2 байта) целое|
|int32, uint32 |i4, u4   |Знаковое и беззнаковое 32-разрядное(4 байта) целое|
|int64, uint64 |i8, u8   |Знаковое и беззнаковое 64-разрядное(8 байт) целое |
|float16       |f2       |С плавающей точкой половинной точности            |
|float32       |f4       |Стандартный тип с плавающей точкой одинарной точ  |
|float64       |f8 или d |Стандартный тип с плавающей точкой двойной точ    |
|float128      |f16      |С плавающей точкой расширенной точности           |
|complex64,    |c8       |Комплексные                                       |
|complex128,   |c16      |                                                  |
|complex256    |c32      |                                                  |
|bool          |?        |Булев тип, способный хранить значения True и False|
|object        |O        |Тип объекта Python                                |
|string_       |S        |Тип строки фиксированной длины(1 байт на символ)  |
|unicode_      |U        |Тип Unicode-строки фиксированной длины            |
+--------------+---------+--------------------------------------------------+

# Приведение типа
# если в массиве и числа и строки - все приводится к строкам
b = a.astype(np.float64) # такой же как а, но другой тип
z = np.uint8(a)          # такой же, но тип uint8

# Некоторые свойства
a.shape    # размерность массива (2, 3)
a.dtype    # тип переменных
a.size     # кол-во элем-ов
a.ndim     # глубина/кол-во осей массива
a.itemsize # размер 1-го элемента в байтах
a.strides  # размер порядков в байтах, в случае двумерного
             (размер строки, размер элем)

# Изменение формы массива
# должно быть кратно кол-ву элементов массива
a.reshape(2, 3) # преобразуем в массив 2 стр 3 столбца
a.reshape(3,-1) # -1 авто определение оси
a.flatten()     # вытянуть массив в 1, копия
a.ravel()       # вытянуть массив в 1, тот же адрес
a.T             # a.transpose(), транспонировать, поменять оси местами

# Фиктивные оси
# имеют размерность 1, нужны в некоторых случаях
a[np.newaxis, :]          # добавление фиктивной оси - строка
a[:, np.newaxis]          # добавление фиктивной оси - столбец
np.expand_dims(a, axis=0) # второй способ

# Операции между массивами и скалярами
a*2, a-4 ... a**0.5       # операции происходят поэлементно
a > 0, a <= 22 ...        # различные сравнения, на выходе булевый массив
(a == 0) | (a == 1)       # битовые операторы
a[a < 0] = 0              # замена всех отрицательных нолями
np.dot(a, b), a @ b       # векторно-матричное умножение

# Универсальные функции, быстрые поэлементные операции над массивами.
# Унарные u-функции
np.abs(a)  # абсолютное значение целых
fabs(a)    # абсолютное значение вещественных или комплексных чисел 
sqrt(a)    # квадратный корень из каждого элемента. Эквивалентно arr ** 0.5 
square(a)  # квадрат каждого элемента. Эквивалентно arr ** 2 
exp(a)     # экспоненту ex каждого элемента
log(a)     # Натуральный (по основанию e)
log10(a)   # десятичный
log2(a)    # двоичный
log1p(a)   # функция log(1 + x) 
sign(a)    # знак каждого элемента: 1 0 –1
ceil(a)    # округление до верхнего целого 
floor(а)   # округление до нижнего целого 
rint(a)    # Округлить элементы до ближайшего целого с сохранением dtype 
modf(a)    # дробные и целые части массива в виде отдельных массивов 
isnan(a)   # check for NaN (не числа) 
isinf(a)   # check for inf и NaNnp.inf
# Обычные и гиперболические тригонометрические функции и обратные
cos, cosh, sin, sinh, tan, tanh
arccos, arccosh, arcsin, arcsinh, arctan, arctanh

# Бинарные u-функции
# логические
logical_not # -a - not x для каждого элемента. Эквивалентно -arr 
logical_and # a & b - И
logical_or  # a | b - ИЛИ
logical_xor # a ^ b -исключающее ИЛИ
# сравнение
greater(a,b)       # >
greater_equal(a,b) # >=
less(a,b)          # <
less_equal(a,b)    # <=
equal(a,b)         # ==
not_equal(a,b)     # !=
# арифметические операции    
add(a,b)          # a + b 
subtract(a,b)     # a - b 
multiply(a,b)     # a * b 
divide(a,b)       # a / b
floor_divide(a,b) # a // b 
power(a,b)        # a ** b 
mod(a,b)          # a % b 
copysign(a,b)     # знаки значений второго массива в соотв элем первого 
maximum(a,b)      # Поэлементный максимум. 
fmax(a,b)         # игнорирует значения NaN 
minimum(a,b)      # Поэлементный минимум
fmin(a,b)         # игнорирует значения NaN    

# Обработка данных с приенением массивов, без циклов
meshgrid() # принимает 2 одномерных массива, порождает 2 матрицы со значенрями
             из обоих массивов, строк в первом столько сколько эл во вотором.
             Столбцов во втором - сколько эл в первом.
z = np.sqrt(ar1**2 + ar2**2)  # итерируются 3 массива с их эл-ми.

# Запись логиеских условий в виде операций с массивами
where - соответствует тернарному x if true else y
where(условие,эл1,эл2) # элементами могут быть массивы, скаляры, результат
                         будет новый массив. Массивы итерируются..

# Математические и статистические операции
sum(a)  # Сумма элементов всего массива или вдоль одной оси.
mean(a) # Среднее арифметическое. Для массивов нулевой длины равно NaN 
std(a)  # Стандартное отклонение(среднее 0, отклонение 1(+-1))
var(a)  # дисперсия 
min(a)  # минимум
max(a)  # максимум 
argmin  # iндексы минимального
argmax  # Индексы максимального элемента 
cumsum  # Нарастающая сумма каждый элемент массива складывается с предыдущим 
cumprod # Нарастающее произведение с начальным значением 1 

# Методы булевых массивов
any() # есть ли в массиве хоть 1 True
all() # все ли True
a > 0 # массив True/False

# Сорировка
а.sort()   # сортирует на месте
np.sort(a) # новый сортированный массив
np.flip(a) # reverse 

# Конкатенация
np.concatenate((a, b), axis=0) # конкатенация массивов
np.vstack((a,b)) # вертикальный стакинг
np.hstack((a,b)) # горизонтальный стакинг
np.row_stack     # is equivalent to vstack for any input arrays
np.column_stack  # эквивалент hstack with 2D arrays 
np.r_[1:4,0,4]   # row по одной оси 
np.c_[1:4,0,4]   # column по одной оси

# Устранение дубликатов и др теоретико-множественные оп-ии с массивами
unique(x)         # отсортированное множество уникальных элементов 
intersect1d(x, y) # отсортированное множество элементов, общих для x и y 
union1d(x, y)     # отсортированное объединение элементов 
in1d(x, y)        # какие элементы x встречаются в y 
setdiff1d(x, y)   # элементы, принадлежащие x, но не принадлежащие y 
setxor1d(x, y)    # элементы, принадлежащие одному массиву, но не обоим сразу


# Файловый ввод-вывод массивов.
# Хранение массивов в двоичном формате на жеском диске
save('myarr', arr) # сохранит в myarr.npy, если суффикса не было
load('myarr.npy')  # загрузка
savez('myarrs.npz', a=arr, b=arr2) # несколько массивов в зип
load('myarrs.npz') # вернет подобие словаря, по ассоц меткам ['а'] 
                     можно обращаться к массивам.
# Сохранение и загрузка текстовых файлов
loadtxt('file.csv', delimitr=',')      # load файл .csv
savetxt('file.txt', arr, delimitr=',') # записывает в файл
savetxt('np.csv', a, fmt='%.2f', delimiter=',', header='1,2,3,4') # headers
genfromtxt(io.StringIO(data), delimiter=",") # более крутая чем loadtxt


# разделение массива на несколько малых
split(x, 3) # делит на 3 части
hsplit()    # horiz
vsplit()    # vertic

# Копии
c = a        # ссылка, id одинаковые
c = a.copy() # копия, разные id
c = a.view() # неглубокая копия - данные не копируются

# Линейная алгебра np.linalg
diag  # диагональные элементы квадратной матрицы в виде одномерного массива
        или преобразует одномерный массив в квадратную матрицу, в которой все 
        элементы, кроме находящихся на главной диагонали, равны нулю
dot   # произведение матриц 
trace # след матрицы – сумму диагональных элементов 
det   # определитель матрицы 
eig   # собственные значения и собственные векторы квадратной матрицы
inv   # обратную матрицу 
pinv  # псевдообратную матрицу Мура-Пенроуза для квадратной матрицы 
qr    # QR-разложение 
svd   # сингулярное разложение (SVD) 
solve # Решает линейную систему Ax = b, где A – квадратная матрица 
lstsq # Вычисляет решение уравнения y = Xb по методу наименьших квадратов 

# Генерация случайных чисел np.random
seed        # Задает начальное значение генератора случайных чисел 
permutation # случайную перестановку последовательности или диапазона 
shuffle     # Случайным образом переставляет последовательность на месте 
rand        # Случайная выборка с равномерным распределением 
randn       # Случайная выборка с нормальным распределением со средним 0
randint     # Случайная выборка целого числа из заданного диапазона 
binomial    # Случайная выборка с биномиальным распределением 
normal      # Случайная выборка с нормальным (гауссовым) распределением 
beta        # Случайная выборка с бета-распределением 
chisquare   # Случайная выборка с распределением хи-квадрат 
gamma       # Случайная выборка с гамма-распределением 
uniform     # Случайная выборка с равном-м распред на полуинтервале [0, 1)

# рекомендуемый генератор с битовым генератором по умолчанию (PCG 64)
rng = np.random.default_rng(0)       # seed
rng.random((3,2))                    # float, random array 0-1, 3x2
rng.integers(low=0, high=10, size=3) # 3 random integers 0-10 

# Plotting arrays with Matplotlib
%matplotlib inline # рисовать графики в jupyter notebook
plt.plot(a) # построить график 1-d array, значения а - координаты н
              координаты х - индексы элементов(0,1,2...)
plt.show()  # добавить это, если работа в ком строке
x = np.linspace(0, 5, 20)  # массив под х-координаты
y = np.linspace(0, 10, 20) # массив под у-координаты
# два графика
plt.plot(x, y, 'purple')   # line, color=purple
plt.plot(x, y, 'o')        # dots
