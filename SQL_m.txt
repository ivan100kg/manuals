    SQL  - structured query language - язык структуированных запросов
    СУБД - сист упр БД (MySQL, PostgreSQL, Microsoft Access...)
    Реляционная база данных — бд, основанная на реляционной модели данных.
    Понятие «реляционный» relation («отношение, зависимость, связь»
    Схема   - инфо о БД, о структуре и сво-х ее таблиц
    БД      - набор данных хранящихся упорядоченным способом (таблицы)
    Таблица - срук-ый файл с данными определенного типа
    Столбцы - одиночное поле таблицы с опред. типом данных
    Строка  - данные(запись) в таблице счет от НУЛЯ
    Первичные ключи - уникально иден-ют каждую строку


=== MySQL ======================================================================
-- Операции с БД
CREATE DATABASE my_base; # создать БД my_base
SHOW DATABASES;          # показать все БД
DROP DATABASE my_base;   # удалить БД
USE my_base              # использовать БД

-- Создание таблицы в базе
CREATE TABLE 
IF NOT EXISTS 
`models`(
         `id` INT AUTO_INCREMENT,            # тип инт, гене-я номера
         `name` VARCHAR(32) NOT NULL,        # строка макс 32 симв
         `size` FLOAT,                       # число с точкой
         `country` VARCHAR(32),              
         `birthday` DATE NULL DEFAULT NULL,  # дата
         `pictures` INT,
         `last_pic` INT,
         PRIMARY KEY (`id`, `name`));        # прайм поля

-- изменить таблицу
ALTER TABLE my_table  
        ADD my_new_field VARCHAR(100)         -доб нов столб после указ-го
        CHANGE old_field new_field VARCHAR(2) -изменяет наз-е и тип колонки
        AFTER id;
        DROP my_new_field;                    -удаление колонки

		
SHOW TABLES;          -показать все таблицы в базе
EXPLAIN my_table;     -показать структуру таблицы
DROP TABLE my_table;  -удалить таблицу
================================================================================

=== PostgreSQL =================================================================
sudo -u postgres psql   # start psql as user 'postgres'(авто зареган в Linux) 
psql --help \? \h       # help for everything
\q          # exit from psql
\l          # show databases
\l dbname   # show db 'dbname'
\c dbname   # connect(use) database
\dt         # show all tables in db
\d table_n  # show table 'table_name'
\i sqr.sql  # чтение команд из файла

-- Создать бд
sudo -u postgres createdb mydb   # создать бд из консоли linux
sudo -u postgres dropdb mydb     # удалить бд 'mydb'

-- Типы данных -----------------------------------------------------------------

-- Целые числа
smallint        int2    # целое 2 байта
integer         int4    # 
bigint          int8    #
serial                  # int, автоинкремент

-- Числа фиксированной точности
numeric/decimal         # точность(precision) - общее кол-во цифр
                          масштаб(scale) - кол-во цифр после десятичной точки
                          numeric(5,2) - (точность, масштаб)

-- Числа с плавающей точкой
real                    # 1e-37 - 1e+37
double precision        # 1e-307 - 1e+307

-- Строковые типы
character varying(n)    varchar(n)  # n - max n символов
character(n)            char(n)     # дополняет знач n пробелами - мало исп
text                                # неогран число символов
Синтаксис: 'Some String'
Экранирование: 
    'I''m backslash \\' # ковычки и бэкслэши удваивать
    $$I'm backslash \$$ # с пом знаков доллара
    E'I\'m backsl.. \\' # C-стиль \n \t ... все работает

-- Дата/время
используется формат 'yyyy-mm-dd' 1983-01-23
можно вводить 'Jan 23, 1983' - преобразуется авто
-- дата
SELECT '2016-09-12'::date;      # 2016-09-12
SELECT 'Sep 12, 2016'::date;    # 2016-09-12
SELECT current_date;            # дата сейчас
-- Другой формат даты
SELECT to_char( current_date, 'dd-mm-yyyy' );   # 21-09-2016
-- время
SELECT '21:15'::time;       # 21:15:00
SELECT '21:15:26'::time;    # 21:15:26
SELECT '10:15:16 am'::time; # 21:15:26
SELECT current_time;        # сейчас 23:51:57.293522+03 (+03 часовой пояс)
-- временная отметка (дата+время+[ч пояс])
SELECT timestamptz '2016-09-21 22:25:35';   # 2016-09-21 22:25:35+03
SELECT timestamp '2016-09-21 22:25:35';     # 2016-09-21 22:25:35
SELECT current_timestamp;                   # дата+время+ч.пояс сейчас
-- интервал времени
SELECT '1 year 2 months'::interval; # 1 years 2 mons, считает кол-во
                                      если указать ago - '-1 years -2 mons'
                                      можно исп: microsecond, millisecond,
                                      second, minute, hour, day, week,
                                      month, year, decade, century, millennium
SELECT 'P0001-02-03T04:05:06'::interval;    # альтернативный формат 
                                              1 year 2 mons 3 days 04:05:06
SELECT ('2016-09-16'::timestamp - '2016-09-01'::timestamp)::interval;
-- усечение даты
SELECT (date_trunc('hour', current_timestamp)); # до часа 2016-09-27 22:00:00+03
-- извлечение отдельных полей времени
SELECT extract( 'mon' FROM timestamp '1999-11-27 12:34:56.123459' );    # 11

-- Логический тип Boolean
TRUE    't' 'true'  'yes'   'on'    '1' # истина
FALSE   'f' 'false' 'no'    'off'   '0' # ложь

-- Массивы
my_arr integer[]                            # поле в таблице для массива
'{1,2,3,4}'::integer[] == ARRAY[1,2,3,4]    # записи аналогичные
INSERT: '{1,2,3,4}'::integer[]              # добавить данные в т
UPDATE: my_arr = my_arr || 5;               # добавить в массив 5
        my_arr = array_append(my_arr, 5);   # аналогично 5 в конец
        my_arr = array_append(0, my_arr);   # добавить 0 в начало
        my_arr = array_remove(my_arr, 2);   # удалить эл со знач 2
        my_arr[0] = 2, my_arr[3] = 57;      # изменить по индексу
        my_arr[0:2] = ARRAY[9,9];           # изменить по срезу
SELECT: WHERE array_position(my_arr, 3) IS NOT NULL;    # возвращ индекс позиции
                                                          значения иначе null
        WHERE my_arr @> '{4,8}'::integer[]; # возвращ true если в левом массиве
                                              есть все эл-ты с правого массива
        WHERE my_arr && ARRAY[2,4];         # пересечение множеств есть ли
                                              одинак значения, можно исп NOT
        unnest(my_arr) FROM my_table        # развернуть массив в солбец

-- JSON (JavaScript Object Notation)
hobbies jsonb                               # хранение в таблице объекта json
INSERT: '{ "sports": ["football", "golf"],  # вставка объекта
           "home_lib": true,
           "trips": 3}'::jsonb
SELECT: WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;   # есть такой аттрб?
        WHERE hobbies->'sports' @> '["футбол"]'::jsonb;     # аналог как выше
        name, hobbies->'sports' AS sports.. # вывести конкрет ключу объекта
        сount(*) FROM tbl WHERE hobbies ? 'sports'; # кол-во записей с ключом
UPDATE: hobbies || '{"sports": ["хоккей"]}' # добавить знач 'хок' в ключ 'spo'
        hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"') # добавить знач,
                                                                  ключ, №-позиц
--------------------------------------------------------------------------------

-- Значения по умолчанию, ограничения
Ограничения можно писать сразу в поле, либо в конце таблицы.
Можно давать имена ограничениям CONSTRAINT name, либо им дадут авто имена.
Уникальные поля можно указать в конце в виде кортежа (поле1, поле2).
Первичный ключ в таблице 1, но может быть составным (из неск полей) он
    автоматом UNIQUE и NOT NULL.
CREATE TABLE progress
( 
    mark numeric(1) DEFAULT 5,      # значение по умолчанию 5 для 'mark'
    term numeric(1) CHECK (term>0), # ограничение для 'term'(имя огранич авто)
    book numeric(3) NOT NULL,       # не может быть пустым
    gimp numeric(5) UNIQUE,         # уникальное знач
    CONSTRAINT val_book CHECK (book>0), # именованное ограничение для 'book'
    CONSTRAINT uni_book UNIQUE (book),  # ограничение уникальности
    PRIMARY KEY (book),             # первич ключ, можно указать и в поле сразу

);

-- Внешний ключ - поле в таблице, которая ссылается на поле из др таблицы.
Ссылающаяся таблица --> Ссылочная таблица
        подченинная --> главная
можно присваивать имена CONSTRAINT
CREATE TABLE progress
( book numeric(5) REFERENCES students (book),     # ссылка на поле др табл
  ...
  FOREIGN KEY (book)   # либо так в конце, показана многострочная команда
    REFERENCES students (book)  # куда ссылается
    ON DELETE                   # что делать если то на что ссылались удалено
        CASCADE                 # каскадное удаление ссылок на эту запись
        RESTRICT                # при удалении - ошибка, нельзя удалить
        NO ACTION               # то же, но ждет проверки в рамках транзакции
                                  (по умолчанию NO ACTION)
        SET NULL                # устанавливает NULL, поле долж быть не NOT NULL
        SET DEFAULT             # устан default, он должен быть определен в поле
    ON UPDATE ...               # изменение - те же варианты что и при удалении
                                  CASCADE чтобы все ссылки обновить
);

-- Создать таблицу
CREATE TABLE aircrafts      -- создать таблицу 'aircrafts'
( aircraft_code char( 3 ) NOT NULL,
  model text NOT NULL,
  range integer NOT NULL,
  CHECK ( range > 0 ),
  PRIMARY KEY ( aircraft_code )
);

-- удалить таблицу
DROP TABLE aircrafts;       

-- Работа с данными ----------------------------------------------------
-- внести данные
INSERT INTO aircrafts       
  ( aircraft_code, model, range )
  VALUES ( 'SU9', 'Sukhoi SuperJet-100', 3000 );
  COPY aircrafts FROM '/home/user/air.txt'; # внести из текстового файла

-- выборка данных
SELECT * FROM aircrafts;    

-- обновить/изменить данные
UPDATE aircrafts            
  SET range = 3500
  WHERE aircraft_code = 'SU9';

-- удалить данные
DELETE FROM aircrafts       
  WHERE aircraft_code = 'CN1';

-- Соединения таблиц
-- по полям, если есть совпадение в обоих таблицах
SELECT * FROM weather w JOIN cities c ON w.city = c.name;   # псевдонимы  
        ...LEFT OUTER JOIN  # табл в лев части - все строки, справа - совпавш
        также есть правые внешние, полные

-- Агрегатные ф-ии
SELECT max(temp_lo) FROM weather;                       # max
SELECT city, max(temp_lo) FROM weather GROUP BY city;   # группировка
HAVING max(temp_lo) < 40;   # сортировка после группировки работает

================================================================================

--- SQL ------------------------------------------------------------------------
-- комментарий
#  comment to
/* comment
   to
*/

-- инструкции нечувствительны к регистру USE == Use == use
-- пробелы пожно заменять переносом строк

-- экранирование
`` -такими ковычками можно заэкранировать спец слова и символы
\  -стандартный символ экранирования


-- SELECT # извлечение столбцов---------------------------------------------------------
# SELECT synopsis
SELECT column1, column2…                  # извлечь одно, неск или * - все поля
FROM table                                # имя таблицы
WHERE condition1 AND condition2…          # где 1 или несколько условий
ORDER BY column1 (ASC | DESC), column2…   # сортировка по кол (прям или обр)
LIMIT n                                   # лимит вывода
OFFSET m;                                 # отступ

SELECT * FROM table;                      # извлеч всех столб
SELECT DISTINCT column1                   # уникальные записи в столбце(ах)
SELECT COUNT (*) FROM `mytable`;          # показать количество записей
SELECT column1 AS col FROM table;         # псевдоним

-- WHERE
-- фильтрация указывается в SELECT для вывода опред-ых знач
-- опрераторы в WHERE:  
    =  >  <  >=  <=  !=(<>)  BETWEEN AND IS NULL(пуст поле)
    WHERE price BETWEEN 5 AND 10; # 5 < price < 10
-- операторы OR AND NOT IN
WHERE prod_price <= 10 AND prod_name != 'HER'; составная фильтрация
WHERE (prod_name = 'Milk' OR prod_name = 'Vodka') AND prod_price <= 10; 
WHERE prod_name IN(NOT IN) ('milk', 'vodka'); вхождение(не вхождение)

-- LIKE -опрератор для исп-я метасимволов для поиска текста в текстовых полях
-- Wildcards запросы
-- %(*) -все вхождения любого символа либо отсутствие в скобках в Access
-- _(?) -любой 1 символ обязательный ___ - 3 любых символа...
-- [AB] - либо - либо 1 симв
-- [^(!)CD]- не тот - не тот 1 симв
SELECT prod_name, prod_price, prod_id
FROM Products
WHERE prod_name LIKE 'Fish%'; вывод продуктов с fish (%fish% - где-то)

-- GROUP BY - группирует по значениям в колонке(ах) и применяет ф-ию
SELECT  size, COUNT(*)
FROM table
WHERE country = 'Russia'
GROUP BY size
HAVING COUNT(*) > 10;    # доп фильтрация после группировки
ORDER BY COUNT(*) DESC
LIMIT 5

-- INSERT INTO # Добавление инфо в таблицу----
# INSERT synopsis
INSERT INTO table
    (column1, column2…)
VALUES
    (val1, val2…),
    (val3, val4...),
    …
    (valn, valm…);

-- UPDATE # внести изменения в информацию в таблице----
# UPDATE synopsis
UPDATE table
SET column1 = 'my var',
    column2 = 1080...
WHERE column_name = 'vasya' AND col_surname = 'pupkin';

-- DELETE # удаление инфы из табл---------------------------------------------
DELETE FROM my_table WHERE field1 = 'hui';  # удаляет данные где верно условие
DELETE FROM my_table;                       # удалить все из таблицы
TRUNCATE TABLE my_table;                    # удаляет все и сбрасывает счетчик

-- JOIN # получение данных из двух таблиц------------------------
# JOIN synopsis
SELECT column1, column2…
FROM table1 AS a            # псевдоним
_____ JOIN table2 AS b      # пробел - (INNER, LEFT, RIGHT, FULL)
ON a.column_x == b.column_x # по этой колонке ищем совпадение
WHERE conditions
ORDER BY column1;
# INNER - только строки где есть совпадение по колонке Х
# LEFT  - все строки с левой таблицы и те что совпали с правой
# RIGHT - все строки с правой и те что совпали в левой
# FULL  - все строки с совпадением и без

-- Подзапросы --------------------------------------------------------------
SELECT id, name, price  # SELECT UPDATE DELETE INSERT
FROM products
WHERE price = (SELECT MAX(price) FROM products) # подзапрос возвр рез-т 1-ым
      id IN (SELECT product_id FROM sales)

-- Транзакции - последов-сть ком-д кот должны быть выполнены все или не одной
START TRANSACTION;
UPDATE.. # послед-сть команд
UPDATE..
...
COMMIT; - принять или ROLLBACK; - откатить

-- Индексы - структура данных в базе для быстрого поиска
-- СУБД автоматически решает использовать их или нет
CREATE INDEX superheroes_name_ind   # create index
ON superheroes(name);               # table(field)

-- VIEW - представления-------------------------------------------------
-- можно создавать из смешанных таблиц(для удобства)
-- ограничивать данные(некоторые столбцы не показывать)
-- сокрытие реализации
CREATE VIEW customers_v id, name    # представление
AS SELECT id, name FROM customers;  # нужные столбцы из таблицы для view

-- Вычисляемые поля -некие операции(арифметич или конкатенация или исп функ-й)
-- конкатенация
SELECT CONCAT(field1, ' ', 'sometext'), field2.. FROM mytable;
-- арифметич операции + - * /
SELECT field1 * 2 FROM...

-- функции
NOW(); CURDATE(); DATE(); DATETIME(); TIME(); -тек дата
RTRIM()  -удаление пробелов в конце значения столбца
LTRIM()  -из левой части
UPPER()  -в верх рг-р
LOWER()  -в ниж
LEN()    -длина строки

-- преобразования
to_char()
to_number()
to_date()

-- матем-е
ABS()
COS()
EXP()
PI()
SIN()
SQRT()
TAN()

--агрегатные ф-ии
AVG()   -среднее знач
COUNT() -число строк в столбце COUNT(*) -NULL не игнор, COUNT(столб)-игнорир
MAX()   -макс
MIN()   -мин
SUM()   -сумма
--------------------------------------------------------------------------------



-- настройка удаленного использования БД
sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf  --конф файл
-- меняем bind-address на 0.0.0.0
sudo systemctl restart mysql
-- далее в mysql прописываем
GRANT ALL ON forex.* TO root@'85.113.51.68' IDENTIFIED BY '399';

-- подключение к базе с удаленного узла
    mysql -u root -h 85.113.51.68 -p
	
-- настройка локального использования БД
USE mysql
GRANT ALL PRIVILEGES ON *.* TO 'ivar'@'localhost';
FLUSH PRIVILEGES;
exit;
sudo systemctl restart mysql
