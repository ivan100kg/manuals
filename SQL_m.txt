    SQL  - structured query language - язык структуированных запросов
    СУБД - сист упр БД (MySQL, PostgreSQL, Microsoft Access...)
    Реляционная база данных — бд, основанная на реляционной модели данных.
    Понятие «реляционный» relation («отношение, зависимость, связь»
    Схема   - инфо о БД, о структуре и сво-х ее таблиц
    БД      - набор данных хранящихся упорядоченным способом (таблицы)
    Таблица - срук-ый файл с данными определенного типа
    Столбцы - одиночное поле таблицы с опред. типом данных
    Строка  - данные(запись) в таблице счет от НУЛЯ
    Первичные ключи - уникально иден-ют каждую строку


=== MySQL ======================================================================
-- Операции с БД
CREATE DATABASE my_base; # создать БД my_base
SHOW DATABASES;          # показать все БД
DROP DATABASE my_base;   # удалить БД
USE my_base              # использовать БД

-- Создание таблицы в базе
CREATE TABLE 
IF NOT EXISTS 
`models`(
         `id` INT AUTO_INCREMENT,            # тип инт, гене-я номера
         `name` VARCHAR(32) NOT NULL,        # строка макс 32 симв
         `size` FLOAT,                       # число с точкой
         `country` VARCHAR(32),              
         `birthday` DATE NULL DEFAULT NULL,  # дата
         `pictures` INT,
         `last_pic` INT,
         PRIMARY KEY (`id`, `name`));        # прайм поля

-- изменить таблицу
ALTER TABLE my_table  
        ADD my_new_field VARCHAR(100)         -доб нов столб после указ-го
        CHANGE old_field new_field VARCHAR(2) -изменяет наз-е и тип колонки
        AFTER id;
        DROP my_new_field;                    -удаление колонки

		
SHOW TABLES;          -показать все таблицы в базе
EXPLAIN my_table;     -показать структуру таблицы
DROP TABLE my_table;  -удалить таблицу
================================================================================

=== PostgreSQL =================================================================
sudo -u postgres psql   # start psql as user 'postgres'(авто зареган в Linux) 
psql --help \? \h       # help for everything
\q          # exit from psql
\l          # show databases
\l dbname   # show db 'dbname'
\c dbname   # connect(use) database
\dt         # show all tables in db
\d table_n  # show table 'table_name'
\i sqr.sql  # чтение команд из файла

-- Создать бд
sudo -u postgres createdb mydb   # создать бд из консоли linux
sudo -u postgres dropdb mydb     # удалить бд 'mydb'

-- Типы данных -----------------------------------------------------------------

-- Целые числа
smallint        int2    # целое 2 байта
integer         int4    # 
bigint          int8    #
serial                  # int, автоинкремент

-- Числа фиксированной точности
numeric/decimal         # точность(precision) - общее кол-во цифр
                          масштаб(scale) - кол-во цифр после десятичной точки
                          numeric(5,2) - (точность, масштаб)

-- Числа с плавающей точкой
real                    # 1e-37 - 1e+37
double precision        # 1e-307 - 1e+307

-- Строковые типы
character varying(n)    varchar(n)  # n - max n символов
character(n)            char(n)     # дополняет знач n пробелами - мало исп
text                                # неогран число символов
Синтаксис: 'Some String'
Экранирование: 
    'I''m backslash \\' # ковычки и бэкслэши удваивать
    $$I'm backslash \$$ # с пом знаков доллара
    E'I\'m backsl.. \\' # C-стиль \n \t ... все работает

-- Дата/время
используется формат 'yyyy-mm-dd' 1983-01-23
можно вводить 'Jan 23, 1983' - преобразуется авто
-- дата
SELECT '2016-09-12'::date;      # 2016-09-12
SELECT 'Sep 12, 2016'::date;    # 2016-09-12
SELECT current_date;            # дата сейчас
-- Другой формат даты
SELECT to_char( current_date, 'dd-mm-yyyy' );   # 21-09-2016
-- время
SELECT '21:15'::time;       # 21:15:00
SELECT '21:15:26'::time;    # 21:15:26
SELECT '10:15:16 am'::time; # 21:15:26
SELECT current_time;        # сейчас 23:51:57.293522+03 (+03 часовой пояс)
-- временная отметка (дата+время+[ч пояс])
SELECT timestamptz '2016-09-21 22:25:35';   # 2016-09-21 22:25:35+03
SELECT timestamp '2016-09-21 22:25:35';     # 2016-09-21 22:25:35
SELECT current_timestamp;                   # дата+время+ч.пояс сейчас
-- интервал времени
SELECT '1 year 2 months'::interval; # 1 years 2 mons, считает кол-во
                                      если указать ago - '-1 years -2 mons'
                                      можно исп: microsecond, millisecond,
                                      second, minute, hour, day, week,
                                      month, year, decade, century, millennium
SELECT 'P0001-02-03T04:05:06'::interval;    # альтернативный формат 
                                              1 year 2 mons 3 days 04:05:06
SELECT ('2016-09-16'::timestamp - '2016-09-01'::timestamp)::interval;
-- усечение даты
SELECT (date_trunc('hour', current_timestamp)); # до часа 2016-09-27 22:00:00+03
-- извлечение отдельных полей времени
SELECT extract( 'mon' FROM timestamp '1999-11-27 12:34:56.123459' );    # 11

-- Логический тип Boolean
TRUE    't' 'true'  'yes'   'on'    '1' # истина
FALSE   'f' 'false' 'no'    'off'   '0' # ложь

-- Массивы
my_arr integer[]                            # поле в таблице для массива
'{1,2,3,4}'::integer[] == ARRAY[1,2,3,4]    # записи аналогичные
INSERT: '{1,2,3,4}'::integer[]              # добавить данные в т
UPDATE: my_arr = my_arr || 5;               # добавить в массив 5
        my_arr = array_append(my_arr, 5);   # аналогично 5 в конец
        my_arr = array_append(0, my_arr);   # добавить 0 в начало
        my_arr = array_remove(my_arr, 2);   # удалить эл со знач 2
        my_arr[0] = 2, my_arr[3] = 57;      # изменить по индексу
        my_arr[0:2] = ARRAY[9,9];           # изменить по срезу
SELECT: WHERE array_position(my_arr, 3) IS NOT NULL;    # возвращ индекс позиции
                                                          значения иначе null
        WHERE my_arr @> '{4,8}'::integer[]; # возвращ true если в левом массиве
                                              есть все эл-ты с правого массива
        WHERE my_arr && ARRAY[2,4];         # пересечение множеств есть ли
                                              одинак значения, можно исп NOT
        unnest(my_arr) FROM my_table        # развернуть массив в солбец

-- JSON (JavaScript Object Notation)
hobbies jsonb                               # хранение в таблице объекта json
INSERT: '{ "sports": ["football", "golf"],  # вставка объекта
           "home_lib": true,
           "trips": 3}'::jsonb
SELECT: WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;   # есть такой аттрб?
        WHERE hobbies->'sports' @> '["футбол"]'::jsonb;     # аналог как выше
        name, hobbies->'sports' AS sports.. # вывести конкрет ключу объекта
        сount(*) FROM tbl WHERE hobbies ? 'sports'; # кол-во записей с ключом
UPDATE: hobbies || '{"sports": ["хоккей"]}' # добавить знач 'хок' в ключ 'spo'
        hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"') # добавить знач,
                                                                  ключ, №-позиц
--------------------------------------------------------------------------------

-- Значения по умолчанию, ограничения
Ограничения можно писать сразу в поле, либо в конце таблицы.
Можно давать имена ограничениям CONSTRAINT name, либо им дадут авто имена.
Уникальные поля можно указать в конце в виде кортежа (поле1, поле2).
Первичный ключ в таблице 1, но может быть составным (из неск полей) он
    автоматом UNIQUE и NOT NULL.
CREATE TABLE progress
( 
    mark numeric(1) DEFAULT 5,      # значение по умолчанию 5 для 'mark'
    term numeric(1) CHECK (term>0), # ограничение для 'term'(имя огранич авто)
    book numeric(3) NOT NULL,       # не может быть пустым
    gimp numeric(5) UNIQUE,         # уникальное знач
    CONSTRAINT val_book CHECK (book>0), # именованное ограничение для 'book'
    CONSTRAINT uni_book UNIQUE (book),  # ограничение уникальности
    PRIMARY KEY (book),             # первич ключ, можно указать и в поле сразу

);

-- Внешний ключ - поле в таблице, которая ссылается на поле из др таблицы.
Ссылающаяся таблица --> Ссылочная таблица
        подченинная --> главная
можно присваивать имена CONSTRAINT
CREATE TABLE progress
( book numeric(5) REFERENCES students (book),     # ссылка на поле др табл
  ...
  FOREIGN KEY (book)   # либо так в конце, показана многострочная команда
    REFERENCES students (book)  # куда ссылается
    ON DELETE                   # что делать если то на что ссылались удалено
        CASCADE                 # каскадное удаление ссылок на эту запись
        RESTRICT                # при удалении - ошибка, нельзя удалить
        NO ACTION               # то же, но ждет проверки в рамках транзакции
                                  (по умолчанию NO ACTION)
        SET NULL                # устанавливает NULL, поле долж быть не NOT NULL
        SET DEFAULT             # устан default, он должен быть определен в поле
    ON UPDATE ...               # изменение - те же варианты что и при удалении
                                  CASCADE чтобы все ссылки обновить
);

-- Создать таблицу
CREATE TABLE aircrafts      -- создать таблицу 'aircrafts'
( aircraft_code char( 3 ) NOT NULL,
  model text NOT NULL,
  range integer NOT NULL,
  CHECK ( range > 0 ),
  PRIMARY KEY ( aircraft_code )
);

-- удалить таблицу
DROP TABLE aircrafts;       

-- Работа с данными ----------------------------------------------------
-- внести данные
INSERT INTO aircrafts       
  ( aircraft_code, model, range )
  VALUES ( 'SU9', 'Sukhoi SuperJet-100', 3000 );
  COPY aircrafts FROM '/home/user/air.txt'; # внести из текстового файла

-- выборка данных
SELECT * FROM aircrafts;    

-- обновить/изменить данные
UPDATE aircrafts            
  SET range = 3500
  WHERE aircraft_code = 'SU9';

-- удалить данные
DELETE FROM aircrafts       
  WHERE aircraft_code = 'CN1';

-- Соединения таблиц
-- по полям, если есть совпадение в обоих таблицах
SELECT * FROM weather w JOIN cities c ON w.city = c.name;   # псевдонимы  
        ...LEFT OUTER JOIN  # табл в лев части - все строки, справа - совпавш
        также есть правые внешние, полные

-- Агрегатные ф-ии
SELECT max(temp_lo) FROM weather;                       # max
SELECT city, max(temp_lo) FROM weather GROUP BY city;   # группировка
HAVING max(temp_lo) < 40;   # сортировка после группировки работает

-- Представления
CREATE VIEW myview AS   # создать 
    SELECT name, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;
SELECT * FROM myview;   # использование

-- Транзакции
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- ...
COMMIT;

================================================================================

--- SQL ------------------------------------------------------------------------
-- комментарий
#  comment to
/* comment
   to
*/

-- инструкции нечувствительны к регистру USE == Use == use
-- пробелы пожно заменять переносом строк

-- экранирование
`` -такими ковычками можно заэкранировать спец слова и символы
\  -стандартный символ экранирования

-- CRUD ----------------------------------------------------------------------
-- INSERT INTO
-- Добавление данных
# INSERT synopsis
INSERT INTO table           # table
    (column1, column2…)     # в какие колонки внести, если во все - пропустить
VALUES
    (val1, val2...),        # значения, соответссвующие столбцам
    (val3, val4...),        # можно вносить неск записей(списки одинак размера)
    ...
    (valn, valm…);

-- SELECT
-- Извлечение данных
# SELECT synopsis
SELECT column1, column2…    # извлечь одно, неск или * - все поля
FROM table                  # имя таблицы
WHERE condition1 AND ...    # где 1 или несколько условий
ORDER BY column1 ... mn2…   # сортировка 
LIMIT n                     # лимит вывода
OFFSET m;                   # отступ

-- UPDATE
-- Изменение данных
# UPDATE synopsis
UPDATE table                # table
SET column1 = 'my var',     # установить новые значения в определенные колонки
    column2 = 1080...
WHERE column_name = '...';  # условие, при котором необходимо изменить запись

-- DELETE
-- Удаление данных
DELETE FROM my_table        # table
WHERE field1 = 'hui';       # удаляет данные при условии(без условия - delall)

TRUNCATE TABLE my_table;    # удаляет все и сбрасывает счетчик


SELECT DISTINCT column1                   # уникальные записи в столбце(ах)
SELECT COUNT (*) FROM `mytable`;          # показать количество записей
SELECT column1 AS col FROM table;         # псевдоним

-- WHERE ---------------------------------------------------------------------
-- фильтрация, используется в SELECT/UPDATE/DELETE
-- опрераторы в WHERE:  
    =  >  <  >=  <=  !=(<>) BETWEEN AND IS NULL(пуст поле)
    WHERE price BETWEEN 5 AND 10; # 5 <= price <= 10
-- операторы OR AND NOT IN
WHERE prod_price <= 10 AND prod_name != 'HER'; составная фильтрация
WHERE (prod_name = 'Milk' OR prod_name = 'Vodka') AND prod_price <= 10; 
WHERE prod_name IN(NOT IN) ('milk', 'vodka'); вхождение(не вхождение)

-- LIKE ------------------------------------------------------------------
-- Используется с WHERE
-- опрератор для исп-я метасимволов для поиска текста в текстовых полях
-- Wildcards запросы
    %       # 0 или более любых символов, не обязательный
    _       # любой 1 символ, обязательный
    [AB]    # 1 любой символ из []
    [^CD]   # 1 любой символ, кроме тех что в []

-- ORDDER BY ---------------------------------------------------------------
ORDER BY col1 (ASC | DESC), col2;   # сортировка по колонкам (прям или обр) 
ORDER BY 1;                         # по номеру столбца
ASC                                 # по возрастанию(по умолчанию)
DESC                                # по убыванию(сначала большие знач) 

-- LIMIT -------------------------------------------------------------------
-- Лимит вывода (исп-ся с SELECT)
LIMIT 5;    # первые 5 записей таблицы

-- OFFSET ------------------------------------------------------------------
-- Отступ  (исп-ся с SELECT)
 OFFSET 1;  # вывод записей после 1 записи

-- GROUP BY - группирует по значениям в колонке(ах) и применяет ф-ию ---------
SELECT  size, COUNT(*)
FROM table
WHERE country = 'Russia'
GROUP BY size
HAVING COUNT(*) > 10;    # доп фильтрация после группировки
ORDER BY COUNT(*) DESC
LIMIT 5



-- JOIN # получение данных из двух таблиц------------------------
# JOIN synopsis
SELECT column1, column2…
FROM table1 AS a            # псевдоним
_____ JOIN table2 AS b      # пробел - (INNER, LEFT, RIGHT, FULL)
ON a.column_x == b.column_x # по этой колонке ищем совпадение
WHERE conditions
ORDER BY column1;
# INNER - только строки где есть совпадение по колонке Х
# LEFT  - все строки с левой таблицы и те что совпали с правой
# RIGHT - все строки с правой и те что совпали в левой
# FULL  - все строки с совпадением и без

-- Подзапросы --------------------------------------------------------------
SELECT id, name, price  # SELECT UPDATE DELETE INSERT
FROM products
WHERE price = (SELECT MAX(price) FROM products) # подзапрос возвр рез-т 1-ым
      id IN (SELECT product_id FROM sales)

-- Транзакции - последов-сть ком-д кот должны быть выполнены все или не одной
START TRANSACTION;
UPDATE.. # послед-сть команд
UPDATE..
...
COMMIT; - принять или ROLLBACK; - откатить

-- Индексы - структура данных в базе для быстрого поиска
-- СУБД автоматически решает использовать их или нет
CREATE INDEX superheroes_name_ind   # create index
ON superheroes(name);               # table(field)

-- VIEW - представления-------------------------------------------------
-- можно создавать из смешанных таблиц(для удобства)
-- ограничивать данные(некоторые столбцы не показывать)
-- сокрытие реализации
CREATE VIEW customers_v id, name    # представление
AS SELECT id, name FROM customers;  # нужные столбцы из таблицы для view

-- Вычисляемые столбцы -------------------------------------------------
-- создание своих столбцов: выражение(некие операции, арифметич или 
   конкатенация, или исп функ-й) + псевдоним
-- вычисляютя для каждой строки
SELECT price*amount AS total...
-- конкатенация
SELECT CONCAT(field1, ' ', 'sometext'), field2.. FROM mytable;
-- арифметич операции + - * /
SELECT field1 * 2 FROM...

-- мат функции ----------------------------------------------------------
CEILING(x)  -- возвращает наименьшее целое число, большее или равное
               x(округляет до целого числа в большую сторону)
               CEILING(4.2)=5 CEILING(-5.8)=-5
ROUND(x, k)	-- округляет значение x до k знаков после запятой,
               если k не указано – x округляется до целого	ROUND(4.361)=4
               ROUND(5.86592,1)=5.9
FLOOR(x)	-- возвращает наибольшее целое число, меньшее или равное x
               (округляет до  целого числа в меньшую сторону) 
               FLOOR(4.2)=4 FLOOR(-5.8)=-6
POWER(x, y)	-- возведение x в степень y	POWER(3,4)=81.0
SQRT(x)	    -- квадратный корень из x SQRT(4)=2.0 SQRT(2)=1.41...
DEGREES(x)	-- конвертирует значение x из радиан в град DEGREES(3) = 171.8...
RADIANS(x)	-- конвертирует значение x из градусов в рад RADIANS(180)=3.14...
ABS(x)	    -- модуль числа x ABS(-1) = 1 ABS(1) = 1
PI()        -- pi = 3.1415926...

-- агрегатные ф-ии ---------------------------------------------------------
-- Возвращают значения для группы
AVG()   -среднее знач
COUNT() -число строк в столбце COUNT(*) -NULL не игнор, COUNT(столб)-игнорир
MAX()   -макс
MIN()   -мин
SUM()   -сумма

-- Логический порядок операций ---------------------------------------------
FROM, включая JOINs -- определить весь рабочий набор данных для запроса
WHERE               -- фильтр данных в соответствии с условиями
GROUP BY            -- объед данных в соотв с одним или неск столбцами
HAVING              -- фильтр сгруппированных данных
Функции WINDOW      -- оконные ф-ии
SELECT              -- выборка данных
DISTINCT            -- отбрасывание повторяющихся значений
UNION               -- объединяет наборы результатов двух запросов в один
ORDER BY            -- сортировка результатов
LIMIT и OFFSET      -- лимит и отступ