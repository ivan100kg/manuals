-- Общие понятия
SQL - Structured Query Language — язык структурированных запросов, с помощью
него пишутся специальные запросы (SQL инструкции) к базе данных с целью
получения этих данных из базы и для манипулирования этими данными.
Гуппы операторов в SQL:

DDL - Data Definition Language – это группа операторов определения данных.
Другими словами, с помощью операторов, входящих в эту группы, мы определяем
структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем
и удаляем их. 
Операторы: CREATE, ALTER, DROP.

DML - Data Manipulation Language – это группа операторов для манипуляции
данными. С помощью этих операторов мы можем добавлять, изменять, удалять и
выгружать данные из базы, т.е. манипулировать ими. 
Операторы: SELECT, INSERT, UPDATE, DELETE.

DCL Data Control Language – группа операторов определения доступа к данным.
Иными словами, это операторы для управления разрешениями, с помощью них мы
можем разрешать или запрещать выполнение определенных операций над объектами базы данных.
Операторы: GRANT, REVOKE, DENY.

TCL Transaction Control Language – группа операторов для управления
транзакциями. Транзакция – это команда или блок команд (инструкций), которые
успешно завершаются как единое целое, при этом в базе данных все внесенные
изменения фиксируются на постоянной основе или отменяются, т.е. все изменения,
внесенные любой командой, входящей в транзакцию, будут отменены.
Операторы: BEGIN, COMMIT, ROLLBACK, SAVE TRANSACTION. 

СУБД - сист упр БД (MySQL, PostgreSQL, Microsoft Access...)
Реляционная база данных — бд, основанная на реляционной модели данных.
Понятие «реляционный» relation («отношение, зависимость, связь»)
Схема   - инфо о БД, о структуре и свойствах ее таблиц
БД      - набор данных хранящихся упорядоченным способом (таблицы)
Таблица - срук-ый файл с данными определенного типа
Столбцы - одиночное поле таблицы с опред. типом данных
Строка  - данные(запись) в таблице счет от НУЛЯ
Первичные ключи - уникально иден-ют каждую строку

=== MySQL ======================================================================
-- Операции с БД
CREATE DATABASE my_base; # создать БД my_base
SHOW DATABASES;          # показать все БД
DROP DATABASE my_base;   # удалить БД
USE my_base              # использовать БД

-- Создание таблицы в базе
CREATE TABLE 
IF NOT EXISTS 
`models`(
         `id` INT AUTO_INCREMENT,            # тип инт, гене-я номера
         `name` VARCHAR(32) NOT NULL,        # строка макс 32 симв
         `size` FLOAT,                       # число с точкой
         `country` VARCHAR(32),              
         `birthday` DATE NULL DEFAULT NULL,  # дата
         `pictures` INT,
         `last_pic` INT,
         PRIMARY KEY (`id`, `name`));        # прайм поля

-- изменить таблицу
ALTER TABLE my_table  
        ADD my_new_field VARCHAR(100)         -доб нов столб после указ-го
        CHANGE old_field new_field VARCHAR(2) -изменяет наз-е и тип колонки
        AFTER id;
        DROP my_new_field;                    -удаление колонки

		
SHOW TABLES;          -показать все таблицы в базе
EXPLAIN my_table;     -показать структуру таблицы
DROP TABLE my_table;  -удалить таблицу

--- if-else
IF search_condition THEN statement_list
    [ELSEIF search_condition THEN statement_list] ...
    [ELSE statement_list]
END IF
================================================================================

=== PostgreSQL =================================================================
sudo -u postgres psql   # start psql as user 'postgres'(авто зареган в Linux) 
psql --help \? \h       # help for everything
\q          # exit from psql
\l          # show databases
\l dbname   # show db 'dbname'
\c dbname   # connect(use) database
\dt         # show all tables in db
\d table_n  # show table 'table_name'
\i sqr.sql  # чтение команд из файла

-- Создать бд
sudo -u postgres createdb mydb   # создать бд из консоли linux
sudo -u postgres dropdb mydb     # удалить бд 'mydb'

-- Типы данных -----------------------------------------------------------------

-- Целые числа
smallint        int2    # целое 2 байта
integer         int4    # 
bigint          int8    #
serial                  # int, автоинкремент

-- Числа фиксированной точности
numeric/decimal         # точность(precision) - общее кол-во цифр
                          масштаб(scale) - кол-во цифр после десятичной точки
                          numeric(5,2) - (точность, масштаб)

-- Числа с плавающей точкой
real                    # 1e-37 - 1e+37
double precision        # 1e-307 - 1e+307

-- Строковые типы
character varying(n)    varchar(n)  # n - max n символов
character(n)            char(n)     # дополняет знач n пробелами - мало исп
text                                # неогран число символов
Синтаксис: 'Some String'
Экранирование: 
    'I''m backslash \\' # ковычки и бэкслэши удваивать
    $$I'm backslash \$$ # с пом знаков доллара
    E'I\'m backsl.. \\' # C-стиль \n \t ... все работает

-- Дата/время
используется формат 'yyyy-mm-dd' 1983-01-23
можно вводить 'Jan 23, 1983' - преобразуется авто
-- дата
SELECT '2016-09-12'::date;      # 2016-09-12
SELECT 'Sep 12, 2016'::date;    # 2016-09-12
SELECT current_date;            # дата сейчас
-- Другой формат даты
SELECT to_char( current_date, 'dd-mm-yyyy' );   # 21-09-2016
-- время
SELECT '21:15'::time;       # 21:15:00
SELECT '21:15:26'::time;    # 21:15:26
SELECT '10:15:16 am'::time; # 21:15:26
SELECT current_time;        # сейчас 23:51:57.293522+03 (+03 часовой пояс)
-- временная отметка (дата+время+[ч пояс])
SELECT timestamptz '2016-09-21 22:25:35';   # 2016-09-21 22:25:35+03
SELECT timestamp '2016-09-21 22:25:35';     # 2016-09-21 22:25:35
SELECT current_timestamp;                   # дата+время+ч.пояс сейчас
-- интервал времени
SELECT '1 year 2 months'::interval; # 1 years 2 mons, считает кол-во
                                      если указать ago - '-1 years -2 mons'
                                      можно исп: microsecond, millisecond,
                                      second, minute, hour, day, week,
                                      month, year, decade, century, millennium
SELECT 'P0001-02-03T04:05:06'::interval;    # альтернативный формат 
                                              1 year 2 mons 3 days 04:05:06
SELECT ('2016-09-16'::timestamp - '2016-09-01'::timestamp)::interval;
-- усечение даты
SELECT (date_trunc('hour', current_timestamp)); # до часа 2016-09-27 22:00:00+03
-- извлечение отдельных полей времени
SELECT extract( 'mon' FROM timestamp '1999-11-27 12:34:56.123459' );    # 11
SELECT EXTRACT(YEAR FROM birthday)		# извлечь год из поля birthday
SELECT AGE('2017-01-01','2011-06-24');	# 5 years 6 mons 7 days

-- Логический тип Boolean
TRUE    't' 'true'  'yes'   'on'    '1' # истина
FALSE   'f' 'false' 'no'    'off'   '0' # ложь

-- Массивы
my_arr integer[]                            # поле в таблице для массива
'{1,2,3,4}'::integer[] == ARRAY[1,2,3,4]    # записи аналогичные
INSERT: '{1,2,3,4}'::integer[]              # добавить данные в т
UPDATE: my_arr = my_arr || 5;               # добавить в массив 5
        my_arr = array_append(my_arr, 5);   # аналогично 5 в конец
        my_arr = array_append(0, my_arr);   # добавить 0 в начало
        my_arr = array_remove(my_arr, 2);   # удалить эл со знач 2
        my_arr[0] = 2, my_arr[3] = 57;      # изменить по индексу
        my_arr[0:2] = ARRAY[9,9];           # изменить по срезу
SELECT: WHERE array_position(my_arr, 3) IS NOT NULL;    # возвращ индекс позиции
                                                          значения иначе null
        WHERE my_arr @> '{4,8}'::integer[]; # возвращ true если в левом массиве
                                              есть все эл-ты с правого массива
        WHERE my_arr && ARRAY[2,4];         # пересечение множеств есть ли
                                              одинак значения, можно исп NOT
        unnest(my_arr) FROM my_table        # развернуть массив в солбец

-- JSON (JavaScript Object Notation)
hobbies jsonb                               # хранение в таблице объекта json
INSERT: '{ "sports": ["football", "golf"],  # вставка объекта
           "home_lib": true,
           "trips": 3}'::jsonb
SELECT: WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;   # есть такой аттрб?
        WHERE hobbies->'sports' @> '["футбол"]'::jsonb;     # аналог как выше
        name, hobbies->'sports' AS sports.. # вывести конкрет ключу объекта
        сount(*) FROM tbl WHERE hobbies ? 'sports'; # кол-во записей с ключом
UPDATE: hobbies || '{"sports": ["хоккей"]}' # добавить знач 'хок' в ключ 'spo'
        hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"') # добавить знач,
                                                                  ключ, №-позиц
--------------------------------------------------------------------------------

-- Значения по умолчанию, ограничения
Ограничения можно писать сразу в поле, либо в конце таблицы.
Можно давать имена ограничениям CONSTRAINT name, либо им дадут авто имена.
Уникальные поля можно указать в конце в виде кортежа (поле1, поле2).
Первичный ключ в таблице 1, но может быть составным (из неск полей) он
    автоматом UNIQUE и NOT NULL.
CREATE TABLE progress
( 
    mark numeric(1) DEFAULT 5,      # значение по умолчанию 5 для 'mark'
    term numeric(1) CHECK (term>0), # ограничение для 'term'(имя огранич авто)
    book numeric(3) NOT NULL,       # не может быть пустым
    gimp numeric(5) UNIQUE,         # уникальное знач
    CONSTRAINT val_book CHECK (book>0), # именованное ограничение для 'book'
    CONSTRAINT uni_book UNIQUE (book),  # ограничение уникальности
    PRIMARY KEY (book),             # первич ключ, можно указать и в поле сразу

);

-- Внешний ключ - поле в таблице, которая ссылается на поле из др таблицы.
Ссылающаяся таблица --> Ссылочная таблица
        подченинная --> главная
можно присваивать имена CONSTRAINT
CREATE TABLE progress
( book numeric(5) REFERENCES students (book),     # ссылка на поле др табл
  ...
  FOREIGN KEY (book)   # либо так в конце, показана многострочная команда
    REFERENCES students (book)  # куда ссылается
    ON DELETE                   # что делать если то на что ссылались удалено
        CASCADE                 # каскадное удаление ссылок на эту запись
        RESTRICT                # при удалении - ошибка, нельзя удалить
        NO ACTION               # то же, но ждет проверки в рамках транзакции
                                  (по умолчанию NO ACTION)
        SET NULL                # устанавливает NULL, поле долж быть не NOT NULL
        SET DEFAULT             # устан default, он должен быть определен в поле
    ON UPDATE ...               # изменение - те же варианты что и при удалении
                                  CASCADE чтобы все ссылки обновить
);

-- Создать таблицу
CREATE TABLE accounts (
	user_id serial PRIMARY KEY,
	username VARCHAR ( 50 ) UNIQUE NOT NULL,
	password VARCHAR ( 50 ) NOT NULL,
	email VARCHAR ( 255 ) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
    last_login TIMESTAMP 
);

-- удалить таблицу
DROP TABLE aircrafts;       

-- Работа с данными ----------------------------------------------------
-- внести данные
INSERT INTO aircrafts  
  COPY aircrafts FROM '/home/user/air.txt'; # внести из текстового файла

-- Соединения таблиц
-- по полям, если есть совпадение в обоих таблицах
SELECT * FROM weather w JOIN cities c ON w.city = c.name;   # псевдонимы  
        ...LEFT OUTER JOIN  # табл в лев части - все строки, справа - совпавш
        также есть правые внешние, полные

-- Агрегатные ф-ии
SELECT max(temp_lo) FROM weather;                       # max
SELECT city, max(temp_lo) FROM weather GROUP BY city;   # группировка
HAVING max(temp_lo) < 40;   # сортировка после группировки работает

-- Представления
CREATE VIEW myview AS   # создать 
    SELECT name, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;
SELECT * FROM myview;   # использование

-- Транзакции
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- ...
COMMIT;

-- CASE expression(if-else)
CASE 
      WHEN condition_1  THEN result_1
      WHEN condition_2  THEN result_2
      [WHEN ...]
      [ELSE else_result]
END

================================================================================

--- SQL ------------------------------------------------------------------------
-- комментарий
#  comment to
/* comment
   to
*/

-- инструкции нечувствительны к регистру USE == Use == use
-- пробелы пожно заменять переносом строк

-- экранирование
`` -такими ковычками можно заэкранировать спец слова и символы
\  -стандартный символ экранирования

-- CREATE -----------------------
-- Создать из другой таблицы
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

-- CRUD ----------------------------------------------------------------------
-- INSERT INTO
-- Добавление данных
# INSERT synopsis
INSERT INTO table           # table
    (column1, column2…)     # в какие колонки внести, если во все - пропустить
VALUES
    (val1, val2...),        # значения, соответссвующие столбцам
    (val3, val4...),        # можно вносить неск записей(списки одинак размера)
    ...
    (valn, valm…);
-- добавить из др таблицы можно использовать WHERE, GROUP BY, ORDER BY
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount FROM supply
WHERE author NOT IN ( SELECT author FROM book );	# также можно исп влож запр

-- SELECT
-- Извлечение данных
# SELECT synopsis
SELECT column1, column2…    # извлечь одно, неск или * - все поля
FROM table                  # имя таблицы
WHERE condition1 AND ...    # где 1 или несколько условий
ORDER BY column1 ... mn2…   # сортировка 
LIMIT n                     # лимит вывода
OFFSET m;                   # отступ

-- UPDATE
-- Изменение данных
# UPDATE synopsis
UPDATE table                # table
SET column1 = 'my var',     # установить новые значения в определенные колонки
    column2 = 1080...
WHERE column_name = '...';  # условие, при котором необходимо изменить запись
-- В запросах на обновление можно использовать несколько таблиц
UPDATE book, supply 		# к полям обращаться через точку
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

-- DELETE
-- Удаление данных
DELETE FROM my_table        # table
WHERE field1 = 'hui';       # удаляет данные при условии(без условия - delall)
WHERE title IN (			# вложенный запрос
        SELECT title 
        FROM book
      );
TRUNCATE TABLE my_table;    # удаляет все и сбрасывает счетчик

-- AS ------------------------------------------------------------------------
SELECT column1 AS col FROM table;         # псевдоним поля
SELECT f.name, f.number_plate, f.violation, 
FROM  fine f, traffic_violation tv

-- WHERE ---------------------------------------------------------------------
-- фильтрация, используется в SELECT/UPDATE/DELETE
-- опрераторы в WHERE:  
    =  >  <  >=  <=  !=(<>) BETWEEN AND IS NULL(пуст поле)
    WHERE price BETWEEN 5 AND 10; # 5 <= price <= 10
-- операторы OR AND NOT IN
WHERE prod_price <= 10 AND prod_name != 'HER'; составная фильтрация
WHERE (prod_name = 'Milk' OR prod_name = 'Vodka') AND prod_price <= 10; 
WHERE prod_name IN(NOT IN) ('milk', 'vodka'); вхождение(не вхождение)

-- LIKE ------------------------------------------------------------------
-- Используется с WHERE
-- опрератор для исп-я метасимволов для поиска текста в текстовых полях
-- Wildcards запросы
    %       # 0 или более любых символов, не обязательный
    _       # любой 1 символ, обязательный
    [AB]    # 1 любой символ из []
    [^CD]   # 1 любой символ, кроме тех что в []

-- ORDDER BY ---------------------------------------------------------------
# сортировка по колонкам (прямая или обратная) 
ORDER BY col1 [ASC | DESC] [NULL FIRST | NULL LAST] [, col2...]
ORDER BY 1;                         # по номеру столбца
ASC                                 # по возрастанию(по умолчанию)
DESC                                # по убыванию(сначала большие знач) 
NULLS FIRST                         # нулевые значения столбца сначала
NULLS LAST                          # нулевые значения столбца вконце

-- LIMIT -------------------------------------------------------------------
-- Лимит вывода (исп-ся с SELECT)
LIMIT 5;    # первые 5 записей таблицы

-- OFFSET ------------------------------------------------------------------
-- Отступ  (исп-ся с SELECT)
 OFFSET 1;  # вывод записей после 1 записи

-- GROUP BY - группирует по значениям в колонке(ах) и применяет ф-ию ---------
-- Агрегатные ф-ии считают общие значения для каждой группы выбранного столбца
-- Все поля в SELECT без агр ф-ий должны быть указаны в GROUP BY
SELECT  size, COUNT(*)      # могут быть как только агр функции, так и поля,
FROM table                    также поля+агр.функции
WHERE country = 'Russia'    # фильтр еще не сгруппированных данных
GROUP BY size               # поля по которым идет группировка
HAVING COUNT(*) > 10;       # доп фильтрация после группировки
ORDER BY COUNT(*) DESC
LIMIT 5

-- DISTINCT -----------------------------------------------------
-- Уникальные значения столбца
SELECT DISTINCT author  # размещается сразу после SELECT
FROM book;                затем нужный столбец
SELECT  author          # аналогичный эффект, только 
FROM book                 уникальные значения столбца
GROUP BY author;

-- JOIN # получение данных из двух таблиц------------------------
# JOIN synopsis
SELECT column1, column2…
FROM table1 AS a            # псевдоним
_____ JOIN table2 AS b      # пробел - (INNER, LEFT, RIGHT, FULL)
ON a.column_x == b.column_x # по этой колонке ищем совпадение
WHERE conditions
ORDER BY column1;
# INNER - только строки где есть совпадение по колонке Х
# LEFT  - все строки с левой таблицы и те что совпали с правой
# RIGHT - все строки с правой и те что совпали в левой
# FULL  - все строки с совпадением и без

-- Подзапросы --------------------------------------------------------------
-- Вложенный запрос исп для выборки данных, которые будут исп в условии 
   отбора записей основного запроса.
-- Применяют для:
   сравнения выражения с результатом вложенного запроса;
   определения того, включено ли выражение в результаты вложенного запроса;
   проверки того, выбирает ли запрос определенные строки.
-- Компоненты вложенного запроса
   SELECT FROM [WHERE GROUP BY HAVING]
-- Влож запросы  могут включаться в WHERE или HAVING, также после SELECT
-- Примеры использования
   WHERE | HAVING выражение оператор_сравнения (вложенный запрос);
   WHERE | HAVING выражение, включающее вложенный запрос;
   WHERE | HAVING выражение [NOT] IN (вложенный запрос);
   WHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос)
-- Операторы ANY и ALL
   Операторы ANY и ALL используются  в SQL для сравнения некоторого значения
   с результирующим набором вложенного запроса, состоящим из одного столбца.
   Можно использовать только с вложенными запросами.
-- ANY в результирующую таблицу будут включены все записи, для которых  
   выраж со знаком отношения верно хотя бы для одного эл резуль-го запроса
-- ALL в результирующую таблицу будут включены все записи, для которых  
   выраж со знаком отношения верно для всех эл результирующего запроса
-- Examples
   amount > ANY (10, 12) эквивалентно amount > 10
   amount < ANY (10, 12) эквивалентно amount < 12
   amount > ALL (10, 12) эквивалентно amount > 12
   amount < ALL (10, 12) эквивалентно amount < 10
  
	SELECT id, name, price  # SELECT UPDATE DELETE INSERT
	FROM products
	WHERE price = (SELECT MAX(price) FROM products) # подзапрос возвр рез-т 1-ым
		  id IN (SELECT product_id FROM sales)
	SELECT title, author, amount, price
	FROM book
	WHERE amount < ALL (
			SELECT AVG(amount) 
			FROM book 
			GROUP BY author);

-- Транзакции - последов-сть ком-д кот должны быть выполнены все или не одной
START TRANSACTION;
UPDATE.. # послед-сть команд
UPDATE..
...
COMMIT; - принять или ROLLBACK; - откатить

-- Индексы - структура данных в базе для быстрого поиска
-- СУБД автоматически решает использовать их или нет
CREATE INDEX superheroes_name_ind   # create index
ON superheroes(name);               # table(field)

-- VIEW - представления-------------------------------------------------
-- можно создавать из смешанных таблиц(для удобства)
-- ограничивать данные(некоторые столбцы не показывать)
-- сокрытие реализации
CREATE VIEW customers_v id, name    # представление
AS SELECT id, name FROM customers;  # нужные столбцы из таблицы для view

-- Вычисляемые столбцы -------------------------------------------------
-- создание своих столбцов: выражение(некие операции, арифметич или 
   конкатенация, или исп функ-й) + псевдоним
-- вычисляютя для каждой строки
SELECT price*amount AS total...
-- конкатенация
SELECT CONCAT(field1, ' ', 'sometext'), field2.. FROM mytable;
-- арифметич операции + - * / %
SELECT field1 * 2 AS doubled_num FROM...
-- функции
SELECT ROUND(field1, 2) AS rounded_num FROM..

-- мат функции ----------------------------------------------------------
CEILING(x)  -- возвращает наименьшее целое число, большее или равное
               x(округляет до целого числа в большую сторону)
               CEILING(4.2)=5 CEILING(-5.8)=-5
ROUND(x, k)	-- округляет значение x до k знаков после запятой,
               если k не указано – x округляется до целого	ROUND(4.361)=4
               ROUND(5.86592,1)=5.9
FLOOR(x)	-- возвращает наибольшее целое число, меньшее или равное x
               (округляет до  целого числа в меньшую сторону) 
               FLOOR(4.2)=4 FLOOR(-5.8)=-6
POWER(x, y)	-- возведение x в степень y	POWER(3,4)=81.0
SQRT(x)	    -- квадратный корень из x SQRT(4)=2.0 SQRT(2)=1.41...
DEGREES(x)	-- конвертирует значение x из радиан в град DEGREES(3) = 171.8...
RADIANS(x)	-- конвертирует значение x из градусов в рад RADIANS(180)=3.14...
ABS(x)	    -- модуль числа x ABS(-1) = 1 ABS(1) = 1
PI()        -- pi = 3.1415926...

-- агрегатные ф-ии ---------------------------------------------------------
-- Считают значения для всего столбца
-- Если есть GROUP BY считают значения столбца для каждой группы
-- В качестве аргумента могут исп не только столбцы, а например мат выр-я
-- К агр ф-ям можно применять мат ф-ии ROUND(AVG(field1*field2),2)
AVG()   -среднее знач
COUNT() -число строк в столбце COUNT(*) -NULL не игнор, COUNT(столб)-игнорир
MAX()   -макс
MIN()   -мин
SUM()   -сумма
SELECT SUM(amount) AS Количество,       # вычислить значения по всей таблице
SUM(price * amount) AS Стоимость          без группировки.
FROM book;

-- Логический порядок операций ---------------------------------------------
FROM, включая JOINs -- определить весь рабочий набор данных для запроса
WHERE               -- фильтр данных в соответствии с условиями
GROUP BY            -- объед данных в соотв с одним или неск столбцами
HAVING              -- фильтр сгруппированных данных
Функции WINDOW      -- оконные ф-ии
SELECT              -- выборка данных
DISTINCT            -- отбрасывание повторяющихся значений
UNION               -- объединяет наборы результатов двух запросов в один
ORDER BY            -- сортировка результатов
LIMIT и OFFSET      -- лимит и отступ
