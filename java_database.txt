--- JDBC ---
    Java Database Connectivity
    Работа Java с различными СУБД.

    Driver - сущность(класс) необходимая для соединения Java с БД,
    для разный СУБД свой драйвер.
    // драйвер(например postgres) можно загрузить с пом maven pom.xml:
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.6</version>
    </dependency>
    // далее загрузим этот класс в JVM с пом загрузчика:
    Class.forName("org.postgres.Driver");           // загрузка класса загрузчиком
    Class.forName(className, true, currentLoader);  // эквивалент того что выше

    Connection      - класс для настройки подключения к БД
    DriverManager   - the basic service for managing a set of JDBC drivers.
    Connection conn = DriverManager.getConnection(
                "jdbc:postgresql://192.168.0.104:5432/mydb",    // url
                "user",                                         // user
                "password");                                    // password
    
    Statement       - объект с пом которого выполняются запросы к БД
    ResultSet       - результат запроса из БД (AutoCloseable)
    Statement stmt = conn.createStatement();   // получить obj Statement
    // SELECT
    ResultSet res = stmt.executeQuery("SELECT * FROM my_table;");
    // DML:INSERT/UPDATE/DELETE; DDL:CREATE/ALTER/DROP
    stmt.executeUpdate("INSERT INTO my_table (name, score) VALUES ('Lisa', 35);");

    // вывод результата
    while (resultSet.next()) {  // похож на Iterator
        String name = resultSet.getString("name");  // выбираем поля
        int size = resultSet.getInt("size");
        String country = resultSet.getString("country");
        System.out.printf("%s\t%d\t%s", name, size, country);
    }

    // закрываем все по порядку
    stmt.close();
    conn.close();

    PreparedStatement   - подготовленный запрос, подходит если есть параметры,
    происх прекомпилляция запроса.
    Statement: используется для простых случаев запроса без параметров.
    PreparedStatement: предварительно компилирует запрос, который может содержать
    входные параметры и выполняться несколько раз с разным набором этих параметров.
    При повторном использовании с одним или несколькими наборами параметров 
    позволяет получить преимущества заранее прекомпилированного и кэшированного 
    запроса, помогая при этом избежать SQL Injection.
    // создание
    PreparedStatement preparedStatement;
    preparedStatement = connection.prepareStatement(
                "INSERT INTO students (name, score) VALUES (?, ?);");
    // использование с нашими параметрами
    preparedStatement.setString(1, "Bob");
    preparedStatement.setInt(2, 50);
    preparedStatement.setObject(3, obj) // если тип неизвестен
    preparedStatement.executeUpdate();  // добавить в БД

    Транзакции
    Скорость вставки нескольких значений,
    если автокоммит не отключить то на каждую вставку строки - одна транзакция,
    выходит во много раз дольше. 80000мс против 44мс
    connection.setAutoCommit(false);    // отключить автокоммит
    for (int i = 0; i < 10000; i++) {
        preparedStatement.setString(1, "Bob" + i);
        preparedStatement.setInt(2, 50 + i % 10);
        preparedStatement.executeUpdate();
    }
    connection.commit();                // завершение транзакции

    Savepoint - точка сохранения состояния базы, позволяет откатиться к этой точке.
    Savepoint sp1 = connection.setSavepoint();  // create
    connection.rollback(sp1);                   // откат

    Example:
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        try (Connection connection = DriverManager.getConnection(
                "jdbc:postgresql://localhost:5432/mydb", 
                "myuser",                                    
                "password"); 
            Statement statement = connection.createStatement()) {
            ResultSet set = statement.executeQuery("SELECT name, size FROM celebrities;");
            while (set.next()) {
                System.out.println(set.getString("name") + set.getInt("size"));
            }
            statement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

--- Hibernate basic ---
    Hibernate - это framework, коткоторый осуществляет CRUD между Java obj и DB.
    Hibernate - реализация спецификации JPA плюс свои фишки.
    Использует для работы с БД под капотом JDBC.
        Java App <===> Hibernate <===> JDBC <===> Database

    CRUD
    CRERATE - INSERT
    READ    - SELECT
    UPDATE  - UPDATE
    DELETE  - DELETE
    
    Плюсы Hibernate:
    Предоставление технологии ORM(Object-to-Relational Mapping) - преобразование
    объекта в строку в таблице и обратное преобразование.
        class Animal {                              animal(table)
            int id;         <==> Hibernate <==>     INTEGER id
            String name;                            VARCHAR(..) name
            int age;                                INTEGER age
            ...                                     ...
        }
    Регулирование SQL-запросами. Нет нужды писать SQL-запросы.
        save() --> Hibernate --> INSERT INTO table ...;
        get()  <-- Hibernate <-- SELECT ...; возвращает объект Java;
    Меньшее кол-во кода по сравнению JDBC.

--- Include Hibernate with Maven ---
    Подключить Hibernate with Maven:
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>6.1.0.Final</version>
      <type>pom</type>
    </dependency>
    
    Подключить JDBC драйвер(например postgres) пом maven pom.xml:
    <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.4.0</version>
    </dependency>

    Создать файл(если не создался) в ресурсах hibernate.cfg.xml
    <!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    <hibernate-configuration>
        <session-factory>
                <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
                <property name="hibernate.connection.username">bestuser</property>
                <property name="hibernate.connection.password">bestuser</property>
                <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/my_db</property>

                <property name="current_session_context_class">thread</property>
                <property name="show_sql">true</property>
                <property name="hibernate.dialect">org.hibernate.dialect</property>

            </session-factory>
        </hibernate-configuration>

    Конфиг связи между классом и таблицей:
        с пом XML - устаревший способ
        с пом Java аннотаций
    
--- Entity class ---
    Entity class - Java class, который отображает инфо определенной таблицы в БД.
    Entity class - POJO class, в кот исп-ся опред Hibernate аннотации для связии 
    класса с БД.
    POJO (Plain Old Java Object) - класс удовлетв условиям:
        private поля 
        getters
        setters
        Constructor without args

    JPA(Java Persistence API) - стандартная спецификация, которая описывает систему
    для уравления сохранением Java объектов в таблицы БД.   
    javax.persistence.*         // пакет для всех аннотаций
    jakarta.persistence.*       // тоже работает(если верхний не пашет)

    @Entity                     // класс имеет отображение в БД
    @Table(name="employees")    // имя таблицы БД, если совпадает можно опустить
    public class Employee {
        @Id                     // Primary Key
        @Column(name = "id")    // имя столбца в БД(если такое же можно опустить)
        @GeneratedValue(strategy = GenerationType.IDENTITY) // автоинкремент по 
        private int id;                                     // правилам БД

        @Column()
        private String name;

        ...

        public Employee() {     // без параметров
        }

        public Employee(String name, String surname, String department, int salary) {
            this.name = name;
            this.surname = surname;
            this.department = department;
            this.salary = salary;
            // id будет генерироваться автоматически
        }

        ... 
        // далее все геттеры, сеттеры на все поля
    }
    GenerationType.IDENTITY     // автоинкремент по правилам БД (лучший выбор)
    GenerationType.SEQUENCE     // полагается на работу Sequence, созданного в БД
    GenerationType.TABLE        // полагается на знач столбца таблицы БД(плох выбор)
    GenerationType.AUTO         // автовыбор - лучше не ставить.

--- CRUD with Hibernate ---
    Первое что необходимо - создать сессию:
    SessionFactory - фабрика по производству сессий.
    SessionFactory читает файл hibernate.cfg.xml для создания опред-х сессий.
    SessionFactory достаточно указать 1 раз - потом переиспользовать.
    Session/сессия - обертка вокруг JDBC для подключ к базе.
    Session/сессия - основа для работы с БД.
    Жизненный цикл сессии небольшой - получаем сессию, делаем операции, закрываем.

    public static void main(String[] args) {
        Employee emp = new Employee("Igor", "Bob", "IT", 450);
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .buildSessionFactory()); 
            Session session = factory.getCurrentSession() {
            
            // открытие и закрытие транзакции - обязательны
            session.beginTransaction();                     // BEGIN transaction
            session.save(emp);                              // INSERT
            Employee emp2 = session.get(Employee.class, 3); // SELECT id=3;
            emp.setSalary(750);                             // UPDATE 1 поле
            session.delete(emp);                            // DELETE 1 запись
            session.getTransaction().commit();              // COMMIT
        }
    }

--- HQL (Hibernate Query Language) CRUD ---
    Используется для вз-ия с БД.
    // SELECT * FROM employees;
    List<Employee> employees = session.createQuery("FROM Employee")
            .getResultList();   // получить список объектов Employee из БД
    "from Employee" // Employee - название класса привяз к таблице
    // SELECT * FROM employees WHERE name = 'Inna';
    "FROM Employee WHERE = 'Inna'"
    // SELECT * FROM employees WHERE  salary > 100 ORDER BY salary DESC;
    "FROM Employee WHERE salary > 100 ORDER BY salary DESC"

    // UPDATE employees SET SET salary=salary+10 WHERE name LIKE '%nn%';
    session.createQuery("UPDATE Employee SET salary=100 WHERE name LIKE '%nn%'")
            .executeUpdate();   // изменить несколько полей

    // DELETE employees WHERE name='Inna';
    session.createQuery("DELETE Employee WHERE name='Inna'")
            .executeUpdate();   // удалить несколько записей
    
--- One-to-One ---
    Uni-directional associations - отношения когда одна сторона не знает о них.
    Bi-directional associations - обе стороны имеют ссылки друг на друга.

    Uni
    Employee --> Details(детали не знают о существовании Employee)

    // Поле 'details_id' в табл employees которое является внешним ключем на
       поле 'id' таблицы details.
    // Добавим в класс Employee поле - внешний ключ на Detail(табл details)
    // Естесственно в БД должны быть соотв таблицы и настроенный связи.
    @OneToOne(cascade = CascadeType.ALL)// тип отношений, cascade -типа как в БД
                                        // при del/upd в связ таблице тоже удал
    @JoinColumn(name = "details_id")    // столбец кот осущ связь с др таблицей
    private Detail empDetail;           // тип - класс кот связан с др таблицей

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)    // добавим еще класс
                .buildSessionFactory()); 
            Session session = factory.getCurrentSession() {
            
            Employee emp = new Employee("Ivan", "Bond", "IT", 750);
            Detail detail = new Detail("Samara", "+70096", "ivan@gmail.com");
            emp.setEmpDetail(detail);
            session.beginTransaction();

            // в итоге транзакции создадутся записи как в employees так и 
               запись в details автоматом(из за cascade = CascadeType.ALL)
            session.save(emp);
            // так можно получить запись из таблицы через др таблицу         
            session.get(Employee.class, 9).getEmpDetail()
            // так удалятся данные работника + автоматом детали
            Employee emp = session.get(Employee.class, 10);
            session.delete(emp);

            session.getTransaction().commit();
        }
    }

    Bi
    Employee <==> Detail, оба класса знают друг о друге.
    // добавим в Detail поле 
    @OneToOne(mappedBy = "empDetail",   // указыаем уже готовую связь one-to-one
              cascade = CascadeType.ALL)// также делаем зависимости 
    private Employee employee;     

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)
                .buildSessionFactory();
            Session session = factory.getCurrentSession()) {
            Employee emp = new Employee("Petr", "Pacman", "Security", 260);
            Detail detail = new Detail("Samara", "+79172076", "oleg@gmail.com");

            emp.setEmpDetail(detail);
            detail.setEmployee(emp);

            session.beginTransaction();
            session.save(detail);   // создается записи в 2-х таблицах
            session.getTransaction().commit();

            // удаление и получение данных как и в Uni, только можно работать
               с обоими классами, так как они связаны как Bi.
        }
    }

    Если необходимо удалить только записи в одной таблице, но не удалять
    автоматом запись из другой:
    @OneToOne(mappedBy = "empDetail",   // меняем CascadeType
              cascade = {CascadeType.PERSIST, CascadeType.REFRESH})
    // далее получаем детали, получаем работкника и обнуляем ссылку на детали
    detail detail = session.get(Detail.class, 1);
    detail.getEmployee().setEmpDetail(null);    // обнуляем ссылку на Detail
    session.delete(detail); 


