--- JDBC ---
    Java Database Connectivity
    Работа Java с различными СУБД.

    Driver - сущность(класс) необходимая для соединения Java с БД,
    для разный СУБД свой драйвер.
    // драйвер(например postgres) можно загрузить с пом maven pom.xml:
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.6</version>
    </dependency>
    // далее загрузим этот класс в JVM с пом загрузчика:
    Class.forName("org.postgres.Driver");           // загрузка класса загрузчиком
    Class.forName(className, true, currentLoader);  // эквивалент того что выше

    Connection      - класс для настройки подключения к БД
    DriverManager   - the basic service for managing a set of JDBC drivers.
    Connection conn = DriverManager.getConnection(
                "jdbc:postgresql://192.168.0.104:5432/mydb",    // url
                "user",                                         // user
                "password");                                    // password
    
    Statement       - объект с пом которого выполняются запросы к БД
    ResultSet       - результат запроса из БД (AutoCloseable)
    Statement stmt = conn.createStatement();   // получить obj Statement
    // SELECT
    ResultSet res = stmt.executeQuery("SELECT * FROM my_table;");
    // DML:INSERT/UPDATE/DELETE; DDL:CREATE/ALTER/DROP
    stmt.executeUpdate("INSERT INTO my_table (name, score) VALUES ('Lisa', 35);");

    // вывод результата
    while (resultSet.next()) {  // похож на Iterator
        String name = resultSet.getString("name");  // выбираем поля
        int size = resultSet.getInt("size");
        String country = resultSet.getString("country");
        System.out.printf("%s\t%d\t%s", name, size, country);
    }

    // закрываем все по порядку
    stmt.close();
    conn.close();

    PreparedStatement   - подготовленный запрос, подходит если есть параметры,
    происх прекомпилляция запроса.
    Statement: используется для простых случаев запроса без параметров.
    PreparedStatement: предварительно компилирует запрос, который может содержать
    входные параметры и выполняться несколько раз с разным набором этих параметров.
    При повторном использовании с одним или несколькими наборами параметров 
    позволяет получить преимущества заранее прекомпилированного и кэшированного 
    запроса, помогая при этом избежать SQL Injection.
    // создание
    PreparedStatement preparedStatement;
    preparedStatement = connection.prepareStatement(
                "INSERT INTO students (name, score) VALUES (?, ?);");
    // использование с нашими параметрами
    preparedStatement.setString(1, "Bob");
    preparedStatement.setInt(2, 50);
    preparedStatement.setObject(3, obj) // если тип неизвестен
    preparedStatement.executeUpdate();  // добавить в БД

    Транзакции
    Скорость вставки нескольких значений,
    если автокоммит не отключить то на каждую вставку строки - одна транзакция,
    выходит во много раз дольше. 80000мс против 44мс
    connection.setAutoCommit(false);    // отключить автокоммит
    for (int i = 0; i < 10000; i++) {
        preparedStatement.setString(1, "Bob" + i);
        preparedStatement.setInt(2, 50 + i % 10);
        preparedStatement.executeUpdate();
    }
    connection.commit();                // завершение транзакции

    Savepoint - точка сохранения состояния базы, позволяет откатиться к этой точке.
    Savepoint sp1 = connection.setSavepoint();  // create
    connection.rollback(sp1);                   // откат

    Example:
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        try (Connection connection = DriverManager.getConnection(
                "jdbc:postgresql://localhost:5432/mydb", 
                "myuser",                                    
                "password"); 
            Statement statement = connection.createStatement()) {
            ResultSet set = statement.executeQuery("SELECT name, size FROM celebrities;");
            while (set.next()) {
                System.out.println(set.getString("name") + set.getInt("size"));
            }
            statement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

--- Hibernate basic ---
    Hibernate - это framework, коткоторый осуществляет CRUD между Java obj и DB.
    Hibernate - реализация спецификации JPA плюс свои фишки.
    Использует для работы с БД под капотом JDBC.
        Java App <===> Hibernate <===> JDBC <===> Database

    CRUD
    CRERATE - INSERT
    READ    - SELECT
    UPDATE  - UPDATE
    DELETE  - DELETE
    
    Плюсы Hibernate:
    Предоставление технологии ORM(Object-to-Relational Mapping) - преобразование
    объекта в строку в таблице и обратное преобразование.
        class Animal {                              animal(table)
            int id;         <==> Hibernate <==>     INTEGER id
            String name;                            VARCHAR(..) name
            int age;                                INTEGER age
            ...                                     ...
        }
    Регулирование SQL-запросами. Нет нужды писать SQL-запросы.
        save() --> Hibernate --> INSERT INTO table ...;
        get()  <-- Hibernate <-- SELECT ...; возвращает объект Java;
    Меньшее кол-во кода по сравнению JDBC.

--- Include Hibernate with Maven ---
    Подключить Hibernate with Maven:
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>6.1.0.Final</version>
      <type>pom</type>
    </dependency>
    
    Подключить JDBC драйвер(например postgres) пом maven pom.xml:
    <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.4.0</version>
    </dependency>

    Создать файл(если не создался) в ресурсах hibernate.cfg.xml
    <!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    <hibernate-configuration>
        <session-factory>
                <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
                <property name="hibernate.connection.username">bestuser</property>
                <property name="hibernate.connection.password">bestuser</property>
                <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/my_db</property>

                <property name="current_session_context_class">thread</property>
                <property name="show_sql">true</property>
                <property name="hibernate.dialect">org.hibernate.dialect</property>

            </session-factory>
        </hibernate-configuration>

    Конфиг связи между классом и таблицей:
        с пом XML - устаревший способ
        с пом Java аннотаций
    
--- Entity class ---
    Entity class - Java class, который отображает инфо определенной таблицы в БД.
    Entity class - POJO class, в кот исп-ся опред Hibernate аннотации для связии 
    класса с БД.
    POJO (Plain Old Java Object) - класс удовлетв условиям:
        private поля 
        getters
        setters
        Constructor without args

    JPA(Java Persistence API) - стандартная спецификация, которая описывает систему
    для уравления сохранением Java объектов в таблицы БД.   
    javax.persistence.*         // пакет для всех аннотаций
    jakarta.persistence.*       // тоже работает(если верхний не пашет)

    @Entity                     // класс имеет отображение в БД
    @Table(name="employees")    // имя таблицы БД, если совпадает можно опустить
    public class Employee {
        @Id                     // Primary Key
        @Column(name = "id")    // имя столбца в БД(если такое же можно опустить)
        @GeneratedValue(strategy = GenerationType.IDENTITY) // автоинкремент по 
        private int id;                                     // правилам БД

        @Column()
        private String name;

        ...

        public Employee() {     // без параметров
        }

        public Employee(String name, String surname, String department, int salary) {
            this.name = name;
            this.surname = surname;
            this.department = department;
            this.salary = salary;
            // id будет генерироваться автоматически
        }

        ... 
        // далее все геттеры, сеттеры на все поля
    }
    GenerationType.IDENTITY     // автоинкремент по правилам БД (лучший выбор)
    GenerationType.SEQUENCE     // полагается на работу Sequence, созданного в БД
    GenerationType.TABLE        // полагается на знач столбца таблицы БД(плох выбор)
    GenerationType.AUTO         // автовыбор - лучше не ставить.

--- CRUD with Hibernate ---
    Первое что необходимо - создать сессию:
    SessionFactory - фабрика по производству сессий.
    SessionFactory читает файл hibernate.cfg.xml для создания опред-х сессий.
    SessionFactory достаточно указать 1 раз - потом переиспользовать.
    Session/сессия - обертка вокруг JDBC для подключ к базе.
    Session/сессия - основа для работы с БД.
    Жизненный цикл сессии небольшой - получаем сессию, делаем операции, закрываем.

    public static void main(String[] args) {
        SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .buildSessionFactory();
        try{
            Session session = factory.getCurrentSession();
            Employee emp = new Employee("Ivan", "Bond", "IT", 500); // без id
            session.beginTransaction();         // BEGIN открыть транзакцию(обяз)
            
            session.save(emp);                  // INSERT (вставляем наш класс))
            session.get(Employee.class, 2);     // SELECT * FROM ... WHERE id=2;

            session.getTransaction().commit();  // COMMIT(обязательно) закр сессию
        } finally {
            factory.close() // закрыть фабрику
        }
    }

    HQL (Hibernate Query Language) используется для вз-я с БД.
    List<Employee> employees = session.createQuery("from Employee").getResultList();
    "from Employee" // Employee - название класса привяз к таблице