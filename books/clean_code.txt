# Чистый код


Имена
Переменные/классы - существительное с описанием что это
Функции - глагол что делает ф-ия

good                            | bad
--------------------------------+----------------------------------------------
    переменные:
int daysSinceCreation           | d, nameString, customerObject
String source, destination      | String p1, p2
firstName, lastName             | addrFirstName, addrLastName
    константы:
WORK_DAYS_PER_WEEK              | m_dsc
    классы:
class Product, WikiPage         | class ProductData, ProductInfo, DtaRcrd102
class Customer, Account         | Manager, Processor, Data, Info
AccountAddress                  | GSDAccountAddress
    списки:
List<String> accounts           | List<String> accountList
    интерфейсы:
interface ShapeFactory          | interface IShapeFactory
    методы:
postPayment, savePage, isRed    | holyHandGrenade
getColor, setMusic              |
    доп конструкторы:
Complex.FromRealNumber(19.0)    | new Complex(23.0) 

Функции:
Функции по своим именам как бы рассказывают историю программы
1. компактность
2. должна выполнять одну операцию на одном уровне абстракции
3. максимум 2 аргумента, если больше - передаем объект
4. аргументы - флаги недопустимы! функция выполняет 1-ну операцию
5. try-catch засовываем в отдельную ф-ю обработки ошибок, потом вызываем 
   нужную функцию, в которой просто прописываем throws
6. Не повторяющийся код

Комментарии:
1. стараемся писать код без комментов, чтобы было понятно по названиям
2. не комментим код, а исправляем чтобы было понятно
3. автор - не нужен
4. заголовки функций - не комментируем, изменяем название если не понятно
5. полезные комметны:
        TODO - что должно делаться в будущем
        Javadoc - для общедоступных API

Форматирование:
1. Переменные следует объявлять как можно ближе к месту использования
2. В функциях все локальные переменные объявляем вначале
3. Если функция вызывает другую - то она должна распологаться рядом
4. Вызываемая функция - находится ниже вызывающей
5. Ширина строк 80/120 символов
6. Отступы между функциями стандарт

Объекты и структуры данных:
1. Абстракция данных - создаем интерфейсы для достума к данным объекта
   скрываем реализацию с помощью интерфейсов
   public interface Vehicle {
       double getPercentFuelRemaining();    // норм
   }
2. Антисимметрия данных/объектов
   Объекты - скрывают свои данные за абстракциями, предоставляют функции
   Структуры данных - раскрывают свои данные(public поля) 
                      и не имеют осмысленных функций
   Лучше использовать ООП подход или процедурный зависит от ситуации
3. Закон Деметры
   Метод не должен вызывать методы объектов, возвращаемых любыми из
   разрешенных функций
4. Избегаем цепочек вызовов 
   final String outputDir = ctxt.options.scratchDir.absolutePath
5. Избегаем гибридов - классы с открытыми полями или геттерами/сеттерами
   и также имеющих функции. Всегда делим - объекты+интерфейсы / структуры
6. Используем ДТО

Обработка ошибок
1. Вызывающая сторона не должна каждый раз проверять возврат с метода,
   нужно всё это дело поместить в try-catch и уже в вызываемых функциях
   выбрасывать ошибки
2. Используем/создаем непроверяемые исключения
3. Создаем содержательные сообщения для своих исключений
4. Класс обертка, допустим метод API может выбрасывать разные исключения,
   мы строим класс который вызыает метод API и обрабатывает все исключения,
   выбрасывая одно наше исключение с понятным текстом что за ошибка
5. Не возвращай null, лучше выдать ошибку, либо вернуть объект особого случая
   Если списки - верни Collections.emptyList()
   Если объект - то сделать исключение/спец объект
6. Не передавай null(если только на сторонние API)
   В методах в которые передаются null можно выбрасывать свои сключения, если
   приходит null, либо bcgjk
   assert param != null : "param is null" : return param+2;

Границы
1. Не используй при передаче по API интерфейс Map
2. Исследуем API с помощью тестов - вызываем методы стороннего
   апи в том виде в котором хотим использовать это апи
3. используй log4j
4. Используем учебные тесты
5. Используем несуществующий код, допустим определяем интерфейс
   для работы с апи методом, имплементим своим пока тестовым классом,
   тестируем, потом добавляем реализацию правильного класса, имплементим

Классы
1. Расположение элементов:
   public static var
   private static var
   private var
   constructor
   public function
   private function
2. Классы должны быть компактными
3. Класс имеет одну ответственность
