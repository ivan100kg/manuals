Паттерны проектирования

Отношения между сущностями:
Наследование    - IS-A позволяет классу-наследнику унаследовать функц parent класса
                  parentClass ◁—— child (незакрашенная стрелка, сплошная линия)
Реализация      - определение интерфейса и его реализация в классах
                  Interface ◁-- child (незакрашенная стрелка, пунктир линия)
Ассоциация:     - объект класса A содержит или использует объект класса B
                  classA *——>1 classB (обыч стрелка, 1- один *-ко многим)
    Композиция  - HAS-A класс A содержит объект класса B(сильная связь)
                  classA ♦——> classB (закраш ромб)
    Агрегация   - HAS-A класс A использует ссылку на сущ-й объект класса B(слаб)
                  classA ◊——> classB (незакраш ромб)

ac - abstract class
cc - concrete class
i  - interface

Абстрактный класс или интерфейс:
Абстрактные классы - если надо определить общий функционал для родственных объектов
Интерфейсы - если нам надо определить функционал для группы разрозненных объектов,
которые могут быть никак не связаны между собой

Паттерн - описание взаимодействия объектов и классов, адаптированных для решения
общей задачи проектирования в конкретном контексте 

Состав паттерна:
имя         - имя паттерна(Стратегия)
задача      - описание того, когда следует применяеть паттерн
решение     - абстрактное описание решения задачи с помощью классов и объектов
результаты  - следствия применения паттерна

Назначения паттернов:
порождающие - процесс создания объектов
структурные - композизия объектов и классов
поведения   - взаимодействие между классами/объектами

Классификаци паттернов по типу:
1. Паттерны классов - описывают отношения между классами посредством наследования. 
Отношения между классами определяются на стадии компиляции.
2. Паттерны объектов - описывают отношения между объектами. 
Эти отношения возникают на этапе выполнения, поэтому обладают большей гибкостью

Паттерны:
    ------------+------------------+-----------------+------------------------
          \ цель| порождающие      | структурные     | поведения  
    уровень\    |                  |                 |
    ------------+------------------+-----------------+------------------------
    class       | Factory Method   | Adapter(class)  | Template method
                |                  |                 | Interpreter
    ------------+------------------+-----------------+------------------------
    object      | Abstract Factory | Adapter(object) | Command
                | Builder          | Bridge          | Chain of responsibility
                | Prototype        | Composite       | Iterator
                | Singleton        | Decorator       | Mediator
                |                  | Facade          | Memento
                |                  | Flyweight       | Observer
                |                  | Proxy           | State
                |                  |                 | Strategy
                |                  |                 | Visitor
    ------------+------------------+-----------------+------------------------

Изменяемые паттернами элементы дизайна:
--------------+------------------------+--------------------------------
Назначение    | Паттерн проектирования | Аспекты, которые можно изменять
--------------+------------------------+--------------------------------
Порождающие   | Абстрактная фабрика    | Семейства порождаемых объектов
паттерны      | Одиночка               | Единственный экземпляр класса
              | Прототип               | Класс, из которого инстанцируется объект
              | Строитель              | Способ создания составного объекта
              | Фабричный метод        | Инстанцируемый подкласс объекта
--------------+------------------------+--------------------------------
Структурные   | Адаптер                | Интерфейс к объекту
паттерны      | Декоратор              | Обязанности объекта без порождения подкласса
              | Заместитель            | Способ доступа к объекту, его местоположение
              | Компоновщик            | Структура и состав объекта
              | Мост                   | Реализация объекта
              | Приспособленец         | Накладные расходы на хранение объектов
              | Фасад                  | Интерфейс к подсистеме
--------------+------------------------+--------------------------------
Паттерны      | Интерпретатор          | Грамматика и интерпретация языка
поведения     | Итератор               | Способ обхода элементов агрегата
              | Команда                | Время и способ выполнения запроса
              | Наблюдатель            | Множество объектов, зависящих от другого объекта;
              |                        | способ, которым зависимые объекты поддерживают 
              |                        | себя в актуальном состоянии
              | Посетитель             | Операции, которые можно применить к объекту
              |                        | или объектам, не меняя класса
              | Посредник              | Объекты, взаимодействующие между собой,
              |                        | и способ их коопераций
              | Состояние              | Состояние объекта
              | Стратегия              | Алгоритм
              | Хранитель              | Закрытая информация, хранящаяся вне объекта,
              |                        | и время ее сохранения
              | Цепочка обязанностей   | Объект, выполняющий запрос
              | Шаблонный метод        | Шаги алгоритма
--------------+------------------------+--------------------------------

Как решать задачи проектирования с помощью паттернов:
1. Разложить систему на объекты два пути:
    - сформулировать задачу письменно, выделить из получившейся фразы существительные и глаголы,
      после чего создать соответствующие классы и операции
    - сосредоточиться на отношениях и разделении обязанностей в системе. Можно построить модель
      реального мира или перенести выявленные при анализе объекты на свой дизайн
    Многие объекты возникают в проекте из построенной в ходе анализа модели.
    Нередко появляются и классы, у которых нет прототипов в реальном мире(алгоритм, процесс..)
2. Определение степени детализации объекта:
    Размеры и число объектов могут сильно варьироваться. С их помощью может
    быть представлено все, начиная с уровня аппаратуры и до законченных приложений,
    здесь и потребуются паттерны проектирования.
3. Специфицирование интерфейсов объекта
    определение всех сигнатур методов интерфейсов(возвращаемый тип, имя, принимаемые параметры)
    Тип – это имя, используемое для обозначения конкретного интерфейса
    У одного объекта может быть много типов(множ-я имплементация), 
    объекты разных классов могут иметь один и тот же тип
4. Специфицирование реализации объектов
    реализация объекта определяется его классом. Класс специфицирует внутренние данные объекта
    и его представление, а также операции, которые объект может выполнять
5. Программирование в соответствии с интерфейсом, а не с реализацией
    Не объявляйте переменные как экземпляры конкретных классов. Вместо этого придерживайтесь 
    интерфейса, определенного абстрактным классом.
6. Механизмы повторного использования
    - Наследование и композиция - предпочитайте композицию наследованию класса
      используйте делегирование, если это упростит дизайн (состояние, стратегия, посетитель)
    - Делегирование - показывает, что наследование как механизм повторного использования всегда 
      можно заменить композицией.
    - Наследование и параметризованные типы(обобжения/дженерики)
      используем если есть возможность
7. Сравнение структур времени выполнения и времени компиляции
    Агрегирование   - один объект владеет другим или несет за него ответственность
    Осведомленность - слабая связь, ссылка, ассоциация
8. Проектирование с учетом будущих изменений
    Системы необходимо проектировать с учетом их дальнейшего развития. Для проектирования системы,
    устойчивой к таким изменениям, следует предположить, как она будет изменяться на протяжении 
    отведенного ей времени жизни
    - создавайте объекты косвенно
      Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
    - не включать запросы в код
      Паттерны проектирования: цепочка обязанностей, команда;
    - ограничивать платформенные зависимости
      Паттерны проектирования: абстрактная фабрика, мост
    - Сокрытие реализации объекта от клиентов
      Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель
    - алгоритмы, вероятность изменения которых высока, следует изолировать.
      Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель
    - Использовать слабую связанность вместо сильной(монолитное приложение), применяются такие 
      методы,как абстрактные связи и разбиение на слои.
      Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, 
      фасад, посредник, наблюдатель
    - Применять композиция объектов и делегирование – альтернативы наследованию 
      для комбинирования поведений
      Паттерны проектирования: мост, цепочка обязанностей, компоновщик, декоратор, 
      наблюдатель, стратегия
    - Не нужно изменять класс - используем вместо этого паттерны
      Паттерны проектирования: адаптер, декоратор, посетитель.
9. Прикладные программы
    высший приоритет при проектировании прикладной программы(редактор документов):
    - не проектировать и не реализовывать больше, чем необходимо
    - уменьшить число зависимостей
    - ослабление связанности
    - ограничения платформенных зависимостей и разбиения системы на отдельные слои
10. Библиотеки/Фреймворки
    Использовать готовые библиотеки/фреймворки, не изобретать заново колесо

Как выбирать паттерн проектирования:
1. подумать, как паттерны решают проблемы проектирования(выше)
2. пролистать разделы каталога, описывающие назначение паттернов, посмотреть цель паттерна
3. изучить взаимосвязи паттернов
4. проанализировать паттерны со сходными целями
5. разобраться в причинах, вызывающих перепроектирование
6. посмотреть, что в дизайне должно быть изменяющимся

Как пользоваться паттерном проектирования:
1. прочитать описание
2. изучить и понять структуру, участников и отношения
3. посмотреть пример
4. придумать соотв имена участникам(AnimalFactory)
5. определить классы и интерфейсы, установить отношения наследования, определить поля
6. определить имена операций, встречающихся в паттерне
7. реализовать операции(методы)



=== Порождающие паттерны =================================================

Фабричный метод (Factory Method)*
    это паттерн, который используется для создания объектов без указания конкретных классов. 
    Вместо этого он определяет методы-фабрики, которые отвечают за создание и возвращение новых объектов
    
    Применяется когда заранее неизвестно, объекты каких типов необходимо создавать.
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой:
    в нее можно легко вводить новые классы, объекты которых система должна создавать.
    Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

    Animal dog = dogFactory.createAnimal();   // в зависимости от фабрики создается тот или иной
    Animal cat = catFactory.createAnimal();

Абстрактная фабрика (Abstract Factory)
    Абстрактная фабрика похожа на фабричный метод, но она создает не только один объект, 
    а целую семейство объектов. Она предоставляет интерфейс для создания различных связанных 
    объектов без указания конкретных классов этих объектов. Вместо этого абстрактная фабрика 
    предоставляет набор интерфейсов, каждый из которых может использоваться для создания 
    семейства связанных объектов.
    
    Применяется когда система не должна зависеть от способа создания и компоновки новых объектов
    Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

    Cat domesticCat = domesticAnimalFactory.createCat();  // фабрика создающая несколько типов
    Dog domesticDog = domesticAnimalFactory.createDog();

Одиночка (Singleton, Синглтон)*
    это паттерн, который гарантирует, что у класса есть только один экземпляр, 
    и предоставляет глобальную точку доступа к этому экземпляру.

    Применяется когда необходимо, чтобы для класса существовал только один экземпляр

Прототип (Prototype)
    Паттерн Прототип (Prototype) позволяет создавать объекты на основе уже ранее созданных 
    объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.

    Применять когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
    Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов 
    из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
    Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация 
    с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

Строитель (Builder)
    Шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.

    Применять когда процесс создания нового объекта не должен зависеть от того, 
    из каких частей этот объект состоит и как эти части связаны между собой
    Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

=== Структурные паттерны =================================================

Декоратор (Decorator)*
    это паттерн, который позволяет динамически добавлять новое поведение к объектам, оборачивая их в декораторы

    Применять когда надо динамически добавлять к объекту новые функциональные возможности. 
    При этом данные возможности могут быть сняты с объекта
    Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей
    и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. 
    Еще больше она может разрастись, если нам необходимо создать классы, 
    реализующие все возможные сочетания добавляемых функциональностей.

    есть интерфейс и конкретный класс его реализ
    есть абстрактный класс имплементирующий тот же интерфейс, принимающий в коструктор тот конкретный класс
    и есть неск классов реализ абстрактный класс, делая с тем конкретным классо что хотят
    Animal animal3 = new CanSwimDecorator(new CanFlyDecorator(new BasicAnimal()));
    можно заворачивать один в другой

Адаптер (Adapter)*
    предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного 
    паттерна мы можем использовать вместе классы с несовместимыми интерфейсами

    Применять когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
    Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

    Есть конкретный класс(адаптируемый/который будем адаптировать)
    Есть интерфейс, с каким то методом.
    Адаптер - это класс, который принимает в конструктор наш конкретный класс и реализует интерфейс,
    и уже в имплементируемом методе испольтзует методы нашего конкретного класса и что-то с ним делает

Фасад (Facade)*
    позволяет скрыть сложность системы с помощью предоставления упрощенного интерфейса для взаимодействия с ней

    Применнять когда имеется сложная система, и необходимо упростить с ней работу. 
    Фасад позволит определить одну точку взаимодействия между клиентом и системой.
    Когда надо уменьшить количество зависимостей между клиентом и сложной системой. 
    Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
    Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой 
    отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга

    Есть конкретный большой класс Animal
    Фасад - это класс принимающий в конструктор объект Animal и предоставляет свои методы,
    которые дергают методы Animal. 

Компоновщик (Composite)
    предназначен для организации структуры объектов в древовидную иерархию. 
    Суть паттерна заключается в том, что все объекты (листья и контейнеры) имеют одинаковый интерфейс, 
    что позволяет работать с ними единообразно

    Применять когда объекты должны быть реализованы в виде иерархической древовидной структуры
    Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. 
    То есть целое и его части должны реализовать один и тот же интерфейс

    Есть интерфейс Animal с 2-мя методами(run, jump)
    Есть конкретные классы(Cat, Dog), которые реализуют Animal (листья)
    Также есть конкретный класс Zoo также реализующий Animal, но у него есть поля - списки Animal,
    в которые можно добавлять каких угодно животных реализ Animal.
    И все те же методы Animal(run, jump) реализуются уже для всего списка сразу 

Заместитель (Proxy)
    предоставляет объект-заместитель, который управляет доступом к другому объекту. 
    То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его

    Применять когда надо осуществлять взаимодействие по сети, а объект-проси должен имитировать 
    поведения объекта в другом адресном пространстве. Использование прокси позволяет снизить накладные 
    издержки при передачи данных через сеть. Подобная ситуация еще называется удалённый заместитель (remote proxies)
    Когда нужно управлять доступом к ресурсу, создание которого требует больших затрат. Реальный объект создается 
    только тогда, когда он действительно может понадобится, а до этого все запросы к нему обрабатывает прокси-объект.
    Подобная ситуация еще называется виртуальный заместитель (virtual proxies)
    Когда необходимо разграничить доступ к вызываемому объекту в зависимости от прав вызывающего объекта. 
    Подобная ситуация еще называется защищающий заместитель (protection proxies)
    Когда нужно вести подсчет ссылок на объект или обеспечить потокобезопасную работу с реальным объектом. 
    Подобная ситуация называется "умные ссылки" (smart reference)

    Есть интерфейс Animal с допустим методом makeSound()
    Есть конкретный класс например Dog, реализующий интерфес, реализующий метод makeSound()
    Есть конкретный прокси класс который также реализует интерфейс + создает внутри класс Dog, 
    при реализации своего метода, он вызывает метод Dog + накручивает свою логику вокруг. 

Мост (Bridge)
    позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, 
    и реализацию можно было изменять независимо друг от друга

    Применять когда надо избежать постоянной привязки абстракции к реализации
    Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. 
    То есть изменения в абстракции не должно привести к изменениям в реализации

    Есть интерфейс допустим звук_животного и два контретный класса его реализ
    Также есть абс класс животного Animal, который принимает в конструктор звук_животного
    и использует его, + два конкретный класса его реализ
    Так вот - мы разделили абстракцию Animal с реализацией звука, можем менять звуки,
    не затрагивая основную абстракцию Animal

Приспособленец (Flyweight)
    позволяет использовать разделяемые объекты сразу в нескольких контекстах. 
    Данный паттерн используется преимущественно для оптимизации работы с памятью

    Применять когда приложение использует большое количество однообразных объектов, 
    из-за чего происходит выделение большого количества памяти
    Когда часть состояния объекта, которое является изменяемым, можно вынести во вне. 
    Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

    Есть фабрика которая имеет HashMap с объектами, и если запрашивается один тип объектов,
    то новый не создается, а возвращается готовый объект

=== Паттерны поведения ===================================================================

Стратегия (Strategy)
    определяет набор алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
    В зависимости от ситуации мы можем легко заменить один используемый алгоритм другим.
    При этом замена алгоритма происходит независимо от объекта, который использует данный алгоритм

    Когда есть несколько родственных классов, которые отличаются поведением. Можно задать один основной класс, 
    а разные варианты поведения вынести в отдельные классы и при необходимости их применять
    Когда необходимо обеспечить выбор из нескольких вариантов алгоритмов, 
    которые можно легко менять в зависимости от условий
    Когда необходимо менять поведение объектов на стадии выполнения программы
    Когда класс, применяющий определенную функциональность, ничего не должен знать о ее реализации

    Есть интерфейс Стратегия например MoveStrategy с методом move
    Есть два конкретных класса реализующих этот интерфейс, например бежать, идти
    Контекст - это конкретный класс(Animal), который содержит ссылку на общую стратегию, приним ее в конструкторе.
    также имеет метод типа move, который вызывает метод move у стратегии и в зависимости от
    стратегии происхродит действие

Наблюдатель (Observer)
    использует отношение "один ко многим". В этом отношении есть один наблюдаемый объект и множество наблюдателей.
    И при изменении наблюдаемого объекта автоматически происходит оповещение всех наблюдателей

    Применять когда система состоит из множества классов, объекты которых должны находиться в согласованных состояниях
    Когда общая схема взаимодействия объектов предполагает две стороны: одна рассылает сообщения и является главным,
    другая получает сообщения и реагирует на них. Отделение логики обеих сторон позволяет их рассматривать независимо 
    и использовать отдельно друга от друга.
    Когда существует один объект, рассылающий сообщения, и множество подписчиков, которые получают сообщения. 
    При этом точное число подписчиков заранее неизвестно и процессе работы программы может изменяться.

    Есть интерфейс Observable у которого есть список наблюдателей - реализующих интерфейс Наблюдателя,
    есть возможность их туда добавлять и удалять,
    при изменении объекта реализующего Observable - вызываем у всего листа наблюдателей метод, прокидываем в него this
    т.е. сам наблюдаемый объект - а там вертим как хотим

Команда (Command)
    позволяет инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. 
    Этот объект запроса на действие и называется командой. При этом объекты, инициирующие запросы на выполнение действия,
    отделяются от объектов, которые выполняют это действие

    Применять когда надо передавать в качестве параметров определенные действия, вызываемые в ответ на другие действия.
    То есть когда необходимы функции обратного действия в ответ на определенные действия.
    Когда необходимо обеспечить выполнение очереди запросов, а также их возможную отмену.
    Когда надо поддерживать логгирование изменений в результате запросов. Использование логов может помочь восстановить
    состояние системы - для этого необходимо будет использовать последовательность запротоколированных команд.

    Конкретный класс(Animal) и Интерфейс команды с методом execute и классы реализующие этот интерфейс, принимающие
    объект класса Animal и деогающие какие-то методы. Также есть класс отправитель, который принимает тип команды,
    и выплолняет метод execute()

Шаблонный метод (Template Method)
    определяет общий алгоритм поведения подклассов, позволяя им переопределить отдельные шаги 
    этого алгоритма без изменения его структуры

    Применять когда планируется, что в будущем подклассы должны будут переопределять 
    различные этапы алгоритма без изменения его структуры
    Когда в классах, реализующим схожий алгоритм, происходит дублирование кода. 
    Вынесение общего кода в шаблонный метод уменьшит его дублирование в подклассах.

    есть абстрактный класс Animal с методом, в котором вызываются несколько других абс метода, которые
    нужно переопределить наследнимкам. Созав конкретный класс, реализуя все методы, можно
    вызвать этот общий метод, чтобы все переопределенные вызвались

Итератор (Iterator)
    предоставляет абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта 
    без раскрытия его внутренней структуры

    позволяет осуществить перебор коллекций с помощью foreach

    Классом реализуем Iterable а также создаем влож класс реализующий Iterator и уже в нем закладывам логику 

Состояние (State)
    позволяет объекту изменять свое поведение в зависимости от внутреннего состояния

    Применять когда поведение объекта должно зависеть от его состояния и может изменяться динамически во время выполнения
    Когда в коде методов объекта используются многочисленные условные конструкции, 
    выбор которых зависит от текущего состояния объекта

    есть интерфейс состояния, и пара методов. Наследники переопределяют его по содержимому
    есть класс Animal который имеет одним из полей это состояние и в зависимости какое состояние прокидываем
    в Анимал - меняются реализации методов, в методах мы просто дергаем методы состояния

Цепочка Обязанностей (Chain of responsibility)
    позволяет избежать жесткой привязки отправителя запроса к получателю. 
    Все возможные обработчики запроса образуют цепочку, а сам запрос перемещается по этой цепочке. 
    Каждый объект в этой цепочке при получении запроса выбирает, либо закончить обработку запроса, 
    либо передать запрос на обработку следующему по цепочке объекту.

    Применять когда имеется более одного объекта, который может обработать определенный запрос
    Когда надо передать запрос на выполнение одному из нескольких объектов, точно не определяя, какому именно объекту
    Когда набор объектов задается динамически

Посредник (Mediator)
    обеспечивает взаимодействие множества объектов без необходимости ссылаться друг на друга. 
    Тем самым достигается слабосвязанность взаимодействующих объектов

    Применять когда имеется множество взаимосвязаных объектов, связи между которыми сложны и запутаны.
    Когда необходимо повторно использовать объект, однако повторное использование затруднено в силу 
    сильных связей с другими объектами

    Есть класс медиатор , который внутри себя обрабатывает список объектов класса Анимал, дергая его методы
    Есть абстрактный класс Анимал с этим медиатором и реализации, которые вызывая какой-либо метод вызывают
    методы медиатора, а он оповещает весь список классов.

Хранитель (Memento)
    позволяет выносить внутреннее состояние объекта за его пределы для последующего возможного 
    восстановления объекта без нарушения принципа инкапсуляции

    Применять когда нужно сохранить состояние объекта для возможного последующего восстановления
    когда сохранение состояния должно проходить без нарушения принципа инкапсуляции

    есть класс Анимал и класс хранитель с такими же полями, в Анимал есть методы который возвращает
    этого хранителя с полями как у Анимал. Сохраняем эти состояния в третий класс, и получатся различные
    состояния в одном списке 

