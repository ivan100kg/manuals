Паттерны проектирования

Отношения между сущностями:
Наследование    - IS-A позволяет классу-наследнику унаследовать функц parent класса
                  parentClass ◁—— child (незакрашенная стрелка, сплошная линия)
Реализация      - определение интерфейса и его реализация в классах
                  Interface ◁-- child (незакрашенная стрелка, пунктир линия)
Ассоциация:     - объект класса A содержит или использует объект класса B
                  classA *——>1 classB (обыч стрелка, 1- один *-ко многим)
    Композиция  - HAS-A класс A содержит объект класса B
                  classA ♦——> classB (закраш ромб)
    Агрегация   - HAS-A класс A использует ссылку на сущ-й объект класса B
                  classA ◊——> classB (незакраш ромб)

ac - abstract class
cc - concrete class
i  - interface

Абстрактный класс или интерфейс:
Абстрактные классы - если надо определить общий функционал для родственных объектов
Интерфейсы - если нам надо определить функционал для группы разрозненных объектов,
которые могут быть никак не связаны между собой

Паттерн - описание взаимодействия объектов и классов, адаптированных для решения
общей задачи проектирования в конкретном контексте 

Состав паттерна:
имя         - имя паттерна(Стратегия)
задача      - описание того, когда следует применяеть паттерн
решение     - абстрактное описание решения задачи с помощью классов и объектов
результаты  - следствия применения паттерна

Назначения паттернов:
порождающие - процесс создания объектов
структурные - композизия объектов и классов
поведения   - взаимодействие между классами/объектами

Классификаци паттернов по типу:
1. Паттерны классов - описывают отношения между классами посредством наследования. 
Отношения между классами определяются на стадии компиляции.
2. Паттерны объектов - описывают отношения между объектами. 
Эти отношения возникают на этапе выполнения, поэтому обладают большей гибкостью


Паттерны:
    ------------+------------------+-----------------+------------------------
          \ цель| порождающие      | структурные     | поведения  
    уровень\    |                  |                 |
    ------------+------------------+-----------------+------------------------
    class       | Factory Method   | Adapter(class)  | Template method
                |                  |                 | Interpreter
    ------------+------------------+-----------------+------------------------
    object      | Abstract Factory | Adapter(object) | Command
                | Builder          | Bridge          | Chain of responsibility
                | Prototype        | Composite       | Iterator
                | Singleton        | Decorator       | Mediator
                |                  | Facade          | Memento
                |                  | Flyweight       | Observer
                |                  | Proxy           | State
                |                  |                 | Strategy
                |                  |                 | Visitor
    ------------+------------------+-----------------+------------------------

Как решать задачи проектирования с помощью паттернов:
1. Разложить систему на объекты два пути:
    - сформулировать задачу письменно, выделить из получившейся фразы существительные и глаголы,
      после чего создать соответствующие классы и операции
    - сосредоточиться на отношениях и разделении обязанностей в системе. Можно построить модель
      реального мира или перенести выявленные при анализе объекты на свой дизайн
2. Определение степени детализации объекта:
    Размеры и число объектов могут сильно варьироваться. С их помощью может
    быть представлено все, начиная с уровня аппаратуры и до законченных приложений,
    здесь и потребуются паттерны проектирования
3. Специфицирование интерфейсов объекта
4. Специфицирование реализации объектов

=== Порождающие паттерны =================================================

Фабричный метод (Factory Method)*
    это паттерн, который используется для создания объектов без указания конкретных классов. 
    Вместо этого он определяет методы-фабрики, которые отвечают за создание и возвращение новых объектов
    
    Применяется когда заранее неизвестно, объекты каких типов необходимо создавать.
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой:
    в нее можно легко вводить новые классы, объекты которых система должна создавать.
    Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

    Animal dog = dogFactory.createAnimal();   // в зависимости от фабрики создается тот или иной
    Animal cat = catFactory.createAnimal();

Абстрактная фабрика (Abstract Factory)
    Абстрактная фабрика похожа на фабричный метод, но она создает не только один объект, 
    а целую семейство объектов. Она предоставляет интерфейс для создания различных связанных 
    объектов без указания конкретных классов этих объектов. Вместо этого абстрактная фабрика 
    предоставляет набор интерфейсов, каждый из которых может использоваться для создания 
    семейства связанных объектов.
    
    Применяется когда система не должна зависеть от способа создания и компоновки новых объектов
    Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

    Cat domesticCat = domesticAnimalFactory.createCat();  // фабрика создающая несколько типов
    Dog domesticDog = domesticAnimalFactory.createDog();

Одиночка (Singleton, Синглтон)*
    это паттерн, который гарантирует, что у класса есть только один экземпляр, 
    и предоставляет глобальную точку доступа к этому экземпляру.

    Применяется когда необходимо, чтобы для класса существовал только один экземпляр

Прототип (Prototype)
    Паттерн Прототип (Prototype) позволяет создавать объекты на основе уже ранее созданных 
    объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.

    Применять когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
    Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов 
    из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
    Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация 
    с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

Строитель (Builder)
    Шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.

    Применять когда процесс создания нового объекта не должен зависеть от того, 
    из каких частей этот объект состоит и как эти части связаны между собой
    Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

=== Структурные паттерны =================================================

Декоратор (Decorator)*
    это паттерн, который позволяет динамически добавлять новое поведение к объектам, оборачивая их в декораторы

    Применять когда надо динамически добавлять к объекту новые функциональные возможности. 
    При этом данные возможности могут быть сняты с объекта
    Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей
    и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. 
    Еще больше она может разрастись, если нам необходимо создать классы, 
    реализующие все возможные сочетания добавляемых функциональностей.

    есть интерфейс и конкретный класс его реализ
    есть абстрактный класс имплементирующий тот же интерфейс, принимающий в коструктор тот конкретный класс
    и есть неск классов реализ абстрактный класс, делая с тем конкретным классо что хотят
    Animal animal3 = new CanSwimDecorator(new CanFlyDecorator(new BasicAnimal()));
    можно заворачивать один в другой

Адаптер (Adapter)*
    предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного 
    паттерна мы можем использовать вместе классы с несовместимыми интерфейсами

    Применять когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
    Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

    Есть конкретный класс(адаптируемый/который будем адаптировать)
    Есть интерфейс, с каким то методом.
    Адаптер - это класс, который принимает в конструктор наш конкретный класс и реализует интерфейс,
    и уже в имплементируемом методе испольтзует методы нашего конкретного класса и что-то с ним делает