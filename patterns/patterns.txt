Паттерны проектирования

Отношения между сущностями:
Наследование    - IS-A позволяет классу-наследнику унаследовать функц parent класса
                  parentClass ◁—— child (незакрашенная стрелка, сплошная линия)
Реализация      - определение интерфейса и его реализация в классах
                  Interface ◁-- child (незакрашенная стрелка, пунктир линия)
Ассоциация:     - объект класса A содержит или использует объект класса B
                  classA *——>1 classB (обыч стрелка, 1- один *-ко многим)
    Агрегация   - HAS-A класс A содержит объект класса B(сильная связь)
                  classA ♦——> classB (закраш ромб)
    Композиция  - HAS-A класс A использует ссылку на сущ-й объект класса B(слаб)
                  classA ◊——> classB (незакраш ромб)

ac - abstract class
cc - concrete class
i  - interface

Абстрактный класс или интерфейс:
Абстрактные классы - если надо определить общий функционал для родственных объектов
Интерфейсы - если нам надо определить функционал для группы разрозненных объектов,
которые могут быть никак не связаны между собой

Паттерн - описание взаимодействия объектов и классов, адаптированных для решения
общей задачи проектирования в конкретном контексте 

Состав паттерна:
имя         - имя паттерна(Стратегия)
задача      - описание того, когда следует применяеть паттерн
решение     - абстрактное описание решения задачи с помощью классов и объектов
результаты  - следствия применения паттерна

Назначения паттернов:
порождающие - процесс создания объектов
структурные - композизия объектов и классов
поведения   - взаимодействие между классами/объектами

Классификаци паттернов по типу:
1. Паттерны классов - описывают отношения между классами посредством наследования. 
Отношения между классами определяются на стадии компиляции.
2. Паттерны объектов - описывают отношения между объектами. 
Эти отношения возникают на этапе выполнения, поэтому обладают большей гибкостью

Паттерны:
    ------------+------------------+-----------------+------------------------
          \ цель| порождающие      | структурные     | поведения  
    уровень\    |                  |                 |
    ------------+------------------+-----------------+------------------------
    class       | Factory Method   | Adapter(class)  | Template method
                |                  |                 | Interpreter
    ------------+------------------+-----------------+------------------------
    object      | Abstract Factory | Adapter(object) | Command
                | Builder          | Bridge          | Chain of responsibility
                | Prototype        | Composite       | Iterator
                | Singleton        | Decorator       | Mediator
                |                  | Facade          | Memento
                |                  | Flyweight       | Observer
                |                  | Proxy           | State
                |                  |                 | Strategy
                |                  |                 | Visitor
    ------------+------------------+-----------------+------------------------

Изменяемые паттернами элементы дизайна:
--------------+------------------------+--------------------------------
Назначение    | Паттерн проектирования | Аспекты, которые можно изменять
--------------+------------------------+--------------------------------
Порождающие   | Абстрактная фабрика    | Семейства порождаемых объектов
паттерны      | Одиночка               | Единственный экземпляр класса
              | Прототип               | Класс, из которого инстанцируется объект
              | Строитель              | Способ создания составного объекта
              | Фабричный метод        | Инстанцируемый подкласс объекта
--------------+------------------------+--------------------------------
Структурные   | Адаптер                | Интерфейс к объекту
паттерны      | Декоратор              | Обязанности объекта без порождения подкласса
              | Заместитель            | Способ доступа к объекту, его местоположение
              | Компоновщик            | Структура и состав объекта
              | Мост                   | Реализация объекта
              | Приспособленец         | Накладные расходы на хранение объектов
              | Фасад                  | Интерфейс к подсистеме
--------------+------------------------+--------------------------------
Паттерны      | Интерпретатор          | Грамматика и интерпретация языка
поведения     | Итератор               | Способ обхода элементов агрегата
              | Команда                | Время и способ выполнения запроса
              | Наблюдатель            | Множество объектов, зависящих от другого объекта;
              |                        | способ, которым зависимые объекты поддерживают 
              |                        | себя в актуальном состоянии
              | Посетитель             | Операции, которые можно применить к объекту
              |                        | или объектам, не меняя класса
              | Посредник              | Объекты, взаимодействующие между собой,
              |                        | и способ их коопераций
              | Состояние              | Состояние объекта
              | Стратегия              | Алгоритм
              | Хранитель              | Закрытая информация, хранящаяся вне объекта,
              |                        | и время ее сохранения
              | Цепочка обязанностей   | Объект, выполняющий запрос
              | Шаблонный метод        | Шаги алгоритма
--------------+------------------------+--------------------------------

Как решать задачи проектирования с помощью паттернов:
1. Разложить систему на объекты два пути:
    - сформулировать задачу письменно, выделить из получившейся фразы существительные и глаголы,
      после чего создать соответствующие классы и операции
    - сосредоточиться на отношениях и разделении обязанностей в системе. Можно построить модель
      реального мира или перенести выявленные при анализе объекты на свой дизайн
    Многие объекты возникают в проекте из построенной в ходе анализа модели.
    Нередко появляются и классы, у которых нет прототипов в реальном мире(алгоритм, процесс..)
2. Определение степени детализации объекта:
    Размеры и число объектов могут сильно варьироваться. С их помощью может
    быть представлено все, начиная с уровня аппаратуры и до законченных приложений,
    здесь и потребуются паттерны проектирования.
3. Специфицирование интерфейсов объекта
    определение всех сигнатур методов интерфейсов(возвращаемый тип, имя, принимаемые параметры)
    Тип – это имя, используемое для обозначения конкретного интерфейса
    У одного объекта может быть много типов(множ-я имплементация), 
    объекты разных классов могут иметь один и тот же тип
4. Специфицирование реализации объектов
    реализация объекта определяется его классом. Класс специфицирует внутренние данные объекта
    и его представление, а также операции, которые объект может выполнять
5. Программирование в соответствии с интерфейсом, а не с реализацией
    Не объявляйте переменные как экземпляры конкретных классов. Вместо этого придерживайтесь 
    интерфейса, определенного абстрактным классом.
6. Механизмы повторного использования
    - Наследование и композиция - предпочитайте композицию наследованию класса
      используйте делегирование, если это упростит дизайн (состояние, стратегия, посетитель)
    - Делегирование - показывает, что наследование как механизм повторного использования всегда 
      можно заменить композицией.
    - Наследование и параметризованные типы(обобжения/дженерики)
      используем если есть возможность
7. Сравнение структур времени выполнения и времени компиляции
    Агрегирование   - один объект владеет другим или несет за него ответственность
    Осведомленность - слабая связь, ссылка, ассоциация
8. Проектирование с учетом будущих изменений
    Системы необходимо проектировать с учетом их дальнейшего развития. Для проектирования системы,
    устойчивой к таким изменениям, следует предположить, как она будет изменяться на протяжении 
    отведенного ей времени жизни
    - создавайте объекты косвенно
      Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
    - не включать запросы в код
      Паттерны проектирования: цепочка обязанностей, команда;
    - ограничивать платформенные зависимости
      Паттерны проектирования: абстрактная фабрика, мост
    - Сокрытие реализации объекта от клиентов
      Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель
    - алгоритмы, вероятность изменения которых высока, следует изолировать.
      Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель
    - Использовать слабую связанность вместо сильной(монолитное приложение), применяются такие 
      методы,как абстрактные связи и разбиение на слои.
      Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, 
      фасад, посредник, наблюдатель
    - Применять композиция объектов и делегирование – альтернативы наследованию 
      для комбинирования поведений
      Паттерны проектирования: мост, цепочка обязанностей, компоновщик, декоратор, 
      наблюдатель, стратегия
    - Не нужно изменять класс - используем вместо этого паттерны
      Паттерны проектирования: адаптер, декоратор, посетитель.
9. Прикладные программы
    высший приоритет при проектировании прикладной программы(редактор документов):
    - не проектировать и не реализовывать больше, чем необходимо
    - уменьшить число зависимостей
    - ослабление связанности
    - ограничения платформенных зависимостей и разбиения системы на отдельные слои
10. Библиотеки/Фреймворки
    Использовать готовые библиотеки/фреймворки, не изобретать заново колесо

Как выбирать паттерн проектирования:
1. подумать, как паттерны решают проблемы проектирования(выше)
2. пролистать разделы каталога, описывающие назначение паттернов, посмотреть цель паттерна
3. изучить взаимосвязи паттернов
4. проанализировать паттерны со сходными целями
5. разобраться в причинах, вызывающих перепроектирование
6. посмотреть, что в дизайне должно быть изменяющимся

Как пользоваться паттерном проектирования:
1. прочитать описание
2. изучить и понять структуру, участников и отношения
3. посмотреть пример
4. придумать соотв имена участникам(AnimalFactory)
5. определить классы и интерфейсы, установить отношения наследования, определить поля
6. определить имена операций, встречающихся в паттерне
7. реализовать операции(методы)



=== Порождающие паттерны =================================================

Фабричный метод (Factory Method)*
    это паттерн, который используется для создания объектов без указания конкретных классов. 
    Вместо этого он определяет методы-фабрики, которые отвечают за создание и возвращение новых объектов
    
    Применяется когда заранее неизвестно, объекты каких типов необходимо создавать.
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой:
    в нее можно легко вводить новые классы, объекты которых система должна создавать.
    Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

    Animal dog = dogFactory.createAnimal();   // в зависимости от фабрики создается тот или иной
    Animal cat = catFactory.createAnimal();

Абстрактная фабрика (Abstract Factory)
    Абстрактная фабрика похожа на фабричный метод, но она создает не только один объект, 
    а целую семейство объектов. Она предоставляет интерфейс для создания различных связанных 
    объектов без указания конкретных классов этих объектов. Вместо этого абстрактная фабрика 
    предоставляет набор интерфейсов, каждый из которых может использоваться для создания 
    семейства связанных объектов.
    
    Применяется когда система не должна зависеть от способа создания и компоновки новых объектов
    Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

    Cat domesticCat = domesticAnimalFactory.createCat();  // фабрика создающая несколько типов
    Dog domesticDog = domesticAnimalFactory.createDog();

Одиночка (Singleton, Синглтон)*
    это паттерн, который гарантирует, что у класса есть только один экземпляр, 
    и предоставляет глобальную точку доступа к этому экземпляру.

    Применяется когда необходимо, чтобы для класса существовал только один экземпляр

Прототип (Prototype)
    Паттерн Прототип (Prototype) позволяет создавать объекты на основе уже ранее созданных 
    объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.

    Применять когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
    Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов 
    из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
    Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация 
    с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

Строитель (Builder)
    Шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.

    Применять когда процесс создания нового объекта не должен зависеть от того, 
    из каких частей этот объект состоит и как эти части связаны между собой
    Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

=== Структурные паттерны =================================================

Декоратор (Decorator)*
    это паттерн, который позволяет динамически добавлять новое поведение к объектам, оборачивая их в декораторы

    Применять когда надо динамически добавлять к объекту новые функциональные возможности. 
    При этом данные возможности могут быть сняты с объекта
    Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей
    и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. 
    Еще больше она может разрастись, если нам необходимо создать классы, 
    реализующие все возможные сочетания добавляемых функциональностей.

    есть интерфейс и конкретный класс его реализ
    есть абстрактный класс имплементирующий тот же интерфейс, принимающий в коструктор тот конкретный класс
    и есть неск классов реализ абстрактный класс, делая с тем конкретным классо что хотят
    Animal animal3 = new CanSwimDecorator(new CanFlyDecorator(new BasicAnimal()));
    можно заворачивать один в другой

Адаптер (Adapter)*
    предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного 
    паттерна мы можем использовать вместе классы с несовместимыми интерфейсами

    Применять когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
    Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

    Есть конкретный класс(адаптируемый/который будем адаптировать)
    Есть интерфейс, с каким то методом.
    Адаптер - это класс, который принимает в конструктор наш конкретный класс и реализует интерфейс,
    и уже в имплементируемом методе испольтзует методы нашего конкретного класса и что-то с ним делает

Фасад (Facade)*
    позволяет скрыть сложность системы с помощью предоставления упрощенного интерфейса для взаимодействия с ней

    Применнять когда имеется сложная система, и необходимо упростить с ней работу. 
    Фасад позволит определить одну точку взаимодействия между клиентом и системой.
    Когда надо уменьшить количество зависимостей между клиентом и сложной системой. 
    Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
    Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой 
    отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга

    Есть конкретный большой класс Animal
    Фасад - это класс принимающий в конструктор объект Animal и предоставляет свои методы,
    которые дергают методы Animal. 

Компоновщик (Composite)
    предназначен для организации структуры объектов в древовидную иерархию. 
    Суть паттерна заключается в том, что все объекты (листья и контейнеры) имеют одинаковый интерфейс, 
    что позволяет работать с ними единообразно

    Применять когда объекты должны быть реализованы в виде иерархической древовидной структуры
    Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. 
    То есть целое и его части должны реализовать один и тот же интерфейс

    Есть интерфейс Animal с 2-мя методами(run, jump)
    Есть конкретные классы(Cat, Dog), которые реализуют Animal (листья)
    Также есть конкретный класс Zoo также реализующий Animal, но у него есть поля - списки Animal,
    в которые можно добавлять каких угодно животных реализ Animal.
    И все те же методы Animal(run, jump) реализуются уже для всего списка сразу 

Заместитель (Proxy)
    предоставляет объект-заместитель, который управляет доступом к другому объекту. 
    То есть создается объект-суррогат, который может выступать в роли другого объекта и замещать его

    Применять когда надо осуществлять взаимодействие по сети, а объект-проси должен имитировать 
    поведения объекта в другом адресном пространстве. Использование прокси позволяет снизить накладные 
    издержки при передачи данных через сеть. Подобная ситуация еще называется удалённый заместитель (remote proxies)
    Когда нужно управлять доступом к ресурсу, создание которого требует больших затрат. Реальный объект создается 
    только тогда, когда он действительно может понадобится, а до этого все запросы к нему обрабатывает прокси-объект.
    Подобная ситуация еще называется виртуальный заместитель (virtual proxies)
    Когда необходимо разграничить доступ к вызываемому объекту в зависимости от прав вызывающего объекта. 
    Подобная ситуация еще называется защищающий заместитель (protection proxies)
    Когда нужно вести подсчет ссылок на объект или обеспечить потокобезопасную работу с реальным объектом. 
    Подобная ситуация называется "умные ссылки" (smart reference)

    Есть интерфейс Animal с допустим методом makeSound()
    Есть конкретный класс например Dog, реализующий интерфес, реализующий метод makeSound()
    Есть конкретный прокси класс который также реализует интерфейс + создает внутри класс Dog, 
    при реализации своего метода, он вызывает метод Dog + накручивает свою логику вокруг. 

Мост (Bridge)
    позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, 
    и реализацию можно было изменять независимо друг от друга

    Применять когда надо избежать постоянной привязки абстракции к реализации
    Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. 
    То есть изменения в абстракции не должно привести к изменениям в реализации

    Есть интерфейс допустим звук_животного и два контретный класса его реализ
    Также есть абс класс животного Animal, который принимает в конструктор звук_животного
    и использует его, + два конкретный класса его реализ
    Так вот - мы разделили абстракцию Animal с реализацией звука, можем менять звуки,
    не затрагивая основную абстракцию Animal

Приспособленец (Flyweight)
    позволяет использовать разделяемые объекты сразу в нескольких контекстах. 
    Данный паттерн используется преимущественно для оптимизации работы с памятью

    Применять когда приложение использует большое количество однообразных объектов, 
    из-за чего происходит выделение большого количества памяти
    Когда часть состояния объекта, которое является изменяемым, можно вынести во вне. 
    Вынесение внешнего состояния позволяет заменить множество объектов небольшой группой общих разделяемых объектов.

    Есть фабрика которая имеет HashMap с объектами, и если запрашивается один тип объектов,
    то новый не создается, а возвращается готовый объект