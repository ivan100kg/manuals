Паттерны проектирования

Отношения между сущностями:
Наследование    - IS-A позволяет классу-наследнику унаследовать функц parent класса
                  parentClass ◁—— child (незакрашенная стрелка, сплошная линия)
Реализация      - определение интерфейса и его реализация в классах
                  Interface ◁-- child (незакрашенная стрелка, пунктир линия)
Ассоциация:     - объект класса A содержит или использует объект класса B
                  classA *——>1 classB (обыч стрелка, 1- один *-ко многим)
    Агрегация   - HAS-A класс A содержит объект класса B(сильная связь)
                  classA ♦——> classB (закраш ромб)
    Композиция  - HAS-A класс A использует ссылку на сущ-й объект класса B(слаб)
                  classA ◊——> classB (незакраш ромб)

ac - abstract class
cc - concrete class
i  - interface

Абстрактный класс или интерфейс:
Абстрактные классы - если надо определить общий функционал для родственных объектов
Интерфейсы - если нам надо определить функционал для группы разрозненных объектов,
которые могут быть никак не связаны между собой

Паттерн - описание взаимодействия объектов и классов, адаптированных для решения
общей задачи проектирования в конкретном контексте 

Состав паттерна:
имя         - имя паттерна(Стратегия)
задача      - описание того, когда следует применяеть паттерн
решение     - абстрактное описание решения задачи с помощью классов и объектов
результаты  - следствия применения паттерна

Назначения паттернов:
порождающие - процесс создания объектов
структурные - композизия объектов и классов
поведения   - взаимодействие между классами/объектами

Классификаци паттернов по типу:
1. Паттерны классов - описывают отношения между классами посредством наследования. 
Отношения между классами определяются на стадии компиляции.
2. Паттерны объектов - описывают отношения между объектами. 
Эти отношения возникают на этапе выполнения, поэтому обладают большей гибкостью


Паттерны:
    ------------+------------------+-----------------+------------------------
          \ цель| порождающие      | структурные     | поведения  
    уровень\    |                  |                 |
    ------------+------------------+-----------------+------------------------
    class       | Factory Method   | Adapter(class)  | Template method
                |                  |                 | Interpreter
    ------------+------------------+-----------------+------------------------
    object      | Abstract Factory | Adapter(object) | Command
                | Builder          | Bridge          | Chain of responsibility
                | Prototype        | Composite       | Iterator
                | Singleton        | Decorator       | Mediator
                |                  | Facade          | Memento
                |                  | Flyweight       | Observer
                |                  | Proxy           | State
                |                  |                 | Strategy
                |                  |                 | Visitor
    ------------+------------------+-----------------+------------------------

Как решать задачи проектирования с помощью паттернов:
1. Разложить систему на объекты два пути:
    - сформулировать задачу письменно, выделить из получившейся фразы существительные и глаголы,
      после чего создать соответствующие классы и операции
    - сосредоточиться на отношениях и разделении обязанностей в системе. Можно построить модель
      реального мира или перенести выявленные при анализе объекты на свой дизайн
    Многие объекты возникают в проекте из построенной в ходе анализа модели.
    Нередко появляются и классы, у которых нет прототипов в реальном мире(алгоритм, процесс..)
2. Определение степени детализации объекта:
    Размеры и число объектов могут сильно варьироваться. С их помощью может
    быть представлено все, начиная с уровня аппаратуры и до законченных приложений,
    здесь и потребуются паттерны проектирования.
3. Специфицирование интерфейсов объекта
    определение всех сигнатур методов интерфейсов(возвращаемый тип, имя, принимаемые параметры)
    Тип – это имя, используемое для обозначения конкретного интерфейса
    У одного объекта может быть много типов(множ-я имплементация), 
    объекты разных классов могут иметь один и тот же тип
4. Специфицирование реализации объектов
    реализация объекта определяется его классом. Класс специфицирует внутренние данные объекта
    и его представление, а также операции, которые объект может выполнять
5. Программирование в соответствии с интерфейсом, а не с реализацией
    Не объявляйте переменные как экземпляры конкретных классов. Вместо этого придерживайтесь 
    интерфейса, определенного абстрактным классом.
6. Механизмы повторного использования
    - Наследование и композиция - предпочитайте композицию наследованию класса
      используйте делегирование, если это упростит дизайн (состояние, стратегия, посетитель)
    - Делегирование - показывает, что наследование как механизм повторного использования всегда 
      можно заменить композицией.
    - Наследование и параметризованные типы(обобжения/дженерики)
      используем если есть возможность
7. Сравнение структур времени выполнения и времени компиляции
    Агрегирование   - один объект владеет другим или несет за него ответственность
    Осведомленность - слабая связь, ссылка, ассоциация
8. Проектирование с учетом будущих изменений
    Системы необходимо проектировать с учетом их дальнейшего развития. Для проектирования системы,
    устойчивой к таким изменениям, следует предположить, как она будет изменяться на протяжении 
    отведенного ей времени жизни
    - создавайте объекты косвенно
      Паттерны проектирования: абстрактная фабрика, фабричный метод, прототип;
    - не включать запросы в код
      Паттерны проектирования: цепочка обязанностей, команда;
    - ограничивать платформенные зависимости
      Паттерны проектирования: абстрактная фабрика, мост
    - Сокрытие реализации объекта от клиентов
      Паттерны проектирования: абстрактная фабрика, мост, хранитель, заместитель
    - алгоритмы, вероятность изменения которых высока, следует изолировать.
      Паттерны проектирования: мост, итератор, стратегия, шаблонный метод, посетитель
    - Использовать слабую связанность вместо сильной(монолитное приложение), применяются такие 
      методы,как абстрактные связи и разбиение на слои.
      Паттерны проектирования: абстрактная фабрика, мост, цепочка обязанностей, команда, 
      фасад, посредник, наблюдатель
    - Применять композиция объектов и делегирование – альтернативы наследованию 
      для комбинирования поведений
      Паттерны проектирования: мост, цепочка обязанностей, компоновщик, декоратор, 
      наблюдатель, стратегия
    - Не нужно изменять класс - используем вместо этого паттерны
      Паттерны проектирования: адаптер, декоратор, посетитель.
9. Прикладные программы
    высший приоритет при проектировании прикладной программы(редактор документов):
    - не проектировать и не реализовывать больше, чем необходимо
    - уменьшить число зависимостей
    - ослабление связанности
    - ограничения платформенных зависимостей и разбиения системы на отдельные слои
10. Библиотеки/Фреймворки
    Использовать готовые библиотеки/фреймворки, не изобретать заново колесо

Как выбирать паттерн проектирования:
1. подумать, как паттерны решают проблемы проектирования(выше)
2. пролистать разделы каталога, описывающие назначение паттернов, посмотреть цель паттерна
3. изучить взаимосвязи паттернов
4. проанализировать паттерны со сходными целями
5. разобраться в причинах, вызывающих перепроектирование
6. посмотреть, что в дизайне должно быть изменяющимся

Как пользоваться паттерном проектирования:
1. прочитать описание
2. изучить и понять структуру, участников и отношения
3. посмотреть пример
4. придумать соотв имена участникам(AnimalFactory)
5. определить классы и интерфейсы, установить отношения наследования, определить поля
6. определить имена операций, встречающихся в паттерне
7. реализовать операции(методы)

=== Порождающие паттерны =================================================

Фабричный метод (Factory Method)*
    это паттерн, который используется для создания объектов без указания конкретных классов. 
    Вместо этого он определяет методы-фабрики, которые отвечают за создание и возвращение новых объектов
    
    Применяется когда заранее неизвестно, объекты каких типов необходимо создавать.
    Когда система должна быть независимой от процесса создания новых объектов и расширяемой:
    в нее можно легко вводить новые классы, объекты которых система должна создавать.
    Когда создание новых объектов необходимо делегировать из базового класса классам наследникам

    Animal dog = dogFactory.createAnimal();   // в зависимости от фабрики создается тот или иной
    Animal cat = catFactory.createAnimal();

Абстрактная фабрика (Abstract Factory)
    Абстрактная фабрика похожа на фабричный метод, но она создает не только один объект, 
    а целую семейство объектов. Она предоставляет интерфейс для создания различных связанных 
    объектов без указания конкретных классов этих объектов. Вместо этого абстрактная фабрика 
    предоставляет набор интерфейсов, каждый из которых может использоваться для создания 
    семейства связанных объектов.
    
    Применяется когда система не должна зависеть от способа создания и компоновки новых объектов
    Когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными

    Cat domesticCat = domesticAnimalFactory.createCat();  // фабрика создающая несколько типов
    Dog domesticDog = domesticAnimalFactory.createDog();

Одиночка (Singleton, Синглтон)*
    это паттерн, который гарантирует, что у класса есть только один экземпляр, 
    и предоставляет глобальную точку доступа к этому экземпляру.

    Применяется когда необходимо, чтобы для класса существовал только один экземпляр

Прототип (Prototype)
    Паттерн Прототип (Prototype) позволяет создавать объекты на основе уже ранее созданных 
    объектов-прототипов. То есть по сути данный паттерн предлагает технику клонирования объектов.

    Применять когда конкретный тип создаваемого объекта должен определяться динамически во время выполнения
    Когда нежелательно создание отдельной иерархии классов фабрик для создания объектов-продуктов 
    из параллельной иерархии классов (как это делается, например, при использовании паттерна Абстрактная фабрика)
    Когда клонирование объекта является более предпочтительным вариантом нежели его создание и инициализация 
    с помощью конструктора. Особенно когда известно, что объект может принимать небольшое ограниченное число возможных состояний.

Строитель (Builder)
    Шаблон проектирования, который инкапсулирует создание объекта и позволяет разделить его на различные этапы.

    Применять когда процесс создания нового объекта не должен зависеть от того, 
    из каких частей этот объект состоит и как эти части связаны между собой
    Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания

=== Структурные паттерны =================================================

Декоратор (Decorator)*
    это паттерн, который позволяет динамически добавлять новое поведение к объектам, оборачивая их в декораторы

    Применять когда надо динамически добавлять к объекту новые функциональные возможности. 
    При этом данные возможности могут быть сняты с объекта
    Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей
    и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. 
    Еще больше она может разрастись, если нам необходимо создать классы, 
    реализующие все возможные сочетания добавляемых функциональностей.

    есть интерфейс и конкретный класс его реализ
    есть абстрактный класс имплементирующий тот же интерфейс, принимающий в коструктор тот конкретный класс
    и есть неск классов реализ абстрактный класс, делая с тем конкретным классо что хотят
    Animal animal3 = new CanSwimDecorator(new CanFlyDecorator(new BasicAnimal()));
    можно заворачивать один в другой

Адаптер (Adapter)*
    предназначен для преобразования интерфейса одного класса в интерфейс другого. Благодаря реализации данного 
    паттерна мы можем использовать вместе классы с несовместимыми интерфейсами

    Применять когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям
    Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы

    Есть конкретный класс(адаптируемый/который будем адаптировать)
    Есть интерфейс, с каким то методом.
    Адаптер - это класс, который принимает в конструктор наш конкретный класс и реализует интерфейс,
    и уже в имплементируемом методе испольтзует методы нашего конкретного класса и что-то с ним делает

Фасад (Facade)*
    позволяет скрыть сложность системы с помощью предоставления упрощенного интерфейса для взаимодействия с ней

    Применнять когда имеется сложная система, и необходимо упростить с ней работу. 
    Фасад позволит определить одну точку взаимодействия между клиентом и системой.
    Когда надо уменьшить количество зависимостей между клиентом и сложной системой. 
    Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
    Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой 
    отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга

    Есть конкретный большой класс Animal
    Фасад - это класс принимающий в конструктор объект Animal и предоставляет свои методы,
    которые дергают методы Animal.  