
==============================================================================
Console
Вывод в стдаут 
    Console.WriteLine("hello"); с переводом строки.
    cw Tab - быстрый набор вывода
	Console.WriteLine("hello {0} {1, 10} {2:#.##}", 1, 22, 0.765); 
    Позиционные аргументы: первый просто вставляется, 
         второй указывает минимальную ширину поля и третий
         указывает сколько цифр после запятой.
	Console.WriteLine(@"Это буквальный
						строковый литерал,
					занимающий несколько строк.");

Ввод стдин
    Read(); читает 1 символ, после нажатия enter
    ReadLine(); читает строку, нажать enter.
    ReadKey(); читает символы непосредственно, возвращает сразу
	
==============================================================================
using System; использовать пространство имён Систем.


==============================================================================
Типы данных
	Значимые типы данных: 
		Структуры и enum, хранятся в стеке, все унаследованы от System.ValueType
	тип		бит 
	bool	 1	Логический, предоставляет два значения: “истина” или “ложь”
	byte 	 8	целочисленный без знака
	char 	 2  Символьный
	decimal  128   Десятичный (для финансовых расчетов)
	double   64 С плавающей точкой двойной точности
	float    32 С плавающей точкой одинарной точности
	int      32 Целочисленный
	long     64 Длинный целочисленный
	sbyte    8  целочисленный со знаком
	short       Короткий целочисленный
	uint 		Целочисленный без знака
	ulong 		Длинный целочисленный без знака
	ushort 		Короткий целочисленный без знака
    Все типы данных это структуры или классы. Родитель всех классов объект object. 
    Все типы это псевдонимы .NET типа int это int32.
    byte, sbyte, int, uint, long, ulong, float, double...decimal
    char - 2 байта, Unicode
	16-тирич 0xFF	g
	var - динамическая типизация	
	простые типы это int, float… переменные этих типов указывают 
        сразу на значения и с new не используется
		
    Ссылочные типы указывают на ссылку и объявляются как new, хранятся в куче,
		очищаются сборщиком мусора
	string - строки юникода.
    object, dynamic - не меняющийся, меняющийся.
    class
	массивы

	
Приведение типов
    (int) 10/3
	
	String str; str.Format("hui {}, 34")
==============================================================================
Литералы
	100  - литерал, тип int
	4.2  - литерал, тип double
	10L(l)  - long
	2.2F(f) - float
	100U - uint
	10UL - ulong
	9.9M - decimal
	
==============================================================================
Функции
    Функции в С# хранятся только в классах, являются методами.
    Внутри класса Program методы делаем static, чтоб запускать из Main, так как работаем не на уровне объекта.
    Перегрузка методов как в плюсах. 
    Описание метода или класса вызывается тремя слэшами под названием. /// 
	

==============================================================================
Конвертация
    Из одного типа в другой
    Convert.ToInt32("45");
	
Parse
    Метод типов, для конвертации строки в этот тип. int.Parse("88");
    int word = int.Parse(Console.ReadLine()); - чтение и конв в инт.
TryParse
    int.TryParse("66", out a); если успешно то сохранят в а, если нет то ноль.

Разделитель для чисел с плавающей точкой при конвертации
    По умолчанию запятая. float.Parse("5,45");
    using System.Globalization; 
    NumberFormatInfo nfi = new NumberFormatInfo() {
        NumberDecimalSeparator = '.';
    }
    float.Parse("5.45", nfi); теперь точка.
==============================================================================

ConsoleKey ck = Console.ReadKey().Key; засунуть в свитч и ткнуть на пустом поле. 
    Выведуться все клавиши, обработка нажатий.

System.Threading.Thread.Sleep(300); задержка в мс

===============================================================================
Основные конструкции
// коменты как в с++ /**/

Циклы 
	while(true){};
	do{}while();
	for(;;)
    foreach(var item in myArr){};
	
ветвления
	if(true)
	else if(true)
	else
	switch(a){case 1:default}
	brea;
	continue;
	goto;
	
арифметические операторы
	+ - * / % ++ --
	
операторы присваивания
	= += -= *= /= %=
	
операторы отношения
	> < >= <= == !=
	
битовые операторы (работают с целыми числами)
	& | ^ ~ << >> 

логические операторы
	& | && || ! ^ 
		&& || - укороченные, не проверяют вторую часть если	не нужно в отличие 
			от & |
===============================================================================
Массивы
    Массивы все динамические, чистить не надо.
    int [] arr = new int[10]; Инициализируется нулями по умолчанию.
    Массивы это класс, наследник Array имеет много методов.
    int [] arr = Enumerable.Range(4, 5).ToArray(); -5элм начиная с 4
	arr[^1] последний элемент.
    arr[1..4] диапазон
    int [,] arr2; - запятая, прямоугольный двумерный массив, чем больше тем многомернее.
    int[][] arr2a; массив массивов, с разным количеством элементов, зубчатый,
	под каждый  подмассив необходимо выделить опер память. arr[0] = new int [8]
    arr[2,3] - обращение к элементу строка, колонка
	.Lenght - величина массива
===============================================================================
Строки
	String это класс, объекты имеют много методов и различных операций
===============================================================================
Классы
    class Myclass {}
    Конструкторы, деструкторы(почти не исп), this.
    По умолчанию все методы и поля private.
    Поля: доступ тип переменная;
    Методы: доступ тип_возв_знач название(парам){}
    Myclass myobj = new Myclass (); // создание экземпляра.

Делегирование конструкторов:
    MyClass(): this(params) {} вызов другого конструктора,
        используется this.

Модификаторы доступа
	public, private, protected и internal

===============================================================================
ref - ссылка void change(ref int i){} ссылочные аргументы
    передача по ссылке change(ref a); a - должна быть иниц-на
out - служит для передачи значения за пределы метода. 
    void change(out int i){i =10;} … int f; change(out f); Как бы
    присвоили значение в методе по ссылке.
===============================================================================
Инициализаторы объектов
    MyClass obj = new MyClass { Count = 100, Str = "Тест" };
    Инициализация полей и свойств сразу при создании объекта.
===============================================================================
Список List
	new List<T>(); — объявляет новую коллекцию List с элементами типа Т
	Add(X) — добавляет объект X типа Т в конец List.
	Clear() — удаляет все объекты из List.
	Contains(X) — возвращает true, если объект X (типа Т) имеется в List.
	Count — свойство2, возвращающее количество объектов в List.
	IndexOf (X) — возвращает числовой индекс объекта X в List. Если объект X
		отсутствует в коллекции, возвращается -1.
	Remove (X) — удаляет объект X из List.
	RemoveAt(#) — удаляет из List объект с индексом #.
===============================================================================
Словарь: 
	словари позволяют хранить пары ключ-значение и связывать объекты
		с определенными ключами.
	new Dictionary<Tkey, Tvalue>() — объявляет новый словарь Dictionary
		с указанными типами ключей и значений.
	Add(TKey, Tvalue) — добавляет в словарь объект Tvalue с ключом Ткеу.
	Clear () — удаляет все объекты из словаря.
	ContainsKey (ТКеу) — возвращает true, если ключ ТКеу имеется в словаре.
	ContainsValue(TValue) — возвращает true, если значение TValue имеется
		в словаре.
	Count — свойство, возвращающее количество пар ключ-значение в словаре.
	Remove (ТКеу) — удаляет из словаря значение с ключом ТКеу.
===============================================================================
Очередь:
	упорядоченная коллекция, действующая по принципу «первым пришел,
		первым ушел» (first-in, first-out, FIFO).
	Clear() — удаляет все объекты из очереди.
	Contains(X) — возвращает true, если объект X имеется в очереди.
	Count — свойство, возвращающее количество объектов в очереди.
	Dequeue() — удаляет объект из начала очереди и возвращает его.
	Enqueue(X) — добавляет объект X в конец очереди.
	Реек() — возвращает объект из начала очереди, не удаляя его.
===============================================================================
Стек: 
	упорядоченная коллекция, действующая по принципу «первым пришел,
		последним ушел» (first-in, last-out, FILO)
	Clear () — удаляет все объекты из стека.
	Contains(X) — возвращает true, если объект X имеется в стеке.
	Count — свойство, возвращающее количество объектов в стеке.
	Реек() — возвращает объект с вершины стека, не удаляя его.
	Рор() — удаляет и возвращает объект с вершины стека.
	Push(X)— добавляет объект X на вершину стека.
===============================================================================
Функции

Необязательные параметры
    static void func (it i, float f = 0.9){};
	
Именованные аргументы
    func(i: 12);
	
Ссылки
    ref - передача по ссылке инициализованной переменной
    out - можно передавать не иниц переменную, но в функции нужно присвоить.
    in - нельзя модифицировать в функции, нужен для передачи структур по ссылке

	
params
	с помощью ключевого слова params можно позволить функции принимать
	произвольное количество параметров одного типа. Эти параметры преобразуются
	в массив указанного типа.
	int Add(params int[] ints){}

static
    статические поля общие для всех экземпляров
    для работы со статическими полями исп Статик функции
    Статические классы - все члены Статик. Используется
        для создания методов расширения (Linq), также для объединения нескольких
		Статик функций. Создать экземпляр невозможно. Можно сказать что это
		функции.
==============================================================================
Перегрузка операторов
    все как в плюсах
    public static myobj operator +(myobj ob1, myobj ob2){};
    Операторы можно перегружать множество раз, подставляя разные аргументы.
	Преобразование типов(перегрузка)
        public static explicit operator целевой_тип{исходный_тип v) {return значение;} это в случае неявного приведения типа int i = obj
        public static implicit operator целевой_тип(исходный_тип v) {return значение;} это в случае явного int i = (int)obj

===============================================================================
Индексаторы
	разновидность члена класса, поле с методами get set, обращение как к
		массиву. Не определяют место в памяти, предоставляют доступ к полям или
		ещё чему нибудь через обращение к экземпляру через [].
    Механизм для индексирования объектов, подобно массивам.
    Это не перегрузка оператора []. Применяется для создания
    спец массива с какими-то другими ограничениями пользователя, короче если в
	классе определен массив, то можно  прикрутить всяческие свои надстройки,
	но можно и без массива использовать индексаторы.
    Форма определения
        тип_элемента this[int индекс] тип одинак для всех элементов
        {  // Аксессор для получения данных
             get {  // Возврат значения, которое определяет индекс.  }          
           // Аксессор для установки данных
             set {  // Установка значения, кот. определяет индекс.  }
         }
        Аксессор - средства доступа к данным, подобны методам но
            без параметров и возвращ значений, параметр у них это
            передаваемый индекс.
        Если идёт обращение obj[ind] - вызывается get и возвращается значение
			под этим индексом
		Если obj[ind] = то вызывается set[ind], в этом аксессоре будет передано
			значение в неявную переменную 'value',и присвоится элем под индексом.
        В теле set и get можно определить всякие ограничения или проверки типа 
            if (index ≥ 0) obj[index] = value;
            if (index ≥0) return obj[index]
    Индексаторы можно перегружать подобно методам, допустим 
        для работы с другим типом данных.
    Не обязательно чтобы были сразу оба аксессора. И не обязательно чтобы был
	массив. Можно допустим возвращать какие то любые значения. obj[2] а вернуть
	например 2 в квадрате.
    Индексаторы не могут быть static, не могут передавать ref out.
    Можно определять индексаторы и для многомерных массив

Свойства
    Разновидность члена класса, включает в себя поле с методами get set,
		обращение к свойству как к переменной, но взаимодействие происходит через
		функции. 
	Свойства не определяют место в памяти они только управляют доступом к
		переменной.
    int prop; закрытая переменная управляемая свойством
    public int MyProp свойство
    {get {return prop;}
     set {prop = value;}}
    Можно организовать свойства только для чтения get или только для записи set.
    Автоматические свойства
        Аксессоры без тела, эти свойства подобны переменным.
        тип имя {get; set;} 
        public int prop{get; private set;} с закрытым сет.
    Инициализаторы в свойствах    
        MyClass {  // Теперь это свойства,  
            public int Count { get; set; } 
            public string Str { get; set; } }
        MyClass obj = new MyClass {Count=100,Str="Тестирование"};  
    Свойства не определяют место в памяти, поэтому их нельзя передать методам, в
		get нельзя модифицировать переменную, не перегружается.
    Аксессоры имеют такой же мод-р доступа как их свойство,
		можно менять мод-р на private, для того чтобы менять что-то только на
		уровне класса. 
===============================================================================
Наследование
    class Chield: Parent{}
    public наследуется свободно
    private не наследуется
    protected - при наследовании становится private
    Конструктор базового класса
        public Chield(int a, int b) : base(a) {}
        base() - вызов конструктора базового класса, который следующий по иерархии. С параметром или без.
        base.obj - доступ к базовому элементу
    Ссылке на объект базового класса можно присваивать новый объект также и всех производных классов.


===============================================================================
Виртуальные методы 
    Не могут быть Статик или абстракт 
    public virtual void Who() в базовом классе
    public override void Who() в наследнике

Абстрактный класс и методы
    public abstract тип имя(список_параметров ); без тела, он автоматически 
		виртуальный.
    Класс с таким методом объявляются abstract

Предотвращение наследования
    sealed class

Класс object
    От него унаследовано все, и у всех есть его методы:
    Методы класса object 
        public virtual bool Equals(object ob) Определяет, является ли вызывающий 
			объект таким же, как и объект, доступный по ссылке оb  
        public static bool Equals(object objA,  object objB) Определяет,
			является ли объект, доступный по ссылке objA, таким же, как и объект 
			 доступный по ссылке objB.
		protected Finalize() Выполняет завершающие действия перед “сборкой му  
			сора". В C# метод Finalize() доступен посредством деструктора  
		public virtual int GetHashCode() Возвращает хеш-код, связанный с 
			вызывающим  объектом  
		public Type GetType() Получает тип объекта во время выполнения
			программы  
		protected object MemberwiseClone() Выполняет неполное копирование 
			объекта, т.е. копиру  ются только члены, но не объекты, на которые 
			ссылают  ся эти члены  
		public static bool ReferenceEquals(obj objA, object objB) Определяет, 
			делаются ли ссылки objA и objB на один , и тот же объект  
		public virtual string ToString()Возвращает строку, которая описывает 
			объект 
	Упаковка и распаковка
		Все произошло от класса object, поэтому его ссылка может указывать на любой тип данных
		object obj; ссылка на тип object, родитель всех классов.
		obj = 10; упаковка. Упаковываем тип int в наш объект.
		int y = (int)obj; распаковка. 
		Можно создавать функции с параметрами и возвращаемым значениями типа object, большая гибкость
		static int foo(object o) return (int)o * 2;

    
===============================================================================
Проверка на null 
    null используется с ссылочными типами по умолчанию
        со значимыми типами по умолчанию используются свои         
        значения.
    Оператор объединения с null ??
        string str = null;
        Mystr = str ?? "Нет данных"
        Происходит проверка на null, и если null то присваивается то, что после ??, тип должен быть таким же.
    Оператор присваивания с объединением null ??=
        Mystr = str ?? "Нет данных"
        Отличие в том что в str тоже присваивается новое значение
    Оператор .?
        arr.?sum() если arr null то возврат null

===============================================================================
Интерфейсы
    Ряд методов для реализации в классах. В самом интерфейсе нет реализации. Это абстрактный класс где все методы абстрактные. 
    interface MyInter{int GetNum();} интерфейс
    class Myclass: MyInter{int GetNum(){return 0;} реализация
    Можно наследовать много интерфейсов, через запятую.
    Ссылка на интерфейс может указывать на любой класс наследник.
    Интерфейсные свойства
        int Next {  get; // возвратить следующее по порядку число 
					set; // установить следующее число  }
        Похожи на автоматические свойства, но нет, нет спецификаторов доступа. Свойства переопределяться в классах наследниках.
    Интерфейсные индексаторы
        int this[int index]{get; set;}
    Наследование интерфейса от интерфейса
        I1: I2 синтаксис как в классах, реализовывать не нужно
        Класс унаследовавший такой интерфейс, реализует все методы всех интерфейсов. Если имена методов в интерфейсах совпадают, то первый скрывается, но можно и его определить обратившись явно:
            int I1.someFunc(){}
	
===============================================================================
Интерфейс (все абстрактные) нет объекта, нет static
Абстрактный класс (есть абстрактные и реализация) нет объекта, нет static
Класс-родитель(виртуальные методы, реализация) есть объект, 
Класс-потомок(переопределение методов, реализация) есть объект

Структуры
    Значимые типы данных
    struct Mystruct: интерфейсы{методы, поля}
    Структуры имеют меньший потенциал, чем классы, но работают быстрее.

Перечисления
    enum myEnum:byte{список перечисления};
    Все как в плюсах, можно тип указать


===============================================================================
Исключения
    Exception главный класс
    SystemException от этого класса образованы все исключения.
    try 
        { // Блок кода, проверяемый на наличие ошибок. }
    catch (ExcepTypel exOb)
         { // Обработчик исключения типа ExcepTypel. } 
    catch (ЕхсерТуре2)
         { // Обработчик исключения типа ЕхсерТуре2. }
    finally
        { // Это выполняется в любом случае}
    throw Exception; выброс исключения вручную

    checked((byte)345) проверка на переполнение
    unchecked - не проверять переполнение

===============================================================================
Файлы
    using System.IO;
    FileStream(string путь, FileMode режим, FileAccess доступ));
        Режим:
        FileMode.Append - Добавляет выводимые данные в конец файла
        FileMode.Create - Создает новый выходной файл. Существующий файл с таким же именем будет разрушен 
        FileMode.CreateNew - Создает новый выходной файл. Файл с таким же именем не должен существовать 
        FileMode.Open - Открывает существующий файл 
        FileMode.OpenOrCreate - Открывает файл, если он существует. В противном случае создает новый файл 
        FileMode.Truncate - Открывает существующий файл, но сокращает его длину до нуля
        Доступ:
        FileAccess.Read
        FileAccess.Write 
        FileAccess.ReadWrite

    Close(); закрыть файл
	
	Чтение  и запись байтов из потока файлового ввода-вывода
    int ReadByte() чтение одного байта
    int Read(byte[ ] array, int offset, int count) предпринимается попытка 
		считать количество count байтов в массив array, начиная с элемента 
		array[offset]. Он возвращает количество байтов, успешно считанных из 
		файла.
    void WriteByte(byte value)  Этот метод выполняет запись в файл байта, 
		обозначаемого параметром value
    void Write(byte[] array, int offset, int count)  В методе Write() 
		предпринимается попытка записать в файл количество count байтов из 
		массива array, начиная с элемента array[offset]
    BinatyWriter BinaryReader
===============================================================================

Делегаты
    Это указатель на функцию.
    delegate возвращаемый_тип имя(список_параметров); 
        где возвращаемый_тип обозначает тип значения,    
            возвращаемого методами, которые будут вызываться 
            делегатом; 
        имя — конкретное имя делегата; 
        список_параметров — параметры, необходимые для 
            методов, вызываемых делегатом.
    делегат может служить для вызова любого метода с 
        соответствующей сигнатурой и возвращаемым типом.
    delegate string StrMod(string str); объявление делегата
    StrMod strOp = new StrMod(myFoo); переменная
        в которой устанавливается ссылка на функцию myFoo
    StrMod strOp = myFoo; более простой синтаксис(групповое
        преобразование методов)
    str = strOp("hello"); теперь можно пользоваться как myFoo
    Делегаты можно присваивать методам классов
        StrMod hui = Myclass.myFoo;

    групповая адресация — это возможность создать список, или   
        цепочку вызовов, для методов, которые вызываются     
        автоматически при обращении к делегату. + += - -=
        delegate void StrMod(ref string str); 
        // Сконструировать делегаты.  
        StrMod strOp;  
        StrMod replaceSp = ReplaceSpaces;  
        StrMod removeSp = RemoveSpaces;  
        StrMod reverseStr = Reverse;
        // Организовать групповую адресацию.  
        strOp = replaceSp;  присваиваем ссылку
        strOp += reverseStr; добавляем в список делегата ещё ссылк
        srrOp(ref myStr); поочередно строка пройдет по всем фу-ям
        strOp -= replaceSp; так удалить из списка вызов

===============================================================================
Анонимный метод
    один из способов создания безымянного блока кода,     
        связанного с конкретным экземпляром делегата.
    delegate void CountIt(); // можно создавать и с параметрами
    CountIt count = delegate {  безымянная функция
        for (int i=0; i <= 5; i++) 
            Console.WriteLine(i) ;  }; можно с возвращением чего
            либо, return.
    
Лямбда-выражения
    Пришли на смену делегатам
    параметр => выражение 
    (список_параметров) => выражение
    delegate int Incr(int v); делегат
    // Создать делегат Incr, ссылающийся на лямбда-выражение,      
    // увеличивающее свой параметр на 2. 
    Incr incr = count => count + 2;
    int result = incr(10);
    delegate bool IsEven(int v); ещё пример
    // Создать экземпляр делегата IsEven, ссылающийся на 
      лямбда-выражение,  возвращающее логическое значение 
       true, если его параметр имеет четное значение, а иначе — 
       логическое значение false.  
    IsEven isEven = n => n % 2 == 0;
    Пример множ параметров
    delegate bool InRange(int lower, int upper, int v);
    InRange ir (low, high, val) => val >= low && val <= high;
    ir(1,3,5); вернёт 
	
	Блочные лямбда выражения
    IntOp fact = n => 
    {  int r = 1;  for (int i=1; i <= n; i++)  r = i * r;  return r;  };


===============================================================================
События 
    автоматическое уведомление о том, что произошло некоторое действие. События 
	действуют по следующему принципу: объект, проявляющий интерес к событию, 
	регистрирует обработчик этого события. Когда же событие происходит, 
	вызываются все зарегистрированные обработчики этого события. 
Обработчики событий обычно представлены делегатами.
    event делегат_события имя_события;
        где делегат_события обозначает имя делегата, используемого для поддержки 
		события, а имя_событмя — конкретный объект объявляемого события.
    
Обработчик события - это методы на которые будет ссылаться делегат.
Делегат delegate void MyD(); Этот делегат с сигнатурой void() можно будет связать с такими же методами-обработчиками.
class MyE класс содержащий событие
{
    public event MyD myevent; // само событие
    public void startMyevent // функция запуска события
    {
        if (myevent != null) проверка есть ли в событии обработчики
            myevent(); запуск события(запускаются функции привязанные к делегату)
    }
}

Далее в своем классе можно создать методы-обработчики со схожей сигнатурой с делегатом. И связать их
void hui(){...} Метод- обработчик события
MyE event = new MyE(); // экземпляр класса события
event += hui; добавляем обработчик в экземпляр класса с событием.(теперь событие будет не null)
event.startMyevent(); запускаем функцию класса
В результате вызовется обработчик-метод hui через наш делегат, на котором основано само событие myevent.

Групповое событие
	добавляется +=
	убирается -=
	В событие можно добавлять любые методы, статич нестатич, главное с одинаковой
		сигнатурой. Нестатич методы добавляются через объект += obg.mymet,
		статические +=class.method.
	Можно создать кучу объектов одного класса и добавить всех в событие
	
Обработчиками событий могут выступать как статич так и нестатич. В случае со статич, уведомление получает класс а не член.
Применение аксессоров событий
    Это управление добавления или удаления обработчиков из события.
    event myD myE{
        add {  // Код добавления события в цепочку событий +=.  }        
        remove {  // Код удаления события из цепочки событий -=.  }
    Внутри этих методов используется value для добав/удал.
    add{. // Для максимум 3-х событий
         for(i=0; i < 3; i++)  {
            if(evnt[i] == null) {
                evnt[i] = value; 
                break;  }}
    remove { // удаление
       int i;  for(i=0; i < 3; i++) 
           if(evnt[i] == value) 
             {  evnt[i] = null;
                break;  }
Использование лямбда выражения в событиях
    evt.SomeEvent += (n) =>  Console.WriteLine("Событие получено. Значение равно " + n);
    kevt.KeyPress += (sender, е) => Console.WriteLine(" Получено сообщение о нажатии клавиши: " + e.ch);
В событиях принято первым параметром использовать сам объект посылающий события.

Рекомендованный стандарт
    public event EventHandler<MyEventArgs> SomeEvent;
    это встроенный делегат EventHandlet

===============================================================================
object as int - приведение типов
===============================================================================
===============================================================================


System.Linq - различные фишки, например функции мин Макс , where, для массивов.



Random
    Random random = new Random();
    random. Разные методы. .Next(100) число от 0 до 100.



    

    

