# Flutter - framework on Dart and tools
# Dart - programming language


--- About ----------------------------------------------------------------------------
Flutter это фреймворк для создания UI для различных платформ, используется единый язык
Dart - programming language of Google
Приложение на флаттере - набор виджетов, все состоит из виджетов


--- setings -----------------------------------
1. https://docs.flutter.dev/get-started/install
после установки весх компонентов могут быть ошибки:
    unable to find bundled java version - Go to "C:\Program Files\Android\Android Studio"
    then copy the content of jbr and paste the content into jre folder
    cd ~/android-studio/ && ln -s jbr jre - for linux
    flutter config --android-studio-dir=/home/ivan/Programming/android-studio
    
    unable to confirm if installed Windows version is 10 or greater - 
    flutter upgrade
    flutter channel
    flutter channel master
    flutter upgrade
    flutter channel
2. install plagin for VSCode
3. Config files
    pubspec.yaml - specifies basic information about your app, such as its current version,
    its dependencies, and the assets with which it will ship
    analysis_options.yaml - настройки для анализатора

--- terminal commands ---
flutter create my-project   # create new flutter project with name 'my-project'
flutter run                 # run project
dart pub add pedantic_mono  # добавить пакет
dart pub get                # обновить пакеты согласно pubspec.yaml

--- project ---
android/        - полная сборка для различных платформ - все заполняется авто
ios/            ...
linux/          ...
windows/        ...
build/          - различные файлы компилляции для flutter sdk - все на автомате
test/           - авто тесты
lib/            - our code working directory
  .metadata     - атоматич файл для flutter
  .packages     ...
  .my-proj.iml  ...
  pubspec.lock  ...
  pubspec.yaml  - описание, всякие зависимости проекта(pub.dev), шрифты, фотки ...
  analysis_options.yaml

--- pubspec.yaml ---
name: flutter_complete_guide
description: A new Flutter project.
publish_to: 'none'                    # Remove this line if you wish to publish to pub.dev
version: 0.1.0+1                      # версия нашего проекта
environment:                          # окружение
  sdk: '>=2.19.0 <3.0.0'              # версия нашей sdk должна попадать в диапазон
                                        смотреть flutter --version (Tools • Dart 2.19.2)
dependencies:                         # зависимости на проде, берем с pub.dev
  flutter:                            # стандартная необходимая библиотека
    sdk: flutter                      
  cupertino_icons: ^1.0.2             # иконки для ios
  pedantic: ^1.11.0                   # подключение сторонней либы с pub.dev
dev_dependencies:                     # зависимости только для разработки, в прод не идет
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0
flutter:                              # подключение различн шрифтов иконок итд
  uses-material-design: true
  fonts:                              # шрифты
    - family: Rubik                   # определенный скаченный шрифт
      fonts:
        - asset: fonts/Rubik-VariableFont_wght.ttf

--- analysis_options.yaml ---
include: package:pedantic/analysis_options.1.11.0.yaml  # наш подключ пакет версия та же

analyzer:                             # свои настройки
  strong-mode: 
    implicit-casts: false             #
    implicit-dynamic: false           # динамик типы будет запрещать

linter:
  rules:
    - prefer_const_constructors       # где можно const - подсветит
    - prefer_const_declarations
    - avoid_print                     # запретить print()
    - use_key_in_widget_constructors

--- structure ---
           My App
             |
        My Home Page
        /          \
Some Widget     Other Widget

lib/main.dart - main file of app

import 'package:flutter/material.dart'; // импорт пакета - доступен так как в pubspec.yaml
                                           прописаны dependencies: flutter
                                           material.dart - набор виджетов для Android
void main() {                         - точка старта, вызывается при запускe приложения 
    runApp(MyApp());                  - функция из импортированного пакета material, приним
}                                       виджет, который вызывает build() - отрисовка

class MyApp extends StatelessWidget { - класс наслед от виджета, все эл приложения - виджеты
  const MyApp({super.key});             code in MyApp sets up the whole app. It creates the 
    @override                           app-wide state, names the app, defines the visual theme
    Widget build(BuildContext context){ - context - метаданные исп флаттеров о тек виджете
      return ChangeNotifierProvider(  - обязывает все виджеты хранить текущее состояние(ниже)
        create: (context) => MyAppState(),
        child: MaterialApp(
        title: 'Namer App',
        theme: ThemeData(
          useMaterial3: true,
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepOrange),
        ),
        home: MyHomePage(),
      ),
    );
  }
}

class MyAppState exts ChangeNotifier{ - класс опред состояние, определяет данные, которые
  var current = WordPair.random();      будут использоваться функциями. ChangeNotifier -
                                        если будут изменения - все виджеты будут знать
  void getNext() {                    - какой-то обработчик 
    current = WordPair.random();      - действия
    notifyListeners();                - посылает уведомления виджетам(кто подписан)
  }                                     об изменениях

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {- автоматически выз при изменении виджета
    var appState = context.watch<MyAppState>();  - каждый виджет просм текущее App сост
    return Scaffold(                  - кажд виджет возвращ другой виджет/дерево виджетов
      body: Column(                     Scaffold - часто исп полезный виджет
        children: [                   - Column - один из базовых layout of widget
          Text('A random good idea:'),  вставляет люб кол-во children в колонку сверху-вниз
          Text(appState.hui),         - Text widget  
          Text(appState.current.asLowerCase), - обращение к состоянию appState(выше),
                                                получение знач переменной
          // add the button
          ElevatedButton(
            onPressed: () {
              appState.getNext();     - привязываем обработчик на кнопку
            },
            child: Text('Next'),
          ),
        ],                            - запятые можно оставлять у посл элем для удобства
      ),                                вставки других элементов потом(также с , на конце)


--- Widgets ------------------------------------------------
Виджеты         - это классы Dart, которые имеют build метод
Widget          - главный базовый виджет, предок для всех
Widget catalog  - все виджеты flutter на сайте по категориям  с описанием

Типы виджетов:
visible/видимые виджеты:  Text(), ElevatedButton(), Card() ...
unvisible виджеты:        определяющие структуру и контроль - Center(), Column()..

Material Disign - это система дизайна, созданная Google, чтобы помочь командам 
создавать высококачественные цифровые приложения для Android, iOS, Flutter и Интернета
Material Guidelines - рекомендации следования дизайну от Google.

MaterialApp   - базовый root виджет, предоставляет доступ к множеству др виджетов,
                следует Material Guidelines. Используем этот всегда! Должен быть
                возвращен на самом верхнем уровне из нашего приложения, которое
                запускается в main()
CupertinoApp  - брат MaterialApp только все под Apple ios

--- Свои виджеты ---
1. Каждый виджет должен быть унаследован от одного из 2-х виджетов
     StatelessWidget - формируется при вызове конструктора и не меняется runtime
     StatefulWidget  - может менять свое внутреннее состояние(меняет виджеты)
2. Необходимо добавить/переопределить build метод - который принимает BuildContext и
   возвращает Widget и он рисуется флаттером. Для StatelessWidget вызывается 1 раз.
   В этом методе как раз вся структура для отрисовки виджета.
3. Обычно под 1 класс - 1 файл, редко 2 виджета в 1 файле

Examples:
// StatelessWidget
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(...                // отрисовка виджетов тут
  }}
// StatefulWidget - разделен как бы на 2 класса Основной+Состояние(с build методом)
class MyApp extends StatefulWidget {      // <--------------------------+
  @override                                                             |
  State<MyApp> createState() {  // переопред createState()              |
    return _MyAppState();       // возвращ класс ниже --+               |
  }}  //      v-----------------------------------------+               |
class _MyAppState extends State<MyApp> {  // привязка к классу MyApp ---+
  var _questionIndex = 0;     // какие-то данные
  void _answerQuestion() {    // обработчик кнопки приватный, только в классе
    setState(() {             // отрисовывает виджет заново build() --------+
      _questionIndex++;       // private переменная - исп только в классе   |
    )});                                                                    |
  }                                                                         |
  @override                                                                 |
  Widget build(BuildContext context) {  <-----------------------------------+
    return MaterialApp(...    // отрисовка виджетов тут
}

--- Базовые виджеты ---
MaterialApp(                  // корн виджет, который должен быть на самом верху
  title: 'some title',        // заголовок на вкладке(для веб)
  theme: ThemeData(           // темы для различ виджетов
    appBarTheme: AppBarTheme(backgroundColor: AppColors.darkBlue),
    bottomNavigationBarTheme:
  home: Text('some text'),    // основное тело - весь экран

Scaffold(                     // базовый дизайн и структура страницы/каркас экрана
  appBar: AppBar(             // бар, передадим ему AppBar() - который включ много чего
  body: Column(               // тело содержащее основное на странице

Center(                       // выравнивает все по центру
  child: ...                  // содержит др виджет

Align(                        // типа Center но может выравнивать и по другим краям
  alignment: Alignment.bottomRight,

Container(                    // содержит др виджет
  color: Colors.cyan,         // можно задать цвет
  width: double.infinity,     // макс ширина 
  height: 120,
  child: ...,
  margin: EdgeInsets.only(left: 20, right: 20),               // внешние отступы
  padding: EdgeInsets.symmetric(vertical: 5, horizontal: 10), // внутренние отступы

Row(                          // контейнер для виджетов, занимает все пространство по верт
Column(                       // контейнер для виджетов, занимает все пространство по гориз
  mainAxisAlignment: ... ,    // выравнивание относ глав оси (center, start, spaceAround..)
  crossAxisAlignment: ... ,   // выравнивание относ другой оси (center, start, end..)
  mainAxisSize: ...           // MainAxisSize.min - займет по макс размеру чайлдов
  children: [ ...             // может содержать множество виджетов
  Spacer()                    // пробел максимально возможной длины между эл в Row

SizedBox(                     // просто отступ в любом месте
  width: 20,                  // можно чисто отступ по вертикали или гориз, или оба
  height: 30,

Text(                         // отображение текста
  'some text',                // позиц парам строка
  style: TextStyle(           // различные стили для текста
    color: Colors.black,
    backgroundColor: Colors.orange,
    fontSize: 20,
    fontFamily: 'Rubik',      // ---------------------------------------------+
                                                                              |
# Свой шрифт:                                                                 |
заходим в google fonts и скачиваем понравившийся                              |
перенесем шрифт .ttf из скаченного архива в новую дир в корне проекта fonts/  |
в pubspec.yaml добавим/расскомментим                                          |
  fonts:                                                                      |
    - family: Rubik   <-------------------------------------------------------+
      fonts:
        - asset: fonts/Rubik-VariableFont_wght.ttf

Stack(                          // стопка элементов 1 на другом допустим pic+text
  fit: StackFit.loose,          // занимаемое пространство
  alignment: Alignment.center,  // выравнивание
  children: [                   // виджеты в стэке

Positioned(                     // изменение позиции/отступа относ родителя
  left: 40,                     // используется в стэке
  top: ..


--- layout -----------------------------------------------------------------------
Виджет может указать сколько места он займет width, height. Но не всегда получится
это сделать - тут все зависит от родителя.
Родительский виджет может указать дочернему ограничения по занимаемому месту
min width, max width, min height, max height.
По умолчанию у разных виджетов разные ограничения для потомков, например контейнер
имеет все min и max ограничения равнными его размеров, т.е. чайлд не может занять
меньше, но можно это переопределить (см пример). А Центр дает возможность выставить
размеры любые, но не больше его собственных.

CostrainedBox();    // заменяет constraints родителя на свои
UncostraintBox();   // снимает у чайлда ограничения родителя
OverflowBox();      // снимает у чайлда ограничения родителя и не выводит предупреждений
FitterBox();        // растягивает чайлда до своих размеров, удобен в использовании в 
                       каких то местах где не помещается текст - сжимается в размерах
Expanded();         // чайлдд занимает все возможное пространство например элемент A 
                       в строке: A______BCD => A-expanded, несколько таких делят пустое
                       пространство меж собой, можно регулировать праметрм flex:
Flexible();         // делят пустое пространство между собой но не заходят не больше
                       половины(в случае 2-х Flexible)

Center(                       // Center позволяет чайлду выставлять размеры --+
  child: Container(           // Container будет занимать 200xmax <-----------+
    width: double.infinity,   // вся ширина     
    height: 200,              // какие то свои размеры
    constraints: BoxConstraints(maxHeight: 150),  // различн ограничения для чайлдов <-+
    color: Colors.amber,                                                               |
    child: Container(         // ограничен по высоте, по ширине - ширина родителя      |   
      width: 50,              // здесь родитель не даст занять меньше                  |
      height: 200,            // будет 150, потомучто ограничил родитель --------------+
      color: Colors.black,

--- Custom layouts widget---
// single - редко используется
CustomSingleChildLayout(      // тонкая настройка для 1 виджета--+
  delegate: MyDelegate(),     // сюда вставл класс ниже          |
  child: Widget               // виджет <------------------------+

class MyDelegate extends SingleChildLayoutDelegate {
  houldRelayout                         // обяз, можно вернуть true
  Size getSize                          // собственные ограничения
  BoxConstraints getConstraintsForChild // ограничения для чайлдов
  Offset getPositionForChild            // офсет
}

// multi - например расположить элементы на экране в определенных частях
   экрана , определенных размеров.
ustomMultiChildLayout(
  delegate: MyMultiDelegate(),  // делегат определяется ниже
  children: [                   // список лэйаутов
    LayoutId(                   // только такие структуры могут тут быть  
      id: 1,                    // id должны быть разными(могут быть строками)
      child: Text(              // виджеты
          'data-left'),
    ),
    LayoutId(
      id: 2,
      child: Text(
          'data-midle'),
    ),

class MyMultiDelegate extends MultiChildLayoutDelegate {
  @override
  void performLayout(Size size) {
    if (hasChild(1) && hasChild(2) && hasChild(3)) {  // проверка по id
      // размеры чайлдов
      layoutChild(1, BoxConstraints.loose(Size(size.width * 2 / 3, size.height)));
      layoutChild(2, BoxConstraints.tight(Size(size.width / 6, size.height)));
      layoutChild(3, BoxConstraints.loose(Size(size.width / 6, size.height)));
      // отступ от 0:0 чайлдов
      positionChild(1, Offset(0, size.height / 2));
      positionChild(2, Offset(size.width * 2 / 3, size.height * 1 / 2));
      positionChild(
          3, Offset(size.width - size.width * 1 / 6, size.height * 1 / 2));
    }
  }

  BoxConstraints.loose - не больший size
  BoxConstraints.tight - точный size

  @override
  bool shouldRelayout(covariant MultiChildLayoutDelegate oldDelegate) {
    return true;
  }
}


--- Scroll -------------------------------------------
// вызывает build/initState всех элементов сразу, используется
   для небольших списков, для больших - ListView
SingleChildScrollView(            // скролит 1 элемент
  scrollDirection: Axis.vertical, // гориз скролл
  controller: controller,         // приним скролл контроллер(для sf)
  child: Column(                  // скролищейся элемсент
    children: widgets,            // виджеты

// вызывает build/initState элементов только при скролле на них
   использовать для всего
ListView(                         // обычн конструктор
  children: [ ...                 // виджеты
ListView.builder(                 // строит/удаляет виджеты автом при скрол
  itemBuilder: (context, index) => Text('hi $index'), // с пом этого
  addAutomaticKeepAlives: false,  // пытаться сохранить состояние виджетов
ListView.separated(               // как builder, только генерит между -+
  itemBuilder:                    // виджеты                            |
  separatedBuilder:               // виджеты между виджетами <----------+
// Для нек виджетов не нужно удалять содержимое (TextFueld например) -
   можно в ListView.builder в itemBuilder засунуть свой sf видж c миксином 
   AutomaticKeepAliveClientMixin

ScrollController();               // всякие настройки
controller.jumpTo(400)            // прыг на опр офсет
controller.animateTo(...)         // прыг на опр офсет плавно


--- buttons -------------------------------------------------------------
ElevatedButton(                                     // закрашенная кнопка
OutlinedButton(                                     // закраш outline 
TextButton(                                         // без рамок кнопка
  onPressed: () => print('pressed'),                // callback function
  child: Text('press'),                             // текст кнопки
  style: ButtonStyle(                               // стили кнопок(цвет,форма..)
    backgroundColor: MaterialStateProperty.all(Colors.amber)),
    foregroundColor:

IconButton(                                         // кнопка - иконка
  onPressed: callback,
  iconSize: 50,                                     // размер иконки
  splashRadius: 100,                                // круг при навед/нажат
  icon: Icon(                                       // иконка вместо текста
    Icons.abc,

// В кнопки можно заворачивать не только текст - а любой виджет,
TextButton(                                         
  child: Row(...                                    // все будет кнопкой


--- Navigation ---------------------------
Длф навигации используется класс Navigator.
навигатор умеет переходить вперед, возвращаться назад, провер возможность этого.


final navigator = Navigator.of(context);  // получить текущий навигатор

// Навигатору передается route в котором определен builder: что открыть
final route = MaterialPageRoute<void>(builder: (context) => MyWidget());

Переходы:
navigator.push(route);  // переход, появится кнопка назад на предыдущ виджет
navigator.pushNamed('/main_screen');            // переход по url (см ниже)
                                                   добавляется в стэк нов виджет
navigator.pushReplacementNamed('/main_screen'); // то же но нет стрелки назад,
                                                   убирает из стэка пред виджет
Navigator.of(context).pop();                    // переход назад
Navigator.of(context).canPop();                 // возможен ли переход

// убираем home: из главного виджета и пропишем маршруты
return MaterialApp(
  theme: ThemeData(
      appBarTheme:  // общая тема для AppBar всех страниц
          AppBarTheme(backgroundColor: Color.fromARGB(255, 0, 34, 61))),
  routes: {
    '/auth': (context) => AuthWidget(), // <-----------+
    '/main_screen': (context) => MainScreenWidget(),   |
  },                                                   |
  initialRoute: '/auth',  // этот вместо home: --------+
  // использовать только если необходимо, иначе всегда есть куда перейти(стрелка)
  onGenerateRoute: (settings) => MaterialPageRoute<void>( // если переходим по неправ
        builder: (context) => Text('Wrong path!'),           пути вызовется этот метод
      ),                                                     и откроет нов экран
                                                             кнопка назад будет всегда
                                                             активна.

  Маршрутизация:
  /       - корень
  /main   - с этой страницы автоматически будет кнопка назад в корень
  /sacond - с min не пересикается
  /main/a - а с этой в /main


--- Bottom navigaiton bar -----------
// стили в MaterialApp
bottomNavigationBarTheme: BottomNavigationBarThemeData(
  backgroundColor: AppColors.darkBlue,
  selectedItemColor: Colors.white,
  unselectedItemColor: Colors.grey,
// Добавляется в Scaffold
body: Center(
  child: _widgets[_selectedTab],          // перерисовка в завис от инд 
),                                           _widgets - массив наших видж
bottomNavigationBar: BottomNavigationBar(
  currentIndex: _selectedTab,             // переменная обновляемыя в setState
  items: [                                   выбранная вкладочка в баре
    BottomNavigationBarItem(
      icon: Icon(Icons.access_time),
      label: 'her',
    ),
    BottomNavigationBarItem(
      icon: Icon(Icons.money),
      label: 'hui',
    ),
  ],
  onTap: onSelectTab,                     // наша функция кот обновляет индекс


--- TextField --------------------------------------------------------------
Виджет текстового поля ввода
Имеет несколько состояний в decorator:
  enabled:
    focused (можно вводить текст)
    error
    error + focused
  disabled
под каждый есть свой декороатор и можно настроить

--- decoration ---
TextField(
  decoration: InputDecoration(            // различные настройки отображения
    enabled: true,                        // состояние enabled/disabled
    border: OutlineInputBorder(),         // рамка вокруг общий стиль
    disabledBorder: OutlineInputBorder(), // рамка вогруг неактивного поля
    enabledBorder: OutlineInputBorder(    // активное поле со своим стилем
      borderSide: BorderSide(             // сама рамка, имеет настройки
        color: Colors.green),
        width: 5,
      borderRadius: BorderRadius.all(     // скругление
                Radius.circular(50),
    focusedBorder: UnderlineInputBorder() // в фокусе
    labelText: 'Hello',                   // label поля - отображ в рамке
    labelStyle: TextStyle(                // стиль label
      color: Colors.deepOrange,
    helperText: 'Fuck you',               // текст подсказка снизу рамки
    helperStyle: TextStyle(),             // ее стиль
    helperMaxLines: 1,                    // макс кол-во строк подсказки
    hintText: 'huohuohuou',               // placeholder в поле при фокусе 
    hintStyle: TextStyle(                 // стиль
      color: Colors.black12,
    floatingLabelBehavior:                // настройка анимации лэйбла 
      FloatingLabelBehavior.always,       // always/never поведение label
    errorText: null,                      // если не null то рамка errorBorder + текст
    icon: Icon(Icons.access_time),        // иконка перед полем
    prefixIcon: Icon(Icons.money),        // иконка внутри поля перед текстом
    prefix: Text('pre'),                  // виджет перед текстом
    prefixText: 'pre',                    // текст перед текстом
    suffixIcon: ...                       // после
    suffixText: ...                       // после
    isCollapsed: true,                    // сжать до минимума(убрать иконки, лэйблы)
    contentPadding: EdgeInsets.all(30),   // если isCollapsed - настройка паддинга
    filled: true,                         // заполнять поля
    fillColor: Colors.amber,              // этим цветом
    hoverColor: Colors.black,             // при наведении этим цветом

--- root settings ---
TextField(
  enabled: true,                          // глоб состояние enabled/disabled
  readOnly: true,                         // активное, но вводить ничего не получится
  textInputAction:                        // действия при нажатии (enter) много всего
    TextInputAction.done,                 // выйти из фокуса
    TextInputAction.next,                 // переход на след поле 
  keyboardType: TextInputType.number,     // тип клавы для мобилок
  showCursor: true,                       // показывать курсор в поле
  cursorWidth: 2.0,                       // разл настройки курсора внутри поля
  obscureText: true,                      // точки для password
  obscuringCharacter: '&',                // символ вместо точек в password
  autocorrect: false,                     // откл автокоррект
  enableSuggestions: false,               // откл предлож вар-ты(мобилка)
  style: TextStyle(fontSize: 30,          // настройки самого текста в поле
  maxLines: 2,                            // максимально строк
  minLines: 2,                            // минимально строк
  maxLength: 100,                         // макс кол-во символов
  textAlign: TextAlign.center,            // текст по центру
