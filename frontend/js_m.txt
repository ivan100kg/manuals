// JavaScript
--- Стандарты ---
    В новый стандартах добавляются полезные фишки
    ECMAScript 2009 - ES5
    ECMAScript 2015 - ES6
    "use strict";   // использовать в нач документа - означает соотв-е ES6+

--- Комментарии ---
    // comment
    /*
        multiline comment
    */

--- Литералы ---
    10          // целое 
    3.14        // дробное
    'dom'       // строки
    "dom"       // строки
    [1,2]       // массив
    {name:'X'}  // объект
    (ab|bc)     // рег выражение

--- Константы и переменные ---
    const MAX_VALUE = 200;      // константа(в верх регистре)
    const minValue = arr[0];    // вычисляемая константа(в ниж регистре)
    let arr = [HTML','CSS'];    // переменная, обычное поведение(C++, Python)
    var section;                // переменная, по старым стандартам(устар.)

--- Операторы ---
    + - * / % ** ++ --          // arithmetic
    = += -= *= /= %= **=        // assignment
    == === != !== > < >= <= ?   // ==(типы приводятся) ===(не приводятся)
    && || !                     // logical
    & | ~ ^ << >> >>>           // bit
    typeof()                    // type
    instanceof()                // instance of Array
    in                          // вхождение
    arr['HTML']                 // по ключу
    arr.HTML                    // через точку

--- Типы ------------------------------------------------------------------
    typeof()    // look a type of variable
    Number      // 0, -2, 3.14, 123e5, 12e-2, NaN, ±infinity
    BigInt      // 12345678901234567890n числа неогр длины -(n) на конце
    String      // 'hello' "world" `fuck ${name}`
    Object      // {}, [], null
    bollean     // true, false
    undefined   // let car; не определенная переменная
    Symbol      // symbol - уник идентиф в объектах
    function    // function
    
    null        // спец объект обозначает 'ничего'
    NaN         // вычислительная ошибка - люб мат операц с NaN это NaN
    Infinity    // +infinity
    -Infinity   // -infinity

    -------
    typeof x или typeof(x) - возвращ строковое знач типа данных
    example: if(typeof(obj === 'object'))

    строковое представление типов, при исп функции typeof():
    number
    string
    object
    undefined
    boolean
    bigint
    function
    symbol

    динамическая типизация - у переменых нет типа
    1 перемнной может быть присвоен различный тип данных по ходу кода

Приведение типов:
    String(78)  // '78' к строке
    Number('9') // 9 к числу
    +"10"       // 10 к числу
    Number('J') // NaN
    Boolean(9)  // true

Автоприведение типов
    "7" + 8     // "78" если в сложении учавствует хоть 1 строка - рез-т строка
    8 + "7"     // "87"
    8/"2"*2     // 2 во всех других арифм операциях приводится к Number

Численное преобразование:
    undefined   -> NaN
    null        -> 0
    true        -> 1
    false       -> 0
    ""          -> 0
    " 123\n"    -> 123 происходит изначально trim
    " sdf"      -> NaN

Логическое преобразование:
    0, "", undefined, NaN   - false
    все остальное           - true

--- Взаимодействие: alert, prompt, confirm ---------------------------------
// перекрывают взаимодействие со страницей, пока не будет что-то нажато.
alert("Hello");             // окно с сообщ и кнопкой, ждет пока наж ОК
res = prompt('text', '1');  // окно с сообщ и полем ввода и кнопками ок 
                               отмена, второй парам не обяз - возвращается
                               если пользователь ничего не ввел и нажал ОК
                               если отмена - возврат null
result = confirm(question); // ok - true, отмена - false

--- Функции ---------------------------------------------------------------
    let b = 12;             // глобальная переменная - видно внутри функций
                               также их можно менять в функциях
    function foo() {        // объявление функции (видна до и после объявления)    
        let a = 5;          // видно только в функции
        return true;        // обычная функция
    }

    let foo = function() {  // функциональное выражение (видна посе объявления)
        return true;        // можно исп неименованную (типа lambda Python)
    };                      // в конце выражения ;
    
    let foo = () => true;   // стрелочная функция, аналог той что выше
    let foo = (a,b) => a+b; // пример вычисления суммы, для многострочных при-
                               меняются {}, но возврат через return
    let foo = new Function('a', 'b', 'return a+b;');    // функция "на лету"
                                                           не раб в замыканиях
    foo();                  // вызов функции(указателя/ссылки)

    Функции не возращающие значения - не явно возвращают undefined
    return;                         - не явно возвращается undefined

Параметры ф-ии:
    function sum(a, b=100, ...args)     // a, b - позиц парам, b - имеет знач
                                           по умолч. ...args - массив осталь-
                                           ных арг-ов, может быть пустым
    sum(20,30);     // норм a=20, b=100
    sum(20);        // норм a=20, b=100(default)
    sum(20,30,40);  // норм a=20, b=100, args = [40,]
    sum();          // error - отсутствует обяз аргумент а


Замыкания:
    function createCounter() {      // внеш ф-я
        let count = 0;
 
        return function() {         // внутр ф-я
            return count++;         // ссылка на перем во внеш зоне вид-ти
        };
    }
 
    let counter = createCounter();  // тут ссылка на анонимную ф-ию, которая
    console.log( counter() );          ссылается на переменную в внеш области
                                       видимости 'count' - это замыкание.
                                       пока существует ссылка counter, область
                                       вид-сти createCounter будет жить.

Функция setTimeout:
    отложенный вызов - вызывается параллельно, не зависит от расположения
                             ф-ия|выр   задерж мс  аргументы ф-ии
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
    clearTimeout(timerId)   // остановка вызова setTimeout
    setTimeout("alert('Привет')", 1000);        // можно исп строки с выраж-м
    setTimeout(() => alert('Привет'), 1000);    // или стрелочные

Функция setInterval:
    let idClock = setInterval(foo, 1000);   // вызыв-ся циклич-ки через 1с
    clearInterval(idClock)                  // остановка

Встроенные атрибуты ф-ий:
    function foo(msg) {
        console.log(msg);
    }
    foo.name    # имя ф-ии
    foo.bar = 0 # добавить свой аттр
    foo.call    # позвол вызв ф-ии с указ их контекста (context,arg1,arg2,...)
    foo.apply   # позвол вызв ф-ии с указ их контекста (context, args) массив


--- Objects --------------------------------------------------------
    let user = new Object();    // синтаксис "конструктор объекта"
    let user = {};              // синтаксис "литерал объекта"
    {ключ: значение}            // ключи - это строки, знач - любые объекты 
    newKey = 'gender';
    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        her,                    // сокращенно her:her
        for: 2,                 // допустимы let for return
        0: 123,                 // 0 -> '0'
        [user]: user            // исп переменных в ключах и значениях
        [выраж + перем]: male,  // люб вычисляемое занач из переменных/текста..
        fullName: function () { // this(тек бъект) т.е поля этого объекта
            return this.firstName + " " + this.lastName;
        },
        getId() {               // ES6 - компактный вариант
            return this.id;     
        },
    };

    Стрелочные функции не имеют this!

    person.firstNsme        // обращение к полю. 
    person['firstName']     // аналогично
    person.salary = 100     // изм знач атр, либо создание атр, если такого нет
    delete person.salary    // удалить атрибут 
    "salary" in person      // проверка на вхождение ключа 
    person.salary === undefined // та же проверка на вхождение 
    person['hi bye']        // получение поля если название с пробелом

    # пробежаться по объекту
    # свойства с целочисленными ключами сортируются по возрастанию,
      остальные располагаются в порядке создания
    for (let key in user) {
        // ключи
        alert( key );  // name, age, isAdmin
        // значения ключей
        alert( user[key] ); // John, 30, true
    }

    let user = {
        name: "John",
        age: 30,            // можно заканчивать запятой 
    }

    const user = {          // объект можно менять внутри, но ссылку нельзя
        name: "John"
    };

    # + ссылка на объект
    let a = {}; 
    let b = a;
    b == a;     // true - ссылаются на один и тот же об

    # копирование объекта
    let clone = {}; // новый пустой объект
    for (let key in user) {
        clone[key] = user[key];
    }

    // функция возвращающая объект
    function createCar(model, color) {
        return {
        model: model,
        color: color
        };
    }
    let car = createCar("toyota", "black");

    // Функции-конструкторы технически являются обычными функциями
       два соглашения:
       Имя функции-конструктора должно начинаться с большой буквы
       Функция-конструктор должна выполняться только с помощью оператора "new"
    
    function Book(title, author) {          // ф-ция конструктор
        // this = {};   // (неявно)
        this.title = title;
        this.author = author;               // поле
        this.sayHi = function() {           // метод
            alert("Hello " + this.author);
        };
        // return this; // (неявно)         // возвращает новый объект
    }
    let book = new Book("Муму", "Турген");  // можно плодить объекты    

    new.target - св-во внутри функции, проверка, вызвана ли функция 
    при помощи оператора new или без него.
    function User() {
        console.log(new.target);
    }
    User();     // undefined            new.target = undefined
    new User(); // function User()...   new.target = самой ф-ии

    Преобразование объектов в примитивы:
        - объект может быть преобразован тоьлко в строку или число 
        - математическая операция с объектами - возвращает примитив
        - числовое преобразование происходит, когда мы вычитаем объекты
          или применяем математические функции
        - преобразование к строке log(obj)/alert(obj).. типа такого
    Хинты:
        спец методы объекта - реализуют преобразования объектов
        "string"    - к строке alert(obj); anotherObj[obj] = 123;
        "number"    - к числу let num = Number(obj); let n = +obj;
        "default"   - оператор «не уверен», какой тип ожидать
                      let total = obj1 + obj2;
    Чтобы выполнить преобразование, JavaScript пытается найти и вызвать
    три следующих метода объекта:
        obj[Symbol.toPrimitive](hint);  // метод с символьным ключом
        obj.toString(); obj.valueOf();  // иначе хинт = "string"
        obj.valueOf(); obj.toString();  // иначе хинт = "number" or "default"

    Object - спец объект для работы с объектами:
    Object.keys(obj)    // массив ключей объекта obj
    Object.values(obj)  // массив значений
    Object.entries(obj) // массив массивов ключ-значение

--- Symbol -----------------------------------------------------------------
в качестве ключей для свойств объекта могут исп только строки или символы
// Создаём новый символ - id с описанием(метка) "id"
let id1 = Symbol("id");     // каждый раз уник, метка ни на что не влияет
let id2 = Symbol("id");     // не равен выше стоящему символу
id1.description;            // -> id, возвраает метку              

// символы не преобразоваются автоматически в строки
alert(id1);                 // TypeError: Cannot convert a Symbol value to..
alert(id1.toString());      // так можно

// скрытые свойства символов
let user = {                // some object
    name: "Вася",
     [id]: 123              // можно так добавить символ, литералом
};
let id = Symbol("id");      // символ
user[id] = 1;               // если доб свойсво так - оно будет скрыто в 
                               других частях программы (за скопом)
alert(user[id]);            // доступ к данным по ключу-символу
если в какой-то другой части программы к этому объекту вновь добавить
свойство, пускай даже под таким же именем
let id = Symbol("id");      // символ в другой части программы
user[id] = 2;               // совершенно другой символ, не затерает первый
Символы игнорируются циклом for…in

Глобальные символы:
глобальный реестр символов - создавать в нём символы и обращаться к ним позже,
                             и при каждом обращении нам гарантированно будет 
                             возвращаться один и тот же символ.
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан
// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");
// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");
// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id

Системные символы:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
...

--- Strings ---------------------------------------------------------------
escape sequences:
    \n \t \v \b \f \r
methods:
    lenth           // lenth
    slice(7, 13)    // slice
    substring()     // slice - cannot accept negative indexes
    substr(7,6)     // 2 par - specifies the length of the extracted part
    replace()       // replase
    toUpperCase()   // to Upper
    toLowerCase()   // to Lower
    trim()          // removes whitespace from both sides of a string
    text.split(",") // Split on commas
format:
    'Welcome $(firstname)'
    `Total: ${(price * (1 + VAT)).toFixed(2)}`
    `<h2>${header}</h2><ul>` += `<li>${x}</li>`
search:    
    String.indexOf()        // position of the first occurrence
    String.lastIndexOf()    // last occurrence of a specified text
    String.search()         // eturns the position of the match
    String.match(regexp)    // returns the matches by regular expression
    String.includes()       // returns true if a string contains a value
    String.startsWith()     // true if a string begins with a value
    String.endsWith()       // true if a string ends with a specified value

--- Numbers --------------------------------------------------------
    let x = 3.14;       // A number with decimals
    let y = 3;          // A number without decimals 
    let x = 123e5;      // 12300000
    let y = 123e-5;     // 0.00123 
    let x = 10/"App";   // x will be NaN (Not a Number)
    isNaN(x);           // checking for NaN
    let x =  2 / 0;     // x will be Infinity
    let x = 0xFF;       // x will be 255
    x.toString();       // to string
    let x = 9.656;
    x.toFixed(2);       // округление до сотых '9.66'
    2**2                // вторая степень
    2**(1/2)            // квадратный корень

--- Arrays ----------------------------------------------------------------
    const cars = ["Saab", "Volvo", "BMW"];
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const points = [40, 100, 1, 5, 25, 10];
    cars[0] = "Opel";
    points[points.length-1] // 10 
    cars.toString();    // return string "Saab,Volvo,BMW"
    cars.join(" * ");   // return string "Saab * Volvo * BMW"
    fruits.pop();       // removes the last element from an array
    fruits.push("Kiwi");// adds a new element to an array (at the end)
    fruits.shift();     // removes the first array el and "shifts" all
    fruits.unshift("L");// dds a new element to an array (at the beginning)
    fruits.sort();      // Sorts the elements of fruits 
    fruits.reverse();   // reverse the order of the elements
    points.sort(function(a, b){return a - b}); // сортировка числовая
    points.sort(function(a, b){return 0.5 - Math.random()});    // random sort
    function myArrayMax(arr){return Math.max.apply(null, arr);} // max
    Math.max(1, 2, 3)   // the same as above
    const cars = [
        {type:"Volvo", year:2016},
        {type:"Saab", year:2001},
        {type:"BMW", year:2010}];
    cars.sort(function(a, b){return a.year - b.year});  // sort object
    let txt = "";
    numbers.forEach(myFunction);
    function myFunction(value, index, array) {
        txt += value + "<br>";
    }
Распаковка массива:
    let items = [1,2,3];        // массив
    let max = max(...items);    // передать в функцию распакованным
    let com = [...item,...arr]; // соединить массивы, можно комбинировать с 
                                   отдельными знач, в любом порявке
    let letters = [..."Hello"]; // распаковка строки на символы

 Перебрка массива:
    for-of:
    for (let value of fruits) {
        console.log(`value=${value}`);
    }
    for-each:
    fruits.forEach(el => console.log(el));

--- Циклы(loops) ---------------------------
    while (true) {              // while
        break;
    }

    for (var i=0; i<10; i++) {  // for
        continue;
    }

    do {                        // do while
        continue;
    } while (!false);
    
    for(let key in book) {      // foreach для объектов
        console.log(key+": "+book[key]);
    }

    for (let value of fruits) { // foreach для массивов
        console.log(`value=${value}`);
    }

    outer: for (let i = 0; i < 3; i++) {    // можно исп метки

    icons.forEach(element => {  // foreach для массивов
        console.log(element);
    });

--- Условные операторы ----------------------------------------
    if (true) {                 // if
        var x = true;
    } else if (false) {         // else if (elif)
        var x = 2;
    } else {                    // else
        var x = 'hui';          
    }

    switch (num) {              // switch (тип важен идет ===)
        case 1: console.log("item = 1");break;
        case 2: // группировка с 3-м
        case 3: console.log("item = 2");break;
        default: console.log("her");
    }

    Опциональная цепочка (?):
    Опциональная цепочка ?. останавливает вычисление и возвращает undefined,
    если значение перед ?. равно undefined или null
    user.address.street     // обращение к какому-то полю, где ошибка хз
    user?.address?.street   // проверив каждое перед вызовом или undefined
    obj?.prop       – возвращает obj.prop если obj существует, else undefined
    obj?.[prop]     – возвращает obj[prop] если obj существует, else undefined
    obj.method?.()  – вызывает obj.method(), если obj.method сущ, else возвр undefined

    Тернарный опрератор:
    let result = условие ? значение1 : значение2;
    let old = age > 50 ? "oldman" : "young";
    2 == 2 ? log(true) : log(false);

    Оператор нулевого слияния (??):
    result = a ?? b;    // проверка на null и undefined
    result = (a !== null && a !== undefined) ? a : b; 
    example:
    let firstName = null;
    let lastName = null;
    let nickName = "Суперкодер";
    // показывает первое значение, которое определено:
    alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
    // будет height=100, если переменная height равна null или undefined
    height = height ?? 100;

--- Math ---
random()    // 0 - 0.9999999...
floor()     // усечение дробной части

--- Debugger ------------------------------------
F12 - открыть devtools
F8  - выполнить до сл брейкпоинта
F9  - шаг - заходит внутрь ф-й
F10 - шаг поверх, не заходит внутрь
F11 - шаг как F9 + асинхронные
Shift+F11 - если случ зашли внуть - на конец ф-ии

если в скрипте написать 
debugger;   // остановка скрипта при открытом devtools


--- DOM - Document Object Model --------------------------------------------
           Window
    /         |         \
DOM         BOM         JavaScript
document    navigator   Object
            location    Array
            history     Function

Window - глобальная переменная - окно браузера со своими методами
BOM - доп объекты браузера для работы со всем кроме документа
DOM - все содержимое страницы в виде объектов, кот можно менять

document - объект который управляет DOM
const bodyElement = document.body   # элементы верхнего уровня это свойства

--- Навигация по узлам/элементам
bodyElement.firstChild      # первый дочерний элемент <body>
bodyElement.lastChild       # последний дочерний элемент <body>
bodyElement.previousSibling # предыдущ эл той же грубины вложенности
bodyElement.nextSibling     # следущ эл той же грубины вложенности
bodyElement.parentNode      # родительский элемент

Навигация по элементам(тэгам)
bodyElem.firtElementChild   # первый дочерний элемент <body>
bodyElem.lastElementChild   # последний дочерний элемент <body>
bodyElem.previousElementSibling # предыдущ эл той же грубины вложенности
bodyElem.nextElementSibling # следущ эл той же грубины вложенности
bodyElem.parentElement      # родительский элемент

Если при навигации нет узла/элемента - получим null

Коллекции
bodyElement.childNodes      # все дочерние узлы - элементы + комменты,
                              какой-то текст между тэгами, в общем все узлы
bodyElement.children        # все элементы(тэги)(и только)
bodyElement.hasChildNodes() # -> boolean, есть ли доч элем
bodyElement[0]              # обращение по индексу

# перебор коллекции
for (let node of childNodes) {
    console.log(node)
}
icons.forEach(element => {  # foreach
    console.log(element);
});

При изменении дерева DOM элементы коллекции автоматом меняют тек состояние
Менять сами элементы в коллекции можно только особым способом.

--- Поиск произвольных элементов по селектору, возврат Коллекция NodeList:
Ко всем полученным объектам из поиска можно применить св-ва навигации.
querySelectorAll    - возвращает статич коллекцию(сохр на момент создания)
getElementsBy       - коллекция меняется динамически всегда

document.querySelectorAll('.itm');      # по классу
document.getElementsByClassName('itm'); # аналогично по классу(без точки)
document.querySelectorAll('img');       # по тегу
document.getElementsByTagName('img');   # аналогично по тэгу
document.querySelectorAll('img.hu');    # по тегу с классом
document.querySelectorAll('.dui, .bui');# элементы нескольких классов
document.querySelectorAll('.dui .bui'); # элем класса .bui только в эл .hui
document.querySelectorAll('.item>li');  # 1 ур влож, у элементов класса .item
                                          ищутся на 1 ур вложенности тэги li
Поиск по id -> возврат 1 элем:
document.querySelector('#item');        # 1 элем по id
document.getElementById('item');        # 1 эл, поиск только c пом document

Поиск по аттрибуту:
document.querySelectorAll('[value]');   # элементы с аттриб value
document.getElementsByName('value');    # аналогично по имени аттриб
document.querySelectorAll('[val="0"]'); # элем с аттрибутом и значением

Искать можно на любом объекте не только document
document.querySelectorAll('#item').querySelectorAll('img');

Первый попавшийся элемент из коллекции:
document.querySelectorAll('.item')[0];  # 1-ый элем
document.querySelector('.item');        # идентично

Первый/ближайший предок:
elem.closest('.item');                  # ближайший предок или null

метод поиска           | ищет по      | возвращает| поиск внутри эл| Динамич
-----------------------+--------------+-----------+----------------+--------
querySelector           any CSS-селек  1 объект    +                -
querySelectorAll        any CSS-селек  коллккция   +                -
getElementById          id             1 объект    -                -   
getElementsByTagName    тэг или *      коллккция   +                +
getElementsByClassName  имя класса     коллккция   +                +
getElementsByName       name           коллккция   -                +

Проверка на соответствие объекта(можно исп в if)
elem.matches('[class$="about__item_active"]')   # -> boolean

--- Изменение элементов
const mainText = document.querySelector('.training__text');  # найдем элем
const elementIText = mainText.innerHTML;                     # сохр текст
mainText.innerHTML =
    `<p>${elementIText}</p>                                  # вставим текст
    <p><span class="yellow">FUUUUCK!!!</span></p>`;          # что-то допише

const elementOText = mainText.outerHTML;    # весь объект в текстовой форме
mainText.outerHTML = `<p>Deleted</p>`       # перезаписать весь объект
console.log(mainText.outerHTML);            # старый текст можно снова получ

const elementText = mainText.textContent;   # только текст
mainText.textContent = `<p>hui</p>`         # строка, автоэкранирование тэг

const getComment = mainText.nextSibling;    # получаем комент
console.log(getComment);                    # получ комент или текст вне тэг
console.log(getComment.data);               # текст комент
getComment.data = "fuck!";                  # изменить текст комента

--- Создание элементов
const newElement = document.createElement('div');   # создать div
newElement.innerHTML = `Hello`;                     # наполним содержимое
const newText = document.createTextNode("Fuck u!"); # создать узел, текст

--- Вставка созданных элементов(или сырого текста) тэги преобр в строки
mainText.before(newElement);                # вставить до элемента
mainText.after(newText);                    # вставить после элемента
mainText.prepend(newText);                  # внутрь в начало содержимого
mainText.append(newText);                   # внутрь в конец содержимого
mainText.append(newText, "some text");      # можно вставлять много объек

    <!-- before -->                 <!-- beforebegin -->
    <ul class="lesson__list">       <ul class="lesson__list">
        <!-- prepend -->                <!-- afterbegin -->
        <li>1</li>                      <li>1</li>
        <li>2</li>                      <li>2</li>
        <li>3</li>                      <li>3</li>
        <!-- append -->                 <!-- beforeend -->
    </ul>                           </ul>
    <!-- after -->                  <!-- afterend -->

--- Вставка html тэгов
1-ый прам куда, 2-й парам что вставляем(тэги/строки)
mainText.insertAdjacentHTML(`beforebegin`,`<p>text</p>`);   # перед объектом
mainText.insertAdjacentHTML(`afterbegin`,`<p>text</p>`);    # внутрь объекта перед содержимым
mainText.insertAdjacentHTML(`beforeend`,`<p>text</p>`);     # внутрь объекта после содержим
mainText.insertAdjacentHTML(`afterend`,`<p>text</p>`);      # после объекта

insertAdjacentText(`afterend`,`<p>...</p>`);    # вставляет текст как есть безетэгов
insertAdjacentElement(`afterend`, newElement);  # вставляет элемент(допустим новый)

--- Перенос/перемещение элемента
// находим элементы
const trainingHeader = document.querySelector('.training__header');
const trainingRow = document.querySelector('.training__row');
// перемещаем
trainingHeader.before(trainingRow);

--- Копия/Клон объекта
const cloneHeader = trainingHeader.cloneNode();         // копия верх ур
const cloneHeaderDeep = trainingHeader.cloneNode(true); // глубокая копия 

--- Удалить объект
cloneHeaderDeep.remove();   // удалить

--- Управление классами(лучший способ манипуляции компонентами)
classNameElem.className;                // классы - string
classNameElem.className = 'item__loh';  // перезаписать все классы на новы[й|e]
// более удобный инструмент
classNameElem.classList;                // классы в спец объекте(итерируемый)
classNameElem.classList.add('new-cls'); // добавить класс
classNameElem.classList.remove('cls');  // удалить класс
classNameElem.classList.toggle('cls');  // доб класс если его нет, если есть - удалить
classNameElem.classList.contains('cl'); // проверка на наличие - true/false

--- Стили
Изменить стили
element.style.color = "red";            // добавить стиль
Для стилей из нескольких слов используется camel case:
element.style.fontSize = "24px";        // для font-size
element.style.color = "";               // сбросить свойство
element.style.cssText = `               // сразу несколько стилей
    margin-bottom: 30px;
    color:red;
`;
Получить текущие значения стилей(чисто чтение)
getComputedStyle(element)               // вытащить все стили
getComputedStyle(element).fontFamily;   // вытащить семейство шрифта
getComputedStyle(element, "::after");   // вытащить стиль псевдоэлемента

--- Атрибуты и свойства
У разных дом элементов могут быть различные свойства и элементы
тэг <a>     - свойства связанные со ссылками ...
<input>     - свойства связанные с полем ввода ...
Аттрибуты   - парсятся браузером и создаются свойства на основе их
dir(link);  - получить список всех доступных свойств элемента
const link = document.querySelector('.lesson__link');  
const input = document.querySelector('.lesson__input');
console.log(link.href);     // http://www...
console.log(input.href);    // undefined - нет такого свойства
input.href = 'www.jshuihiu' // установить нов значение аттриб
link.hidden = true;         // скрыть объект с пом свойства
// Работа с нестандартными аттрибутами
element.hasAttribute('name');           // наличие аттрибута
element.getAttribute('name');           // значение аттрибута
element.setAttribute('name', 'value');  // установить аттрибут + значение
element.removeAttribute('name');        // удалить ат трибут
element.dataset;            // все аттрибуты нач-ся на data-
element.dataset.size = "1"; // изменить аттрибут data-size
element.dataset.fontSize;   // lower camel case для data-font-size

--- Размеры окна браузера
const elem = document.documentElement;  // весь документ html
element.clientWidth;                    // ширина окна до полосы прокрутки
element.clientHeight;                   // высота окна
window.innerWidth;                      // ширина вместе с полосами прокр
window.innerHeight;                     // высота

// макс ширина и высота документа включая прокрученную часть вычислить
let scrollWidth = Math.max(
    document.body.scrollWidth, document.documentElement.scrollWidth,
    document.body.offsetWidth, document.documentElement.offsetWidth,
    document.body.clientWidth, document.documentElement.clientWidth,
);
let scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight,
);

--- Управление прокруткой страницы
// получить кол-во прокрученных пикселей, только для чтения
window.pageYOffset;     // top прокруч пиксели сверху
window.pageXOffset;     // left прокруч пиксели слева

function setScroll() {          // своя функция, привяз к событию
    window.scrollBy(0, 50);     // прокрутить на (x, y)
    window.scrollTo(0,100);     // прокрутить к (x, y)
}

function setScroll() {          // своя функция, привяз к событию
    window.scrollTo({
        top: 50,
        left: 0,
        behavior: "smooth"      // плавно, instant - жестко
    });                         // прокрутить к (x, y) с опциями
}

// прокрутка до какого-либо элемента
function setScrollIntoView(top) {   // top - true/false
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView(top);    // true - элемент окажется вверху стр
}
function setScrollIntoViewOption(top) { // с опциями
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView({
        block: "center",    // start end nearest 
        inline: "nearest",  // center start end
        behavior: "smooth"  // auto
    });
}
// запретить прокрутку
function setDisableEnableScroll {
    document.body.style.overflow = "hidden";        // жестко лочим или
    document.body.classList.toggle('scroll-lock');  // в CSS лочим/разлочим
}

--- Метрики элементов на странице
const block = document.querySelector('.someblock'); // берем элемент
block.offsetParent;     // род элемент относ кот выполнено позиционирование
block.offsetLeft;       // положение по гориз относительно родителя
block.offsetTop;        // положение по вертик относительно родителя


--- Тестирование -----------------------------------------------------------
BDD – это три в одном: и тесты, и документация, и примеры использования.
Перед написанием основ тест-мой ф-ии в нашем случае pow(x,y) напишем спец-ю:
Спецификация:
    describe("pow", function() {                    // описание тестир ф-ии

        it("возводит 2 степень 3", function() {     // тесты(1+)
            assert.equal(pow(2, 3), 8);
        });

    });
Спецификация состоит из трёх основных блоков:
describe("заголовок", function() { ... });  - какая ф-ть описывается, использ
                                              для группировки  функций it()
it("описание", function() { ... });         - описываем что тестируем, и
                                              функция кот это делает
assert.*();                                 - исп для проверки рез-та

JavaScript-библиотеки для тестов:
Mocha   – основной фреймворк. Он предоставляет общие функции тестирования, 
          такие как describe и it, а также функцию запуска тестов.
Chai    – библиотека, множество функций проверки утверждений - assert. 
Sinon   – библиотека, позволяющая наблюдать за функциями, 
          эмулировать встроенные функции и многое другое.

# popular asserts:
assert.equal(value1, value2)            value1 == value2
assert.strictEqual(value1, value2)      value1 === value2
assert.notEqual(value1, value2)         value1 != value2
assert.notStrictEqual(value1, value2)   value1 !== value2
assert.isTrue(value)                    value === true
assert.isFalse(value)                   value === false

<!DOCTYPE html>
<html>
<head>
  <!-- добавим стили mocha для отображения результатов -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- добавляем сам фреймворк mocha -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    // включаем режим тестирования в стиле BDD
    mocha.setup('bdd');
  </script>
  <!-- добавим chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai предоставляет большое количество функций. Объявим assert глобально
    let assert = chai.assert;
  </script>
</head>
<body>
  <script>
    function pow(x, n) {
      <!-- здесь будет наша ф-ия см.ниже -->
    }
  </script>
  <!-- скрипт со спецификацией (describe, it...) -->
  <script src="test.js"></script>
  <!-- элемент с id="mocha" будет содержать результаты тестов -->
  <div id="mocha"></div>
  <!-- запускаем тесты! -->
  <script>
    mocha.run();
  </script>
</body>
</html>

# 4 теста
describe("pow", function() {
    before(() => console.log("перед всеми"));
    after(() => console.log("после всех"));
    beforeEach(() => console.log("перед каждым"));
    afterEach(() => console.log("после каждого"));
    
    it("2 в степени 3 будет 8", () => assert.equal(pow(2, 3), 8));
    it("3 в степени 3 будет 27", function() {
        assert.equal(pow(3, 3), 27);
    });
    it("для отрицательных n возвращает NaN", function() {
        assert.isNaN(pow(2, -1));
    });
    it("для дробных n возвращает NaN", function() {
        assert.isNaN(pow(2, 1.5));
    });
});

Итого пишем ф-ю:
function pow(x, n) {
    if (n < 0) return NaN;              // проверка на отриц
    if (Math.round(n) != n) return NaN; // проверка на целое
    let result = 1;
    for (let i = 0; i < n; i++) {       // само вычисление
        result *= x;
    }
    return result;
}
-----------------------------------------------------------------------------
--- Insert to .html ---
    External: (лучшее местo длы вставки в конце body, чтобы страница прогруз)
    <script src="myScript1.js"></script>    // ссылки на скрипты в коце <body>
    Если скрипт не может загрузится работает <noscript>:
    <noscript>Sorry, your browser does not support JavaScript!</noscript>

--- Output ---
    innerHTML           // вывод на странице: 
                          document.getElementById("demo").innerHTML = 5 + 6;
                          этот метод подходит как для кнопок так и на загрузке
    document.write()    // document.write(5 + 6); вывод на странице(на загрузке)
    window.alert()      // всплывающее сообщение браузера
    console.log()       // консоль
    window.print()      // распечатать
--- Input ---
    var inpt = prompt ("enter the name") // типа alert() сохр строку в перем.

--- Events ---
    <element event="some JavaScript">    
    Event 	       |  Description
    ---------------+----------------------------------------------------
    onchange 	   | An HTML element has been changed
    onclick 	   | The user clicks an HTML element
    onmouseover    | The user moves the mouse over an HTML element
    onmouseout 	   | The user moves the mouse away from an HTML element
    onkeydown 	   | The user pushes a keyboard key
    onload 	       | The browser has finished loading the page

--- JSHInt --------------------------------------------------------------
пакет-валидатор кода для VSCode
устанавливает пакет для node js:
    sudo apt install npm
установить jshint глобально:
    sudo npm install -g jshint
создаем в дирректории файл .jshintrc и добавляем нужные настройки:
{
    "camelcase": true,
    "indent": 4,
    "undef": true,
    "quotmark": false,
    "maxlen": 80,
    "trailing": true,
    "curly": true,
    "strict": true,
    "browser": true,
    "devel": true,
    "jquery": true,
    "esversion": 8,
    "node": true
}
документация:
    https://jshint.com/docs/
все вложенные директории попадают под валидацию