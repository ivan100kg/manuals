// JavaScript
--- Стандарты ---
    В новый стандартах добавляются полезные фишки
    ECMAScript 2009 - ES5
    ECMAScript 2015 - ES6
    "use strict";   // использовать в нач документа - означает соотв-е ES6+

--- Комментарии ---
    // comment
    /*
        multiline comment
    */

--- Литералы ---
    10          // целое 
    3.14        // дробное
    'dom'       // строки
    "dom"       // строки
    [1,2]       // массив
    {name:'X'}  // объект
    (ab|bc)     // рег выражение

--- Константы и переменные ---
    const MAX_VALUE = 200;      // константа(в верх регистре)
    const minValue = arr[0];    // вычисляемая константа(в ниж регистре)
    let arr = [HTML','CSS'];    // переменная, обычное поведение(C++, Python)
    var section;                // переменная, по старым стандартам(устар.)

--- Операторы ---
    + - * / % ** ++ --          // arithmetic
    = += -= *= /= %= **=        // assignment
    == === != !== > < >= <= ?   // ==(типы приводятся) ===(не приводятся)
    && || !                     // logical
    & | ~ ^ << >> >>>           // bit
    typeof()                    // type
    instanceof()                // instance of Array
    in                          // вхождение
    arr['HTML']                 // по ключу
    arr.HTML                    // через точку

--- Типы ------------------------------------------------------------------
    typeof()    // look a type of variable
    Number      // 0, -2, 3.14, 123e5, 12e-2, NaN, ±infinity
    BigInt      // 12345678901234567890n числа неогр длины -(n) на конце
    String      // 'hello' "world" `fuck ${name}`
    Object      // {}, [], null
    bollean     // true, false
    undefined   // let car; не определенная переменная
    Symbol      // symbol - уник идентиф в объектах
    function    // function
    
    null        // спец объект обозначает 'ничего'
    NaN         // вычислительная ошибка - люб мат операц с NaN это NaN
    Infinity    // +infinity
    -Infinity   // -infinity

    -------
    typeof x или typeof(x) - возвращ строковое знач типа данных
    example: if(typeof(obj === 'object'))

    строковое представление типов, при исп функции typeof():
    number
    string
    object
    undefined
    boolean
    bigint
    function
    symbol

    динамическая типизация - у переменых нет типа
    1 перемнной может быть присвоен различный тип данных по ходу кода

Приведение типов:
    String(78)  // '78' к строке
    Number('9') // 9 к числу
    +"10"       // 10 к числу
    Number('J') // NaN
    Boolean(9)  // true
    parseInt("15px", 10)    // к числу десятичная система

Автоприведение типов
    "7" + 8     // "78" если в сложении учавствует хоть 1 строка - рез-т строка
    8 + 'px'    // "8px"
    8/"2"*2     // 2 во всех других арифм операциях приводится к Number

Численное преобразование:
    undefined   -> NaN
    null        -> 0
    true        -> 1
    false       -> 0
    ""          -> 0
    " 123\n"    -> 123 происходит изначально trim
    " sdf"      -> NaN

Логическое преобразование:
    0, "", undefined, NaN   - false
    все остальное           - true

--- Взаимодействие: alert, prompt, confirm ---------------------------------
// перекрывают взаимодействие со страницей, пока не будет что-то нажато.
alert("Hello");             // окно с сообщ и кнопкой, ждет пока наж ОК
res = prompt('text', '1');  // окно с сообщ и полем ввода и кнопками ок 
                               отмена, второй парам не обяз - возвращается
                               если пользователь ничего не ввел и нажал ОК
                               если отмена - возврат null
result = confirm(question); // ok - true, отмена - false

--- Функции ---------------------------------------------------------------
    let b = 12;             // глобальная переменная - видно внутри функций
                               также их можно менять в функциях
    function foo() {        // объявление функции (видна до и после объявления)    
        let a = 5;          // видно только в функции
        return true;        // обычная функция
    }

    let foo = function() {  // функциональное выражение (видна посе объявления)
        return true;        // можно исп неименованную (типа lambda Python)
    };                      // в конце выражения ;
    
    let foo = () => true;   // стрелочная функция, аналог той что выше
    let foo = а => true;    // 1 аргумент
    let foo = (a,b) => a+b; // пример вычисления суммы, для многострочных при-
                               меняются {}, но возврат через return
    let foo = new Function('a', 'b', 'return a+b;');    // функция "на лету"
                                                           не раб в замыканиях
    foo();                  // вызов функции(указателя/ссылки)

    Функции не возращающие значения - не явно возвращают undefined
    return;                         - не явно возвращается undefined

Параметры ф-ии:
    function sum(a, b=100, ...args)     // a, b - позиц парам, b - имеет знач
                                           по умолч. ...args - массив осталь-
                                           ных арг-ов, может быть пустым
    sum(20,30);     // норм a=20, b=100
    sum(20);        // норм a=20, b=100(default)
    sum(20,30,40);  // норм a=20, b=100, args = [40,]
    sum();          // error - отсутствует обяз аргумент а


Функция setTimeout:
    отложенный вызов - вызывается параллельно, не зависит от расположения
                             ф-ия|выр   задерж мс  аргументы ф-ии
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
    clearTimeout(timerId)   // остановка вызова setTimeout
    setTimeout("alert('Привет')", 1000);        // можно исп строки с выраж-м
    setTimeout(() => alert('Привет'), 1000);    // или стрелочные

Функция setInterval:
    let idClock = setInterval(foo, 1000);   // вызыв-ся циклич-ки через 1с
    clearInterval(idClock)                  // остановка

Встроенные атрибуты ф-ий:
    function foo(msg) {
        console.log(msg);
    }
    foo.name    # имя ф-ии
    foo.bar = 0 # добавить свой аттр
    foo.call    # позвол вызв ф-ии с указ их контекста (context,arg1,arg2,...)
    foo.apply   # позвол вызв ф-ии с указ их контекста (context, args) массив

--- Лексическое окружение  ---
    Лексическое окружение - внешнее/внутренние - scope/зона видимости
    на самом деле это объекты лекс окр - хранящие свойсва этих зон вид-ти
    работу этих объектов контолирует интерпретатор, эти объекты существуют у 
    любого блока кода { ... }

    let number = 5;
    function logNumber(){
        let number = 4;
        console.log(number);
    }

    Scope
    Local:          // record environment - сначала ищется все тут
        this: undefined
        number: 4
    Script:
        number: 6
    Global:    

--- Замыкания ---
    Замыкание - это еще один объект лексического окружения, который
    может существовать в блоках
        Scope
        Local:      
        Closure:    
        Script:
        Global: 

    function createCounter(){           // функция которая возвращ др ф-ю
        let counter = 0;                // переменая

        const myFunction = function(){  // возвращаемая функция
            counter ++;                 // ссылаемся на внеш обл видимости
            return counter;
        };
        return myFunction;
    }

    const increment = createCounter();  // тут получаем функцию + лексическое окружение,
    const c1 = increment();                которое существовало при ее создании,
    const c2 = increment();                можно использовать это лекс окружение,
    const c3 = increment();                замыкание это ссылка на counter из влож ф-ии

    console.log(c1, c2, c3);    // 1 2 3

--- Objects --------------------------------------------------------
    let user = new Object();    // синтаксис "конструктор объекта"
    let user = {};              // синтаксис "литерал объекта"
    {ключ: значение}            // ключи - это строки, знач - любые объекты 
    newKey = 'gender';
    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        her,                    // сокращенно her:her
        for: 2,                 // допустимы let for return
        0: 123,                 // 0 -> '0'
        [user]: user            // исп переменных в ключах и значениях
        [выраж + перем]: male,  // люб вычисляемое занач из переменных/текста..
        fullName: function () { // this(тек бъект) т.е поля этого объекта
            return this.firstName + " " + this.lastName;
        },
        getId() {               // ES6 - компактный вариант
            return this.id;     
        },
    };

    Стрелочные функции не имеют this!

    person.firstNsme        // обращение к полю. 
    person['firstName']     // аналогично
    person.salary = 100     // изм знач атр, либо создание атр, если такого нет
    delete person.salary    // удалить атрибут 
    "salary" in person      // проверка на вхождение ключа 
    person.salary === undefined // та же проверка на вхождение 
    person['hi bye']        // получение поля если название с пробелом

    # пробежаться по объекту
    # свойства с целочисленными ключами сортируются по возрастанию,
      остальные располагаются в порядке создания
    for (let key in user) {
        // ключи
        alert( key );  // name, age, isAdmin
        // значения ключей
        alert( user[key] ); // John, 30, true
    }

    let user = {
        name: "John",
        age: 30,            // можно заканчивать запятой 
    }

    const user = {          // объект можно менять внутри, но ссылку нельзя
        name: "John"
    };

    # + ссылка на объект
    let a = {}; 
    let b = a;
    b == a;     // true - ссылаются на один и тот же об

    # копирование объекта
    let clone = {}; // новый пустой объект
    for (let key in user) {
        clone[key] = user[key];                 // поверхностная копия
    }
    const deepClone = Object.assign({}, user);  // глубокая копия объекта   
    const deepClone = {...user};                // глубокая копия объекта(ES9)

    // функция возвращающая объект
    function createCar(model, color) {
        return {
        model: model,
        color: color
        };
    }
    let car = createCar("toyota", "black");

    --- Функции-конструкторы технически являются обычными функциями
       два соглашения:
       Имя функции-конструктора должно начинаться с большой буквы
       Функция-конструктор должна выполняться только с помощью оператора "new"
    
    function Book(title, author) {          // ф-ция конструктор
        // this = {};   // (неявно)
        this.title = title;
        this.author = author;               // поле
        this.sayHi = function() {           // метод
            alert("Hello " + this.author);
        };
        // return this; // (неявно)         // возвращает новый объект
    }
    let book = new Book("Муму", "Турген");  // можно плодить объекты    

    new.target - св-во внутри функции, проверка, вызвана ли функция 
    при помощи оператора new или без него.
    function User() {
        console.log(new.target);
    }
    User();     // undefined            new.target = undefined
    new User(); // function User()...   new.target = самой ф-ии
    User.prototype.foo = function() => {};  // добавить всему классу какой-то атриб

    --- Контекст -------------------------
    Получение/использование контекста:
    1. в обычной функции
    function foo() {
        console.log(this);                  // this = window, для 'strict' - undefined
    }
    2. в методе объекта
    let obj = {
        a: 12,
        sum: function() {
            console.log(this);              // this - это сам объект obj
        }
    }
    3. в ф-ии конструкторе/классе
    function Book(title, author) {         
        // this = {};   // (неявно)
        this.title = title;                 // this - возвращаемый новый объект
        // return this; // (неявно)         // возвращает новый объект
    }
    4. в специальном свойстве ф-ии(call, apply, bind), передав туда объект
    foo.call(obj);                          // теперь при вызове обыч ф-ии this=obj
    foo.apply(obj);                         // то же самое, но если есть доп аргументы - 
                                               передаем их в массиве, а не через запятую
    function count(num) {
        return this*num;
    }
    const double = count.bind(2);           // 2 - this, bind связывает аргумент с this
    double(3);                              // 3 - num
    5. в обработчиках событий
    b.addEventListener('click',function(){  // обычн синтаксис ф-ии
        console.log(this);                  // this - это сам элемент на котором висит обработчик
    });
    b.addEventListener('click', () => {     // стрелочная ф-ия, нет своего контекста
        console.log(this);                  // this - это объект window(родительский контекст)
    });



    --- Преобразование объектов в примитивы: -------------------
        - объект может быть преобразован тоьлко в строку или число 
        - математическая операция с объектами - возвращает примитив
        - числовое преобразование происходит, когда мы вычитаем объекты
          или применяем математические функции
        - преобразование к строке log(obj)/alert(obj).. типа такого
    Хинты:
        спец методы объекта - реализуют преобразования объектов
        "string"    - к строке alert(obj); anotherObj[obj] = 123;
        "number"    - к числу let num = Number(obj); let n = +obj;
        "default"   - оператор «не уверен», какой тип ожидать
                      let total = obj1 + obj2;
    Чтобы выполнить преобразование, JavaScript пытается найти и вызвать
    три следующих метода объекта:
        obj[Symbol.toPrimitive](hint);  // метод с символьным ключом
        obj.toString(); obj.valueOf();  // иначе хинт = "string"
        obj.valueOf(); obj.toString();  // иначе хинт = "number" or "default"

    Object - спец объект для работы с объектами:
    Object.keys(obj)    // массив ключей объекта obj
    Object.values(obj)  // массив значений
    Object.entries(obj) // массив массивов ключ-значение

    Деструктуризация объекта:
    const obj = {       // исходный объект
        name: 'test',
        width: 2048,
        color: {
            r: 196,
            b: 96,
            g: 128
        }
    };
    const {r,g,b} = obj.color;  // деструктуризация
    console.log(g);             // 128


--- Classes/Классы ------------------------------------------------------------
Это обертка над функциями-коннструкторами, синт сахар
class Rectangle {                           // класс
    constructor(height, width, parent) {    // конструктор
        this.height = height;               // иниц поля
        this.width = width;
        this.parent = document.querySelector('#parent');
    }

    calsArea() {                            // метод
        return this.height * this.width;
    }

    render() {                              // отрисовка
        const div = document.createElement('div');
        div.style.width = this.width;
        div.style.height = this.height;
        div.style.backgroundColor = 'red';
        div.textContent = 'Hello blya!';
        this.parent.append(div);
    }
}

const square = new Rectangle(12,13);        // объект
console.log(square.calsArea());

class ColoredRect extends Rectangle {       // наследование
    constructor(height, width, color) {
        super(height, width);               // вызов конструктора родителя
        this.color = color;
    }
}


--- OOP --------------------------------------------------------------------
Каждый экземпляр какого-то класса имеет имеет поля и методы, которые можно
использовать. Все эти свойства экз видны в dev-tools браузерa
const arr = [1,2,3,4];
console.log(arr);   // выведет сам массив + [[Prototype]]: Array(0)
                       для объектов будет   [[Prototype]]: Object
[[Prototype]]: Object - это и есть класс нашего экземпляра со всеми св-ми
Object - вершина для всех, все в итоге наследуют поля и методы от него,
что-то дополняя или переопределяя

Наследование:
const soldier = {           // parent
    health: 400,
    armor: 100
};

const john = {              // child
    health: 100
};

john.__proto__ = soldier;               // устаревший способ
Object.setPrototypeOf(john, soldier);   // добавить связь parent/child
const mike = Object.create(soldier);    // создать наследника от parent

--- Symbol -----------------------------------------------------------------
в качестве ключей для свойств объекта могут исп только строки или символы
// Создаём новый символ - id с описанием(метка) "id"
let id1 = Symbol("id");     // каждый раз уник, метка ни на что не влияет
let id2 = Symbol("id");     // не равен выше стоящему символу
id1.description;            // -> id, возвраает метку              

// символы не преобразоваются автоматически в строки
alert(id1);                 // TypeError: Cannot convert a Symbol value to..
alert(id1.toString());      // так можно

// скрытые свойства символов
let user = {                // some object
    name: "Вася",
     [id]: 123              // можно так добавить символ, литералом
};
let id = Symbol("id");      // символ
user[id] = 1;               // если доб свойсво так - оно будет скрыто в 
                               других частях программы (за скопом)
alert(user[id]);            // доступ к данным по ключу-символу
если в какой-то другой части программы к этому объекту вновь добавить
свойство, пускай даже под таким же именем
let id = Symbol("id");      // символ в другой части программы
user[id] = 2;               // совершенно другой символ, не затерает первый
Символы игнорируются циклом for…in

Глобальные символы:
глобальный реестр символов - создавать в нём символы и обращаться к ним позже,
                             и при каждом обращении нам гарантированно будет 
                             возвращаться один и тот же символ.
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан
// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");
// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");
// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id

Системные символы:
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
...

--- Strings ---------------------------------------------------------------
'str';                  - строка, примитивный тип данных
'str'.toUpperCase();    - при применении методов идет оборачивание в объект
                          и после метода - снова преобразуется к строке
let str = new String(); - объект, в такой заворачивается примитивы

escape sequences:
    \n \t \v \b \f \r
methods:
    lenth           // lenth
    slice(7, 13)    // slice
    substring()     // slice - cannot accept negative indexes
    substr(7,6)     // 2 par - specifies the length of the extracted part
    replace()       // replase
    toUpperCase()   // to Upper
    toLowerCase()   // to Lower
    trim()          // removes whitespace from both sides of a string
    text.split(",") // Split on commas
format:
    'Welcome $(firstname)'
    `Total: ${(price * (1 + VAT)).toFixed(2)}`
    `<h2>${header}</h2><ul>` += `<li>${x}</li>`
search:    
    String.indexOf()        // position of the first occurrence
    String.lastIndexOf()    // last occurrence of a specified text
    String.search()         // eturns the position of the match
    String.match(regexp)    // returns the matches by regular expression
    String.includes()       // returns true if a string contains a value
    String.startsWith()     // true if a string begins with a value
    String.endsWith()       // true if a string ends with a specified value

--- Numbers --------------------------------------------------------
    let x = 3.14;       // A number with decimals
    let y = 3;          // A number without decimals 
    let x = 123e5;      // 12300000
    let y = 123e-5;     // 0.00123 
    let x = 10/"App";   // x will be NaN (Not a Number)
    isNaN(x);           // checking for NaN
    let x =  2 / 0;     // x will be Infinity
    let x = 0xFF;       // x will be 255
    x.toString();       // to string
    let x = 9.656;
    x.toFixed(2);       // округление до сотых '9.66'
    2**2                // вторая степень
    2**(1/2)            // квадратный корень

--- Arrays ----------------------------------------------------------------
    const cars = ["Saab", "Volvo", "BMW"];
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const points = [40, 100, 1, 5, 25, 10];
    cars[0] = "Opel";
    points[points.length-1] // 10 
    cars.toString();    // return string "Saab,Volvo,BMW"
    cars.join(" * ");   // return string "Saab * Volvo * BMW"
    fruits.pop();       // removes the last element from an array
    fruits.push("Kiwi");// adds a new element to an array (at the end)
    fruits.shift();     // removes the first array el and "shifts" all
    fruits.unshift("L");// dds a new element to an array (at the beginning)
    fruits.sort();      // Sorts the elements of fruits 
    fruits.reverse();   // reverse the order of the elements
    points.sort(function(a, b){return a - b}); // сортировка числовая
    points.sort(function(a, b){return 0.5 - Math.random()});    // random sort
    function myArrayMax(arr){return Math.max.apply(null, arr);} // max
    Math.max(1, 2, 3)   // the same as above
    const cars = [
        {type:"Volvo", year:2016},
        {type:"Saab", year:2001},
        {type:"BMW", year:2010}];
    cars.sort(function(a, b){return a.year - b.year});  // sort object

Копия:
    const newArray = oldArray.slice();  // копия массива
    const newArray = [...oldArray];     // копия массива

Распаковка массива:
    let items = [1,2,3];        // массив
    let max = max(...items);    // передать в функцию распакованным
    let com = [...item,...arr]; // соединить массивы, можно комбинировать с 
                                   отдельными знач, в любом порявке
    let letters = [..."Hello"]; // распаковка строки на символы

Перебрка массива:
    for-of:
    for (let value of fruits) {
        console.log(`value=${value}`);
    }

    for-each:
    arr.forEach(function(value, index, array) {
        console.log(`${value} : ${index} : ${array}`);
    });
   
    for-each(lambda):
    fruits.forEach((val, ind, arr)  => console.log(val));

    // все методы перебора(как стримы в Java)
    arr.forEach     // просто переборка
    arr.map         // применяет к каждому эл функцию -> возвращ нов массив
    arr.every/some  // 
    arr.filter      // фильтрует по ф-ии
    arr.reduce   
    arr.sort        // сортировка, если без ф-ии сортирует как строки

--- Циклы(loops) ---------------------------
    while (true) {              // while
        break;
    }

    for (var i=0; i<10; i++) {  // for
        continue;
    }

    do {                        // do while
        continue;
    } while (!false);
    
    for(let key in book) {      // foreach для объектов
        console.log(key+": "+book[key]);
    }

    for (let value of fruits) { // foreach для массивов
        console.log(`value=${value}`);
    }

    outer: for (let i = 0; i < 3; i++) {    // можно исп метки

    icons.forEach(element => {  // foreach для массивов
        console.log(element);
    });

--- Условные операторы ----------------------------------------
    if (true) {                 // if
        var x = true;
    } else if (false) {         // else if (elif)
        var x = 2;
    } else {                    // else
        var x = 'hui';          
    }

    switch (num) {              // switch (тип важен идет ===)
        case 1: console.log("item = 1");break;
        case 2: // группировка с 3-м
        case 3: console.log("item = 2");break;
        default: console.log("her");
    }

    Опциональная цепочка (?):
    Опциональная цепочка ?. останавливает вычисление и возвращает undefined,
    если значение перед ?. равно undefined или null
    user.address.street     // обращение к какому-то полю, где ошибка хз
    user?.address?.street   // проверив каждое перед вызовом или undefined
    obj?.prop       – возвращает obj.prop если obj существует, else undefined
    obj?.[prop]     – возвращает obj[prop] если obj существует, else undefined
    obj.method?.()  – вызывает obj.method(), если obj.method сущ, else возвр undefined

    Тернарный опрератор:
    let result = условие ? значение1 : значение2;
    let old = age > 50 ? "oldman" : "young";
    2 == 2 ? log(true) : log(false);

    Оператор нулевого слияния (??):
    если первое null или undefined - то берется второе значение, иначе первое
    result = a ?? b;    // проверка на null и undefined
    result = (a !== null && a !== undefined) ? a : b; 
    example:
    let firstName = null;
    let lastName = null;
    let nickName = "Суперкодер";
    // показывает первое значение, которое определено:
    alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
    // будет height=100, если переменная height равна null или undefined
    height = height ?? 100;

--- Math ---
random()    // 0 - 0.9999999...
floor()     // усечение дробной части


--- Collections ---------------------------------
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, 
что Map позволяет использовать ключи любого типа.
Методы и свойства:
new Map()           – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key)        – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key)        – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key)     – удаляет элемент (пару «ключ/значение») по ключу key.
map.clear()         – очищает коллекцию от всех элементов.
map.size            – возвращает текущее количество элементов.

Перебор Map
Для перебора коллекции Map есть 3 метода:
map.keys()      – возвращает итерируемый объект по ключам,
map.values()    – возвращает итерируемый объект по значениям,
map.entries()   – возвращает итерируемый объект по парам вида [ключ, значение],
                  этот вариант используется по умолчанию в for..of.
// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});

let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));         // map из объекта
let obj = Object.fromEntries(map);              // объект из map(entries)

Set
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
new Set(iterable)   – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив),
                      то копирует его значения в новый Set.
set.add(value)      – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value)   – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(value)      – возвращает true, если значение присутствует в множестве, иначе false.
set.clear()         – удаляет все имеющиеся значения.
set.size            – возвращает количество элементов в множестве

Перебор объекта Set
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:
let set = new Set(["апельсин", "яблоко", "банан"]);
for (let value of set) alert(value);
// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});

WeakMap() WeakSet() - структуры которые динамически меняются, если объект внутри приравнять null
                      где-то в коде, то в этих структурах так-же потеряются ссылки. Внутри могут
                      хранить только объекты.


--- Date/Дата, время ----------------------------------------------
const now = new Date();                 // 2023-03-17T12:45:31.745Z
const now = new Date('2000-01-01');     // дата по строке 2000-01-01T00:00:00.000Z
const now = new Date(2000, 5, 1, 20);   // дата по числам-параметрам 2000-06-01T17:00:00.000Z
const now = new Date(0);                // дата в миллисекундах от 1970-01-01T00:00:00.000Z
// получить
now.getFullYear();                      // год
now.getMonth();                         // месяц
now.getDate();                          // день
now.getTime();                          // миллисекунды от 1 1970
now.getTimezoneOffset();                // разница по таймзоне
// сохранить
now.setFullYear(2024);                  // установить год
// таймер
let start = new Date();
let end = new Date();
let interval = end - start;             // автоматически переводится в миллисекунды

--- Debugger ------------------------------------
F12 - открыть devtools
F8  - выполнить до сл брейкпоинта
F9  - шаг - заходит внутрь ф-й
F10 - шаг поверх, не заходит внутрь
F11 - шаг как F9 + асинхронные
Shift+F11 - если случ зашли внуть - на конец ф-ии

если в скрипте написать 
debugger;   // остановка(breakpoint) скрипта при открытом devtools


============================================================================
--- DOM - Document Object Model --------------------------------------------
           Window
    /         |         \
DOM         BOM         JavaScript
document    navigator   Object
            location    Array
            history     Function

Window  - глобальная переменная - окно браузера со своими методами
BOM     - доп объекты браузера для работы со всем кроме документа
DOM     - все содержимое страницы в виде объектов, кот можно менять

Узел    - любой компонент страницы - элемент, текст, comment..
Элемент - тэги

document - объект который управляет DOM / страница вся - все элементы
const html = document.documentElement   # html
const head = document.head              # head
const body = document.body              # body

Загрузка страницы, размещение скрипта
размещаем скрипты в конце страницы, либо
<script defer src="js/script.js"></script>  - продолжает загрузку документа,
скрипт выполняется в фоновом режиме, выполняется после полной загрузки дом дерева,
если несколько скриптов defer - выполняются по очереди.
<script async src="js/script.js"></script>  - продолжает загр докуиента, нов
скрипт выполняется не дожидаясь загрузки dom, а также не ждет очереди
других async скиптов.
// можно создать динамич скрипт
const script = document.createElement('script');
script.src = 'js/test.js';
script.async = false;       //  по умолчанию async
document.body.append(script);

--- Навигация по узлам/элементам
bodyElement.firstChild      # первый дочерний элемент <body>
bodyElement.lastChild       # последний дочерний элемент <body>
bodyElement.previousSibling # предыдущ эл той же грубины вложенности
bodyElement.nextSibling     # следущ эл той же грубины вложенности
bodyElement.parentNode      # родительский элемент

Навигация по элементам(тэгам)
bodyElem.firtElementChild   # первый дочерний элемент <body>
bodyElem.lastElementChild   # последний дочерний элемент <body>
bodyElem.previousElementSibling # предыдущ эл той же грубины вложенности
bodyElem.nextElementSibling # следущ эл той же грубины вложенности
bodyElem.parentElement      # родительский элемент

Если при навигации нет узла/элемента - получим null

Коллекции
bodyElement.childNodes      # все дочерние узлы - элементы + комменты,
                              какой-то текст между тэгами, в общем все узлы
bodyElement.children        # все элементы(тэги)(и только)
bodyElement.hasChildNodes() # -> boolean, есть ли доч элем
bodyElement.children[0]     # обращение по индексу

# перебор коллекции
for (let node of childNodes) {
    console.log(node)
}
icons.forEach(element => {  # foreach
    console.log(element);
});

При изменении дерева DOM элементы коллекции автоматом меняют тек состояние
Менять сами элементы в коллекции можно только особым способом.

--- Поиск произвольных элементов по селектору, возврат Коллекция NodeList:
Ко всем полученным объектам из поиска можно применить св-ва навигации.
querySelectorAll    - возвращает статич коллекцию(сохр на момент создания)
getElementsBy       - коллекция меняется динамически всегда

Поиск по тэгу/классу
document.querySelectorAll('.itm');      # по классу
document.getElementsByClassName('itm'); # аналогично по классу(без точки)
document.querySelectorAll('img');       # по тегу
document.getElementsByTagName('img');   # аналогично по тэгу
document.querySelectorAll('img.hu');    # по тегу с классом
document.querySelectorAll('.dui, .bui');# элементы нескольких классов
document.querySelectorAll('.dui .bui'); # элем класса .bui только в эл .dui
document.querySelectorAll('.item>li');  # 1 ур влож, у элементов класса .item
                                          ищутся на 1 ур вложенности тэги li
Поиск по id -> возврат 1 элем:
document.querySelector('#item');        # 1 элем по id
document.getElementById('item');        # 1 эл, поиск только c пом document

Поиск по аттрибуту:
document.querySelectorAll('[value]');   # элементы с аттриб value
document.getElementsByName('value');    # аналогично по имени аттриб
document.querySelectorAll('[val="0"]'); # элем с аттрибутом и значением

Искать можно на любом объекте не только document
document.querySelectorAll('#item').querySelectorAll('img');

Первый попавшийся элемент из коллекции:
document.querySelectorAll('.item')[0];  # 1-ый элем
document.querySelector('.item');        # идентично

Первый/ближайший предок:
elem.closest('.item');                  # ближайший предок или null

метод поиска           | ищет по      | возвращает| поиск внутри эл| Динамич
-----------------------+--------------+-----------+----------------+--------
querySelector           any CSS-селек  1 объект    +                -
querySelectorAll        any CSS-селек  коллккция   +                -
getElementById          id             1 объект    -                -   
getElementsByTagName    тэг или *      коллккция   +                +
getElementsByClassName  имя класса     коллккция   +                +
getElementsByName       name           коллккция   -                +

Проверка на соответствие объекта(можно исп в if)
elem.matches('[class$="about__item_active"]')   # -> boolean

--- Изменение элементов
const mainText = document.querySelector('.training__text');  # найдем элем
// innerHTML - добавляет как текст так и тэги
const elementIText = mainText.innerHTML;                     # сохр текст
mainText.innerHTML =
    `<p>${elementIText}</p>                                  # вставим текст
    <p><span class="yellow">FUUUUCK!!!</span></p>`;          # что-то допише

const elementOText = mainText.outerHTML;    # весь объект в текстовой форме
mainText.outerHTML = `<p>Deleted</p>`       # перезаписать весь объект
console.log(mainText.outerHTML);            # старый текст можно снова получ

const elementText = mainText.textContent;   # только текст
mainText.textContent = `<p>hui</p>`         # строка, автоэкранирование тэг

const getComment = mainText.nextSibling;    # получаем комент
console.log(getComment);                    # получ комент или текст вне тэг
console.log(getComment.data);               # текст комент
getComment.data = "fuck!";                  # изменить текст комента

--- Создание элементов
const newElement = document.createElement('div');   # создать div
newElement.innerHTML = `Hello`;                     # наполним содержимое
const newText = document.createTextNode("Fuck u!"); # создать узел, текст

--- Вставка созданных элементов(или сырого текста) тэги преобр в строки
mainText.appendChild(elem);     # устаревший - то же что append
mainText.removeChild(elem);     # устаревший - то же что remove
            ...Child...         # etc

mainText.before(newElement);                # вставить до элемента
mainText.after(newText);                    # вставить после элемента
mainText.prepend(newText);                  # внутрь в начало содержимого
mainText.append(newText);                   # внутрь в конец содержимого
mainText.append(newText, "some text");      # можно вставлять много объек

    <!-- before -->                 <!-- beforebegin -->
    <ul class="lesson__list">       <ul class="lesson__list">
        <!-- prepend -->                <!-- afterbegin -->
        <li>1</li>                      <li>1</li>
        <li>2</li>                      <li>2</li>
        <li>3</li>                      <li>3</li>
        <!-- append -->                 <!-- beforeend -->
    </ul>                           </ul>
    <!-- after -->                  <!-- afterend -->

--- Вставка html тэгов
1-ый прам куда, 2-й парам что вставляем(тэги/строки)
mainText.insertAdjacentHTML(`beforebegin`,`<p>text</p>`);   # перед объектом
mainText.insertAdjacentHTML(`afterbegin`,`<p>text</p>`);    # внутрь объекта перед содержимым
mainText.insertAdjacentHTML(`beforeend`,`<p>text</p>`);     # внутрь объекта после содержим
mainText.insertAdjacentHTML(`afterend`,`<p>text</p>`);      # после объекта

insertAdjacentText(`afterend`,`<p>...</p>`);    # вставляет текст как есть безетэгов
insertAdjacentElement(`afterend`, newElement);  # вставляет элемент(допустим новый)

--- Перенос/перемещение элемента
// находим элементы
const trainingHeader = document.querySelector('.training__header');
const trainingRow = document.querySelector('.training__row');
// перемещаем
trainingHeader.before(trainingRow);

--- Копия/Клон объекта
const cloneHeader = trainingHeader.cloneNode();         // копия верх ур
const cloneHeaderDeep = trainingHeader.cloneNode(true); // глубокая копия 

--- Замена
oldElem.replaceWith(newElem);   // заменить на др элемент

--- Удалить объект
cloneHeaderDeep.remove();   // удалить

--- Управление классами(лучший способ манипуляции компонентами)
// устаревший
classNameElem.className;                // классы - string
classNameElem.className = 'item__loh';  // перезаписать все классы на новы[й|e]
// более удобный инструмент
classNameElem.classList;                // классы в спец объекте(итерируемый)
classNameElem.classList.add('new-cls'); // добавить класс, ('cl1', 'cl2' ...) неск
classNameElem.classList.remove('cls');  // удалить класс
classNameElem.classList.toggle('cls');  // доб класс если его нет, если есть - удалить
classNameElem.classList.contains('cl'); // проверка на наличие - true/false

--- Стили
Изменить стили в html inline
element.style.color = "red";            // добавить стиль
Для стилей из нескольких слов используется camel case:
element.style.fontSize = "24px";        // для font-size
element.style.color = "";               // сбросить свойство
element.style.cssText = `               // сразу несколько стилей
    margin-bottom: 30px;
    color:red;
`;
Получить текущие значения стилей(чисто чтение) из CSS
window.getComputedStyle(element)        // вытащить все стили
getComputedStyle(element).fontFamily;   // вытащить семейство шрифта
getComputedStyle(element, "::after");   // вытащить стиль псевдоэлемента

--- Атрибуты и свойства
У разных дом элементов могут быть различные свойства и элементы
тэг <a>     - свойства связанные со ссылками ...
<input>     - свойства связанные с полем ввода ...
Аттрибуты   - парсятся браузером и создаются свойства на основе их
dir(link);  - получить список всех доступных свойств элемента
const link = document.querySelector('.lesson__link');  
const input = document.querySelector('.lesson__input');
console.log(link.href);     // http://www...
console.log(input.href);    // undefined - нет такого свойства
input.href = 'www.jshuihiu' // установить нов значение аттриб
link.hidden = true;         // скрыть объект с пом свойства

// Работа с нестандартными аттрибутами
element.hasAttribute('name');           // наличие аттрибута
element.getAttribute('name');           // значение аттрибута
element.setAttribute('name', 'value');  // установить аттрибут + значение
element.removeAttribute('name');        // удалить ат трибут
setAttribute('onclick', 'clickMe()');   // установить обработчик события
element.dataset;            // все аттрибуты нач-ся на data-
element.dataset.size = "1"; // изменить аттрибут data-size
element.dataset.fontSize;   // lower camel case для data-font-size


--- Размеры окна браузера -----------------------------------
const elem = document.documentElement;  // весь документ html
element.clientWidth;                    // ширина окна до полосы прокрутки
element.clientHeight;                   // высота окна
element.offsetWidth;                    // ширина окна с полосой прокрутки
element.offsetHeight;                   // высота окна с полосой прокрутки
element.scrollWidth;                    // ширина окна всего - игнор прокрутки
element.scrollHeight;                   // высота окна всего - игнор прокрутки
window.innerWidth;                      // ширина вместе с полосами прокр
window.innerHeight;                     // высота

// эти можно изменять
el.scrollTop;                           // сколько проскролено в px

// макс ширина и высота документа включая прокрученную часть вычислить
let scrollWidth = Math.max(
    document.body.scrollWidth, document.documentElement.scrollWidth,
    document.body.offsetWidth, document.documentElement.offsetWidth,
    document.body.clientWidth, document.documentElement.clientWidth,
);
let scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight,
);

--- Управление прокруткой страницы
// получить кол-во прокрученных пикселей, только для чтения
window.pageYOffset;     // top прокруч пиксели сверху
window.pageXOffset;     // left прокруч пиксели слева

function setScroll() {          // своя функция, привяз к событию
    window.scrollBy(0, 50);     // прокрутить на (x, y)
    window.scrollTo(0,100);     // прокрутить к (x, y)
}

function setScroll() {          // своя функция, привяз к событию
    window.scrollTo({
        top: 50,
        left: 0,
        behavior: "smooth"      // плавно, instant - жестко
    });                         // прокрутить к (x, y) с опциями
}

// прокрутка до какого-либо элемента
function setScrollIntoView(top) {   // top - true/false
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView(top);    // true - элемент окажется вверху стр
}
function setScrollIntoViewOption(top) { // с опциями
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView({
        block: "center",    // start end nearest 
        inline: "nearest",  // center start end
        behavior: "smooth"  // auto
    });
}
// запретить прокрутку
function setDisableEnableScroll {
    document.body.style.overflow = "hidden";        // жестко лочим или
    document.body.classList.toggle('scroll-lock');  // в CSS лочим/разлочим
}

--- Метрики элементов на странице
const block = document.querySelector('.someblock'); // берем элемент
block.offsetParent;             // род элемент относ кот выполнено позиционирование
block.offsetLeft;               // положение по гориз относительно родителя
block.offsetTop;                // положение по вертик относительно родителя
block.getBoundingClientRect;    // координаты элемента на странице

-----------------------------------------------------------------------------

--- Events ---
    Для использования события нужно назначить обработчик события.
    Обработчик события - функция кот срабатывает как только событие произошло
    
    Варианты создания обработчиков событий:
    <button onclick="clickMe()" id="btn">click me</button>  
    const btn = document.querySelector('#btn');
    btn.setAttribute('onclick', 'clickMe()');
    
    // the best 
    addEventListener(событиe прописываем без 'on', 
                     callback function(обыч/стрел),
                     опции не обяз);    
    ------------------------------------------------------------------
    addEventListener('event', callbackFoo);     // добавить обработчик
    removeEventListener('event', callbackFoo);  // удалить обработчик

    btn.addEventListener('click', clickMe);             // add listener
    btn.addEventListener('mouseout', () => log('2'));   // add +1 listener
    
    // аргументы callback функции(необяз) 1 арг - событие, остальные свои
    btn.addEventListener('click', (e, args) => {
        console.log(e);     // объект MouseEvent(тип события, цель, коорды...)
        e.target;           // элемент на котором висит обработчик
    });

    Делегирование событий - вешаем обработчик на предка - принимают потомки
    // можно обработчик навесить на весь div с кнопками и проверять ткнули
       ли на кнопку или еще куда-то
    if(event?.target?.tagName === 'BUTTON' ||       // тэг кнопка
       event?.target?.classList.contains('cls') ||  // проверка на класс
       event?.target?.matches('button.cls')){       // проверка тэг+класс
        console.log(event.target);
    }

    // отдельная callback функция для удобства
    const delBtn = (e) => e.target.remove();
    btn.addEventListener('mouseout', delBtn);   // удалит сам себя после соб 

    // всплытие событий
       два обработчика на элементе и его родителе/влож элементе
       первым срабатывает обраб влож элемента, потом остальные
       e.currentTarget();   // в отличие от target показывает текущий элемент

    // переопределить стандартное поведение элементов(ссылки, формы, ...)
    const link = document.querySelector('a');
    link.addEventListener('click', function(e) {
        e.preventDefault());    // сброс стд поведения ссылки
        console.log('e.target') // своя логика
    }

    // опции события
    btn.addEventListener('click', clickMe, {once: true});   // обработчик сраб
                                                               только 1 раз.
    
    Event 	       |  Description
    ---------------+----------------------------------------------------
    change 	       | An HTML element has been changed
    click 	       | The user clicks an HTML element
    mouseover      | The user moves the mouse over an HTML element
    mouseenter     | The user moves the mouse in an HTML element
    mouseout 	   | The user moves the mouse away from an HTML element
    keydown 	   | The user pushes a keyboard key
    input          | что-то изменилось поле текста(набор текста)
    submit         | при нажатии в форме на кнопку submit(не забываем e.preventDefault())

    События при загрузки страницы:
    load - срабатывает когда страница полностью прогрузилась со всеми эл
    DOMContentLoaded - DOM дерево полность прогрузилось(остальное возможно нет)
    document.addEventListener('DOMContentLoaded', foo); // использование
    window.addEventListener('DOMContentLoaded', foo);   // аналогично


--- Модальное окно --------------------------------------------------------
https://www.schoolsw3.com/howto/tryhow_css_modal2.php - пример
// создаем div и навешиваем стили
.show {
    display: block;
}

.hide {
    display: none;
}

.modal {
    position: fixed; /* Оставаться на месте */
    width: 200;
    height: 200;
    z-index: 1; /* Сидеть на вершине */
    padding-top: 100px; /* Расположение коробки */
    left: 200;
    top: 200;
    overflow: auto; /* Включите прокрутку, если это необходимо */
    background-color: rgb(0,0,0); /* Цвет запасной вариант  */
    background-color: rgba(0,0,0,0.4); /*Черный с непрозрачностью */
}

// навешиваем события на кнопки и просто меняем видимость окна
modalTrigger.addEventListener('click', () => {
    modal.classList.add('show');
    modal.classList.remove('hide');
    document.body.style.overflow = 'hidden';
});

modalCloseBtn.addEventListener('click', () => {
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = '';
});


--- Тестирование -----------------------------------------------------------
BDD – это три в одном: и тесты, и документация, и примеры использования.
Перед написанием основ тест-мой ф-ии в нашем случае pow(x,y) напишем спец-ю:
Спецификация:
    describe("pow", function() {                    // описание тестир ф-ии

        it("возводит 2 степень 3", function() {     // тесты(1+)
            assert.equal(pow(2, 3), 8);
        });

    });
Спецификация состоит из трёх основных блоков:
describe("заголовок", function() { ... });  - какая ф-ть описывается, использ
                                              для группировки  функций it()
it("описание", function() { ... });         - описываем что тестируем, и
                                              функция кот это делает
assert.*();                                 - исп для проверки рез-та

JavaScript-библиотеки для тестов:
Mocha   – основной фреймворк. Он предоставляет общие функции тестирования, 
          такие как describe и it, а также функцию запуска тестов.
Chai    – библиотека, множество функций проверки утверждений - assert. 
Sinon   – библиотека, позволяющая наблюдать за функциями, 
          эмулировать встроенные функции и многое другое.

# popular asserts:
assert.equal(value1, value2)            value1 == value2
assert.strictEqual(value1, value2)      value1 === value2
assert.notEqual(value1, value2)         value1 != value2
assert.notStrictEqual(value1, value2)   value1 !== value2
assert.isTrue(value)                    value === true
assert.isFalse(value)                   value === false

<!DOCTYPE html>
<html>
<head>
  <!-- добавим стили mocha для отображения результатов -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- добавляем сам фреймворк mocha -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    // включаем режим тестирования в стиле BDD
    mocha.setup('bdd');
  </script>
  <!-- добавим chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai предоставляет большое количество функций. Объявим assert глобально
    let assert = chai.assert;
  </script>
</head>
<body>
  <script>
    function pow(x, n) {
      <!-- здесь будет наша ф-ия см.ниже -->
    }
  </script>
  <!-- скрипт со спецификацией (describe, it...) -->
  <script src="test.js"></script>
  <!-- элемент с id="mocha" будет содержать результаты тестов -->
  <div id="mocha"></div>
  <!-- запускаем тесты! -->
  <script>
    mocha.run();
  </script>
</body>
</html>

# 4 теста
describe("pow", function() {
    before(() => console.log("перед всеми"));
    after(() => console.log("после всех"));
    beforeEach(() => console.log("перед каждым"));
    afterEach(() => console.log("после каждого"));
    
    it("2 в степени 3 будет 8", () => assert.equal(pow(2, 3), 8));
    it("3 в степени 3 будет 27", function() {
        assert.equal(pow(3, 3), 27);
    });
    it("для отрицательных n возвращает NaN", function() {
        assert.isNaN(pow(2, -1));
    });
    it("для дробных n возвращает NaN", function() {
        assert.isNaN(pow(2, 1.5));
    });
});

Итого пишем ф-ю:
function pow(x, n) {
    if (n < 0) return NaN;              // проверка на отриц
    if (Math.round(n) != n) return NaN; // проверка на целое
    let result = 1;
    for (let i = 0; i < n; i++) {       // само вычисление
        result *= x;
    }
    return result;
}


--- JSHInt --------------------------------------------------------------
пакет-валидатор кода для VSCode
устанавливает пакет для node js:
    sudo apt install npm
установить jshint глобально:
    sudo npm install -g jshint
создаем в дирректории файл .jshintrc и добавляем нужные настройки:
{
    "camelcase": true,
    "indent": 4,
    "undef": true,
    "quotmark": false,
    "maxlen": 80,
    "trailing": true,
    "curly": true,
    "strict": true,
    "browser": true,
    "devel": true,
    "jquery": true,
    "esversion": 8,
    "node": true
}
документация:
    https://jshint.com/docs/
все вложенные директории попадают под валидацию


--- JSON -------------------------------------------
const person = {                        // JS object
    name: 'Ivan',
    phone: '+79002341000'
}
const json = JSON.stringify(person);    // из объекта в JSON:
                                           {"name":"Ivan","phone":"+79002341000"}
                                           добавляются/заменяются двойные ковычки
const obj = JSON.parse(json);           // из JSON в объект

// глубокий клон объекта с пом JSON
const clone = JSON.parse(JSON.stringify(person));


--- AJAX -------------------------------------------
Asynchronous JavaScript and XML

const message = {                                   // сообщения о статусе
    loading: 'Загрузка',
    success: 'Успешно',
    failure: 'Что-то пошло не так'
};

1. устаревший способ
// GET
const inputField = document.querySelector('#usd');
const outputField = document.querySelector('#rub');
inputField.addEventListener('input', () => {
    const request = new XMLHttpRequest();           // объект
    //        method, url, async(true), login, pass // параметры
    request.open('GET', 'js/example.json');         // настройки запроса
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    request.send();                                 // запрос(в POST передаем в параметры)
    request.addEventListener('load', () => {        // как придет какой-то ответ
        if(request.status === 200) {
            console.log(request.response);
            const data = JSON.parse(request.response);
            outputField.value = (inputField.value / data.curren.usd).toFixed(2);
        } else {
            console.log(request.response);
            outputField.value = 'unknown';
        }
    });
});
// POST
function postData(form) {
    form.addEventListener('submit', (e) => {
        e.preventDefault();                         // сброс поведения по умолчанию

        // блок для сообщений о статусе
        const status = document.createElement('div');
        status.classList.add('status');
        status.textContent = message.loading;       // статус
        form.append(status);

        const request = new XMLHttpRequest();
        request.open('POST', 'server/');            // POST

        const formData = new FormData(form);        // спец объект формы(устар) заголовки не треб

         // FormData to JSON
        request.setRequestHeader('Content-type', 'application/json');
        const obj = {};
        formData.forEach((value, key) => obj[key] = value);
        const json = JSON.stringify(obj);

        // request.send(formData);                  // отправить FormData
        request.send(json);                         // отправить JSON
        request.addEventListener('load', () => {
            if(request.status === 200) {
                console.log(request.response);
                status.textContent = message.success;
                form.reset();                       // очистка формы
                setTimeout(() => status.remove(), 2000);    // удалить div
            } else {
                console.log(request.response);
                status.textContent = message.failure;
            }
        });
    });
}
