// JavaScript
--- Стандарты ---
    В новый стандартах добавляются полезные фишки
    ECMAScript 2009 - ES5
    ECMAScript 2015 - ES6
    "use strict";   // использовать в нач документа - означает соотв-е ES6+

--- Комментарии ---
    // comment
    /*
        multiline comment
    */

--- Литералы ---
    10          // целое 
    3.14        // дробное
    'dom'       // строки
    "dom"       // строки
    [1,2]       // массив
    {name:'X'}  // объект
    (ab|bc)     // рег выражение

--- Константы и переменные ---
    const MAX_VALUE = 200;      // константа(в верх регистре)
    const minValue = arr[0];    // вычисляемая константа(в ниж регистре)
    let arr = [HTML','CSS'];    // переменная, обычное поведение(C++, Python)
    var section;                // переменная, по старым стандартам(устар.)

--- Операторы ---
    + - * / % ** ++ --          // arithmetic
    = += -= *= /= %= **=        // assignment
    == === != !== > < >= <= ?   // ==(типы приводятся) ===(не приводятся)
    && || !                     // logical
    & | ~ ^ << >> >>>           // bit
    typeof()                    // type
    instanceof()                // instance of Array
    in                          // вхождение
    arr['HTML']                 // по ключу
    arr.HTML                    // через точку

--- Типы ------------------------------------------------------------------
    typeof()    // look a type of variable
    Number      // 0, -2, 3.14, 123e5, 12e-2
    BigInt      // const i = 12345678901234567890n; числа неогр длины
    String      // 'hello' "world" `fuck ${name}`
    Object      // {firstName:"John", lastName:"Doe"}, [1,2,3,4]
    bollean     // true, false
    undefined   // let car; не определенная переменная
    null        // спец объект обозначает 'ничего'
    NaN         // вычислительная ошибка - люб мат операц с NaN это NaN
    Infinity    // +infinity
    -Infinity   // -infinity
    Symbol      // symbol - уник идентиф в объектах
    function    // function

    динамическая типизация - у переменых нет типа
    1 перемнной может быть присвоен различный тип данных по ходу кода

    typeof x или typeof(x) - возвращ строковое знач типа данных

Приведение типов:
    String(78)  // '58'
    Number('9') // 9
    +"10"       // 10
    Number('J') // NaN
    Boolean(9)  // true

Автоприведение типов
    "7" + 8     // "78" если в сложении учавствует хоть 1 строка - рез-т строка
    8 + "7"     // "87"
    8/"2"*2     // 2 во всех других арифм операциях приводится к Number

Численное преобразование:
    undefined   -> NaN
    null        -> 0
    true        -> 1
    false       -> 0
    ""          -> 0
    " 123\n"    -> 123 происходит изначально trim
    " sdf"      -> NaN

Логическое преобразование:
    0, "", undefined, NaN   - false
    все остальное           - true

--- Взаимодействие: alert, prompt, confirm ---------------------------------
// перекрывают взаимодействие со страницей, пока не будет что-то нажато.
alert("Hello");             // окно с сообщ и кнопкой, ждет пока наж ОК
res = prompt('text', '1');  // окно с сообщ и полем ввода и кнопками ок 
                               отмена, второй парам не обяз - возвращается
                               если пользователь ничего не ввел и нажал ОК
                               если отмена - возврат null
result = confirm(question); // ok - true, отмена - false

--- Функции ---------------------------------------------------------------
    let b = 12;             // глобальная переменная - видно внутри функций
                               также их можно менять в функциях
    function foo() {        // объявление функции (видна до и после объявления)    
        let a = 5;          // видно только в функции
        return true;        // обычная функция
    }

    let foo = function() {  // функциональное выражение (видна посе объявления)
        return true;        // можно исп неименованную (типа lambda Python)
    };                      // в конце выражения ;
    
    let foo = () => true;   // стрелочная функция, аналог той что выше
    let foo = (a,b) => a+b; // пример вычисления суммы, для многострочных при-
                               меняются {}, но возврат через return
    let foo = new Function('a', 'b', 'return a+b;');    // функция "на лету"
                                                           не раб в замыканиях
    foo();                  // вызов функции(указателя/ссылки)

    Функции не возращающие значения - не явно возвращают undefined
    return;                         - не явно возвращается undefined

Параметры ф-ии:
    function sum(a, b=100, ...args)     // a, b - позиц парам, b - имеет знач
                                           по умолч. ...args - массив осталь-
                                           ных арг-ов, может быть пустым
    sum(20,30);     // норм a=20, b=100
    sum(20);        // норм a=20, b=100(default)
    sum(20,30,40);  // норм a=20, b=100, args = [40,]
    sum();          // error - отсутствует обяз аргумент а


Замыкания:
    function createCounter() {      // внеш ф-я
        let count = 0;
 
        return function() {         // внутр ф-я
            return count++;         // ссылка на перем во внеш зоне вид-ти
        };
    }
 
    let counter = createCounter();  // тут ссылка на анонимную ф-ию, которая
    console.log( counter() );          ссылается на переменную в внеш области
                                       видимости 'count' - это замыкание.
                                       пока существует ссылка counter, область
                                       вид-сти createCounter будет жить.

Функция setTimeout:
    отложенный вызов - вызывается параллельно, не зависит от расположения
                             ф-ия|выр   задерж мс  аргументы ф-ии
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
    clearTimeout(timerId)   // остановка вызова setTimeout
    setTimeout("alert('Привет')", 1000);        // можно исп строки с выраж-м
    setTimeout(() => alert('Привет'), 1000);    // или стрелочные

Функция setInterval:
    let idClock = setInterval(foo, 1000);   // вызыв-ся циклич-ки через 1с
    clearInterval(idClock)                  // остановка

Встроенные атрибуты ф-ий:
    function foo(msg) {
        console.log(msg);
    }
    foo.name    # имя ф-ии
    foo.bar = 0 # добавить свой аттр
    foo.call    # позвол вызв ф-ии с указ их контекста (context,arg1,arg2,...)
    foo.apply   # позвол вызв ф-ии с указ их контекста (context, args) массив


--- Objects ----------------------------------------------------------------
    {ключ: значение} // ключи - это строки, значения - любые объекты 
    newKey = 'gender';
    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        [newKey]: male, // с пом переменной
        fullName: function () {     // this - то есть поля этого объекта
            return this.firstName + " " + this.lastName;
        }
        getId() { return this.id; }     // ES6
    };
    person.firstNsme    // обращение к полю. 
    person['firstName'] // аналогично
    person.salary = 100 // изм знач атр, либо создание атр, если такого нет.
    delete person.salary // удалить атрибут 
    "salary" in person  // проверка на вхождение ключа 
    person.salary === undefined // та же проверка на вхождение 
    
    let car = createCar("toyota", "black");

function createCar(model, color) {
    return {
       model: model,
       color: color
    };
}

function Book(title, author) {      // ф-ция конструктор
    // this = {};  (неявно)
    this.title = title;
    this.author = author;
    this.price = 10;
    // return this;  (неявно)
}
let book = new Book("Муму", "Тургенев");

    

--- Insert to .html ---
    External: (лучшее местo длы вставки в конце body, чтобы страница прогруз)
    <script src="myScript1.js"></script>    // ссылки на скрипты в коце <body>
    Если скрипт не может загрузится работает <noscript>:
    <noscript>Sorry, your browser does not support JavaScript!</noscript>

--- Output ---
    innerHTML           // вывод на странице: 
                          document.getElementById("demo").innerHTML = 5 + 6;
                          этот метод подходит как для кнопок так и на загрузке
    document.write()    // document.write(5 + 6); вывод на странице(на загрузке)
    window.alert()      // всплывающее сообщение браузера
    console.log()       // консоль
    window.print()      // распечатать
--- Input ---
    var inpt = prompt ("enter the name") // типа alert() сохр строку в перем.

--- Events ---
    <element event="some JavaScript">    
    Event 	       |  Description
    ---------------+----------------------------------------------------
    onchange 	   | An HTML element has been changed
    onclick 	   | The user clicks an HTML element
    onmouseover    | The user moves the mouse over an HTML element
    onmouseout 	   | The user moves the mouse away from an HTML element
    onkeydown 	   | The user pushes a keyboard key
    onload 	       | The browser has finished loading the page

--- Strings ---------------------------------------------------------------
escape sequences:
    \n \t \v \b \f \r
methods:
    lenth           // lenth
    slice(7, 13)    // slice
    substring()     // slice - cannot accept negative indexes
    substr(7,6)     // 2 par - specifies the length of the extracted part
    replace()       // replase
    toUpperCase()   // to Upper
    toLowerCase()   // to Lower
    trim()          // removes whitespace from both sides of a string
    text.split(",") // Split on commas
format:
    'Welcome $(firstname)'
    `Total: ${(price * (1 + VAT)).toFixed(2)}`
    `<h2>${header}</h2><ul>` += `<li>${x}</li>`
search:    
    String.indexOf()        // position of the first occurrence
    String.lastIndexOf()    // last occurrence of a specified text
    String.search()         // eturns the position of the match
    String.match(regexp)    // returns the matches by regular expression
    String.includes()       // returns true if a string contains a value
    String.startsWith()     // true if a string begins with a value
    String.endsWith()       // true if a string ends with a specified value

--- Numbers --------------------------------------------------------
    let x = 3.14;       // A number with decimals
    let y = 3;          // A number without decimals 
    let x = 123e5;      // 12300000
    let y = 123e-5;     // 0.00123 
    let x = 10/"App";   // x will be NaN (Not a Number)
    isNaN(x);           // checking for NaN
    let x =  2 / 0;     // x will be Infinity
    let x = 0xFF;       // x will be 255
    x.toString();       // to string
    let x = 9.656;
    x.toFixed(2);       // returns a string, with the number(2) '9.66'
    2**2                // вторая степень
    2**(1/2)            // квадратный корень

--- Arrays ----------------------------------------------------------------
    const cars = ["Saab", "Volvo", "BMW"];
    const fruits = ["Banana", "Orange", "Apple", "Mango"];
    const points = [40, 100, 1, 5, 25, 10];
    cars[0] = "Opel";
    points[points.length-1] // 10 
    cars.toString();    // return string "Saab,Volvo,BMW"
    cars.join(" * ");   // return string "Saab * Volvo * BMW"
    fruits.pop();       // removes the last element from an array
    fruits.push("Kiwi");// adds a new element to an array (at the end)
    fruits.shift();     // removes the first array el and "shifts" all
    fruits.unshift("L");// dds a new element to an array (at the beginning)
    fruits.sort();      // Sorts the elements of fruits 
    fruits.reverse();   // reverse the order of the elements
    points.sort(function(a, b){return a - b}); // сортировка числовая
    points.sort(function(a, b){return 0.5 - Math.random()});    // random sort
    function myArrayMax(arr){return Math.max.apply(null, arr);} // max
    Math.max(1, 2, 3)   // the same as above
    const cars = [
        {type:"Volvo", year:2016},
        {type:"Saab", year:2001},
        {type:"BMW", year:2010}];
    cars.sort(function(a, b){return a.year - b.year});  // sort object
    let txt = "";
    numbers.forEach(myFunction);
    function myFunction(value, index, array) {
        txt += value + "<br>";
    }
Распаковка массива:
    let items = [1,2,3];        // массив
    let max = max(...items);    // передать в функцию распакованным
    let com = [...item,...arr]; // соединить массивы, можно комбинировать с 
                                   отдельными знач, в любом порявке
    let letters = [..."Hello"]; // распаковка строки на символы

--- Циклы(loops) ---------------------------
    while (true) {              // while
        break;
    }

    for (var i=0; i<10; i++) {  // for
        continue;
    }

    do {                        // do while
        continue;
    } while (!false);
    
    for(let key in book) {      // foreach для объектов
        console.log(key+": "+book[key]);
    }

    outer: for (let i = 0; i < 3; i++) {    // можно исп метки

--- Условные операторы ----------------------------------------
    if (true) {                 // if
        var x = true;
    } else if (false) {         // else if (elif)
        var x = 2;
    } else {                    // else
        var x = 'hui';          
    }

    switch (num) {              // switch (тип важен идет ===)
        case 1: console.log("item = 1");break;
        case 2: // группировка с 3-м
        case 3: console.log("item = 2");break;
        default: console.log("her");
    }

    тернарный опрератор
    let result = условие ? значение1 : значение2;
    let old = age > 50 ? "oldman" : "young";

    Оператор нулевого слияния (??):
    result = a ?? b;    // проверка на null и undefined
    result = (a !== null && a !== undefined) ? a : b; 
    example:
    let firstName = null;
    let lastName = null;
    let nickName = "Суперкодер";
    // показывает первое значение, которое определено:
    alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
    // будет height=100, если переменная height равна null или undefined
    height = height ?? 100;

--- Math ---
random()    // 0 - 0.9999999...
floor()     // усечение дробной части

--- Debugger ------------------------------------
F12 - открыть devtools
F8  - выполнить до сл брейкпоинта
F9  - шаг - заходит внутрь ф-й
F10 - шаг поверх, не заходит внутрь
F11 - шаг как F9 + асинхронные
Shift+F11 - если случ зашли внуть - на конец ф-ии

если в скрипте написать 
debugger;   // остановка скрипта при открытом devtools


--- DOM - Document Object Model --------------------------------------------
           Window
    /         |         \
DOM         BOM         JavaScript
document    navigator   Object
            location    Array
            history     Function

Window - глобальная переменная - окно браузера со своими методами
BOM - доп объекты браузера для работы со всем кроме документа
DOM - все содержимое страницы в виде объектов, кот можно менять

document - объект который управляет DOM
const bodyElement = document.body   # элементы верхнего уровня это свойства

--- Навигация по узлам/элементам
bodyElement.firstChild      # первый дочерний элемент <body>
bodyElement.lastChild       # последний дочерний элемент <body>
bodyElement.previousSibling # предыдущ эл той же грубины вложенности
bodyElement.nextSibling     # следущ эл той же грубины вложенности
bodyElement.parentNode      # родительский элемент

Навигация по элементам(тэгам)
bodyElem.firtElementChild   # первый дочерний элемент <body>
bodyElem.lastElementChild   # последний дочерний элемент <body>
bodyElem.previousElementSibling # предыдущ эл той же грубины вложенности
bodyElem.nextElementSibling # следущ эл той же грубины вложенности
bodyElem.parentElement      # родительский элемент

Если при навигации нет узла/элемента - получим null

Коллекции
bodyElement.childNodes      # все дочерние узлы - элементы + комменты,
                              какой-то текст между тэгами, в общем все узлы
bodyElement.children        # все элементы(тэги)(и только)
bodyElement.hasChildNodes() # -> boolean, есть ли доч элем
bodyElement[0]              # обращение по индексу

# перебор коллекции
for (let node of childNodes) {
    console.log(node)
}
icons.forEach(element => {  # foreach
    console.log(element);
});

При изменении дерева DOM элементы коллекции автоматом меняют тек состояние
Менять сами элементы в коллекции можно только особым способом.

--- Поиск произвольных элементов по селектору, возврат Коллекция NodeList:
Ко всем полученным объектам из поиска можно применить св-ва навигации.
querySelectorAll    - возвращает статич коллекцию(сохр на момент создания)
getElementsBy       - коллекция меняется динамически всегда

document.querySelectorAll('.itm');      # по классу
document.getElementsByClassName('itm'); # аналогично по классу(без точки)
document.querySelectorAll('img');       # по тегу
document.getElementsByTagName('img');   # аналогично по тэгу
document.querySelectorAll('img.hu');    # по тегу с классом
document.querySelectorAll('.dui, .bui');# элементы нескольких классов
document.querySelectorAll('.dui .bui'); # элем класса .bui только в эл .hui
document.querySelectorAll('.item>li');  # 1 ур влож, у элементов класса .item
                                          ищутся на 1 ур вложенности тэги li
Поиск по id -> возврат 1 элем:
document.querySelector('#item');        # 1 элем по id
document.getElementById('item');        # 1 эл, поиск только c пом document

Поиск по аттрибуту:
document.querySelectorAll('[value]');   # элементы с аттриб value
document.getElementsByName('value');    # аналогично по имени аттриб
document.querySelectorAll('[val="0"]'); # элем с аттрибутом и значением

Искать можно на любом объекте не только document
document.querySelectorAll('#item').querySelectorAll('img');

Первый попавшийся элемент из коллекции:
document.querySelectorAll('.item')[0];  # 1-ый элем
document.querySelector('.item');        # идентично

Первый/ближайший предок:
elem.closest('.item');                  # ближайший предок или null

метод поиска           | ищет по      | возвращает| поиск внутри эл| Динамич
-----------------------+--------------+-----------+----------------+--------
querySelector           any CSS-селек  1 объект    +                -
querySelectorAll        any CSS-селек  коллккция   +                -
getElementById          id             1 объект    -                -   
getElementsByTagName    тэг или *      коллккция   +                +
getElementsByClassName  имя класса     коллккция   +                +
getElementsByName       name           коллккция   -                +

Проверка на соответствие объекта(можно исп в if)
elem.matches('[class$="about__item_active"]')   # -> boolean

--- Изменение элементов
const mainText = document.querySelector('.training__text');  # найдем элем
const elementIText = mainText.innerHTML;                     # сохр текст
mainText.innerHTML =
    `<p>${elementIText}</p>                                  # вставим текст
    <p><span class="yellow">FUUUUCK!!!</span></p>`;          # что-то допише

const elementOText = mainText.outerHTML;    # весь объект в текстовой форме
mainText.outerHTML = `<p>Deleted</p>`       # перезаписать весь объект
console.log(mainText.outerHTML);            # старый текст можно снова получ

const elementText = mainText.textContent;   # только текст
mainText.textContent = `<p>hui</p>`         # строка, автоэкранирование тэг

const getComment = mainText.nextSibling;    # получаем комент
console.log(getComment);                    # получ комент или текст вне тэг
console.log(getComment.data);               # текст комент
getComment.data = "fuck!";                  # изменить текст комента

--- Создание элементов
const newElement = document.createElement('div');   # создать div
newElement.innerHTML = `Hello`;                     # наполним содержимое
const newText = document.createTextNode("Fuck u!"); # создать узел, текст

--- Вставка созданных элементов(или сырого текста) тэги преобр в строки
mainText.before(newElement);                # вставить до элемента
mainText.after(newText);                    # вставить после элемента
mainText.prepend(newText);                  # внутрь в начало содержимого
mainText.append(newText);                   # внутрь в конец содержимого
mainText.append(newText, "some text");      # можно вставлять много объек

    <!-- before -->                 <!-- beforebegin -->
    <ul class="lesson__list">       <ul class="lesson__list">
        <!-- prepend -->                <!-- afterbegin -->
        <li>1</li>                      <li>1</li>
        <li>2</li>                      <li>2</li>
        <li>3</li>                      <li>3</li>
        <!-- append -->                 <!-- beforeend -->
    </ul>                           </ul>
    <!-- after -->                  <!-- afterend -->

--- Вставка html тэгов
1-ый прам куда, 2-й парам что вставляем(тэги/строки)
mainText.insertAdjacentHTML(`beforebegin`,`<p>text</p>`);   # перед объектом
mainText.insertAdjacentHTML(`afterbegin`,`<p>text</p>`);    # внутрь объекта перед содержимым
mainText.insertAdjacentHTML(`beforeend`,`<p>text</p>`);     # внутрь объекта после содержим
mainText.insertAdjacentHTML(`afterend`,`<p>text</p>`);      # после объекта

insertAdjacentText(`afterend`,`<p>...</p>`);    # вставляет текст как есть безетэгов
insertAdjacentElement(`afterend`, newElement);  # вставляет элемент(допустим новый)

--- Перенос/перемещение элемента
// находим элементы
const trainingHeader = document.querySelector('.training__header');
const trainingRow = document.querySelector('.training__row');
// перемещаем
trainingHeader.before(trainingRow);

--- Копия/Клон объекта
const cloneHeader = trainingHeader.cloneNode();         // копия верх ур
const cloneHeaderDeep = trainingHeader.cloneNode(true); // глубокая копия 

--- Удалить объект
cloneHeaderDeep.remove();   // удалить

--- Управление классами(лучший способ манипуляции компонентами)
classNameElem.className;                // классы - string
classNameElem.className = 'item__loh';  // перезаписать все классы на новы[й|e]
// более удобный инструмент
classNameElem.classList;                // классы в спец объекте(итерируемый)
classNameElem.classList.add('new-cls'); // добавить класс
classNameElem.classList.remove('cls');  // удалить класс
classNameElem.classList.toggle('cls');  // доб класс если его нет, если есть - удалить
classNameElem.classList.contains('cl'); // проверка на наличие - true/false

--- Стили
Изменить стили
element.style.color = "red";            // добавить стиль
Для стилей из нескольких слов используется camel case:
element.style.fontSize = "24px";        // для font-size
element.style.color = "";               // сбросить свойство
element.style.cssText = `               // сразу несколько стилей
    margin-bottom: 30px;
    color:red;
`;
Получить текущие значения стилей(чисто чтение)
getComputedStyle(element)               // вытащить все стили
getComputedStyle(element).fontFamily;   // вытащить семейство шрифта
getComputedStyle(element, "::after");   // вытащить стиль псевдоэлемента

--- Атрибуты и свойства
У разных дом элементов могут быть различные свойства и элементы
тэг <a>     - свойства связанные со ссылками ...
<input>     - свойства связанные с полем ввода ...
Аттрибуты   - парсятся браузером и создаются свойства на основе их
dir(link);  - получить список всех доступных свойств элемента
const link = document.querySelector('.lesson__link');  
const input = document.querySelector('.lesson__input');
console.log(link.href);     // http://www...
console.log(input.href);    // undefined - нет такого свойства
input.href = 'www.jshuihiu' // установить нов значение аттриб
link.hidden = true;         // скрыть объект с пом свойства
// Работа с нестандартными аттрибутами
element.hasAttribute('name');           // наличие аттрибута
element.getAttribute('name');           // значение аттрибута
element.setAttribute('name', 'value');  // установить аттрибут + значение
element.removeAttribute('name');        // удалить ат трибут
element.dataset;            // все аттрибуты нач-ся на data-
element.dataset.size = "1"; // изменить аттрибут data-size
element.dataset.fontSize;   // lower camel case для data-font-size

--- Размеры окна браузера
const elem = document.documentElement;  // весь документ html
element.clientWidth;                    // ширина окна до полосы прокрутки
element.clientHeight;                   // высота окна
window.innerWidth;                      // ширина вместе с полосами прокр
window.innerHeight;                     // высота

// макс ширина и высота документа включая прокрученную часть вычислить
let scrollWidth = Math.max(
    document.body.scrollWidth, document.documentElement.scrollWidth,
    document.body.offsetWidth, document.documentElement.offsetWidth,
    document.body.clientWidth, document.documentElement.clientWidth,
);
let scrollHeight = Math.max(
    document.body.scrollHeight, document.documentElement.scrollHeight,
    document.body.offsetHeight, document.documentElement.offsetHeight,
    document.body.clientHeight, document.documentElement.clientHeight,
);

--- Управление прокруткой страницы
// получить кол-во прокрученных пикселей, только для чтения
window.pageYOffset;     // top прокруч пиксели сверху
window.pageXOffset;     // left прокруч пиксели слева

function setScroll() {          // своя функция, привяз к событию
    window.scrollBy(0, 50);     // прокрутить на (x, y)
    window.scrollTo(0,100);     // прокрутить к (x, y)
}

function setScroll() {          // своя функция, привяз к событию
    window.scrollTo({
        top: 50,
        left: 0,
        behavior: "smooth"      // плавно, instant - жестко
    });                         // прокрутить к (x, y) с опциями
}

// прокрутка до какого-либо элемента
function setScrollIntoView(top) {   // top - true/false
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView(top);    // true - элемент окажется вверху стр
}
function setScrollIntoViewOption(top) { // с опциями
    const elem = document.querySelector('.training__text');
    elem.setScrollIntoView({
        block: "center",    // start end nearest 
        inline: "nearest",  // center start end
        behavior: "smooth"  // auto
    });
}
// запретить прокрутку
function setDisableEnableScroll {
    document.body.style.overflow = "hidden";        // жестко лочим или
    document.body.classList.toggle('scroll-lock');  // в CSS лочим/разлочим
}

--- Метрики элементов на странице
const block = document.querySelector('.someblock'); // берем элемент
block.offsetParent;     // род элемент относ кот выполнено позиционирование
block.offsetLeft;       // положение по гориз относительно родителя
block.offsetTop;        // положение по вертик относительно родителя
