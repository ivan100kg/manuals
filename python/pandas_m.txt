Pandas это высокоуровневая Python библиотека для анализа данных,
    построена она поверх более низкоуровневой библиотеки NumPy
    Pannel data - Pandas - таблицы данных

import pandas as pd # принятое соглашение

DataFrame # таблица с данными в pandas - 'df'
Series    # колонка в таблице DataFrame

pd.DataFrame----------------------------------------------------------------
Объект DataFrame представляет табличную структуру данных, состоящую из
упорядоченной коллекции столбцов, причем типы значений (числовой,
строко-вый, булев и т. д.) в разных столбцах могут различаться. 
В объекте DataFrame хранятся два индекса: по строкам и по столбцам. 
Можно считать, что это словарь объектов Series.

# Создание
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],  
        'year': [2000, 2001, 2002, 2001, 2002],  
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9]} 
df = DataFrame(data) # индекс генер автом-ки, порядок колонок - рандом
                     # ключи - имена колонок, значения - данные(строки)
DataFrame(data, columns=['year', 'state', 'pop']) # строгое расположение
df = pd.read_csv("models.csv") # из csv
# from SQL database
pd.read_sql("SELECT * FROM `models` ORDER BY `id`", connection, index_col='id')

# Информация и структура таблицы
df.info()     # информация о таблице
df.describe() # обзор всех числовых данных без текстовых
df.index      # индексы строк - объект pd.Index
df.index.name # имя колонки с индексами
df.columns    # названия колонок - объект pd.Index
df.values     # двумерный массив numpy - все значения
df.dtypes     # типы в колонках таблицы
df.shape      # размерность
df.ndim       # количество осей
df.count()    # количество не NaN в колонках

# Столбцы извлечение
df['size']                  # объект Series, индексы как у df, имя size
df[['size', 'country']]     # 2 столбца - объект DataFrame
df[df['size'] > 6.0]        # строки где 'size' > 6
df['size'] > 6.0            # булев мaссив где > 6(True) - Series
df[df['size'].isin([3, 4])] # вхождение - строки с size=3 or size=4
df['size'].isin([3, 4])]    # булев массив
df[df['size'].notna()]      # пропуск NaN(None) значений
# несколько условий
df[(df['size']==6.0) & (df['country']=='Russia')] # И
df[(df['size']==6.0) | (df['country']=='Russia')] # ИЛИ
df[['name','birthday']][(df['birthday']>'1982-12-31')  #
                      & (df['birthday']<'1984-01-01')] 
    
# Строки извлечение
df.iloc[1]        # строка с порядковым номером 1
df.loc['a']       # то же самое, но не по порядк номеру, а по значению индекса
df.iloc[0:5, 2:4] # срезы строки[от:до], колонки[от:до]
df.loc[df['size']==4, 'name'] # строки до запятой, колонкa указ после запятой
df.loc[df['size']==4, ('name', 'country')] # неск колонок объед в кортеж
df.head(5)        # первые пять строк
df.tail(6)        # последние 6 строк

# Добавление, изменение, удаление колонок
df['new'] = x                           # добавить колонку(скаляр, массив..)
df.rename(columns={"A": "a", "B": "c"}) # изменить имена колонок
df.rename(index={0: "x", 1: "y"})       # изменить индексы(наз-я строк)
del df['new']                           # удаление столбца

# статистика
df['size'].mean()   # среднее арифметическое значение по колонке 9,1,2 = 4
df['size'].median() # среднее значение после сортировки 9,1,2 = 2
f.agg({'size':["min", "max", "median", "mean"],      # в стиле describe()
       'pictures':["min", "max", "median", "mean"]})

# группировка/групповая статистика
df.groupby('size').mean() # группировка по размеру, среднее для всех колонок
df.groupby(['country','size_ru'])['size_ru'].count() # группировка по 2-м кол
df[['country','size_ru']].groupby('country').mean()  # средний размер по странам
df.groupby('country')[['country','size_ru']].mean()  # тот же эффект
df.groupby("country")['country'].count() # количество стран
df["size_ru"].value_counts()             # тот же эффект

# сортировка
df.sort_values(by='birthday', ascending=False) # по дате рождения с конца
df.sort_values(by=['size','birthday'])         # по 2-м столбцам
df.sort_index(ascending=False)                 # сортировка по индексу в обр пор


# SQL - pandas
# SELECT---------------------+------------------------------------------------
SELECT name, size            | df[['name','size']].head(5)
FROM models                  |
LIMIT 5;                     |
# AS-------------------------+------------------------------------------------
SELECT *, size+29 as size_ru | df.assign(size_ru=df["size"]+29).head(5)
from models                  |
LIMIT 5;                     |
# WHERE----------------------+------------------------------------------------
SELECT *                     | df[(df['birthd'] == '2000-01-01') &
FROM models                  |    (df['size'] < 6)]
WHERE 'birthd' = '2000-01-01'| (AND = &) (OR = |) (IS NULL = .isna()) 
AND 'size' < 6;              | (IS NOT NULL = .not.na())
# ORDER BY-------------------+------------------------------------------------
SELECT name, size            | df[(df['size'] < 6) & (df['country']=='Russia')]
FROM models                  | [['name','size']].sort_values(by=['size','name'],
WHERE size < 6               | ascending=False)
AND country='Russia'         |
ORDER BY size, name DESC;    |
# GROUP BY-------------------+--------------------------------------------------
SELECT size, count(*)        | df.groupby('size')['size'].count()
FROM models                  | df.groupby('size').size()
GROUP BY 'size';             | 
SELECT COUNT(*), AVG(size)   | df.groupby("country").agg({"name": np.size,
FROM models                  |                            "size": np.mean})
GROUP BY country;            |
# JOIN ----------------------+--------------------------------------------------



Методы и свойсва индексных объектов
    append Конкатенирует с дополнительными индексными объектами, порождая новый объект Index 
    diff Вычисляет теоретико-множественную разность, представляя ее в виде индексного объекта 
    intersection Вычисляет теоретико-множественное пересечение 
    union Вычисляет теоретико-множественное объединение 
    isin Вычисляет булев массив, показывающий, содержится ли каждое значение индекса в переданной коллекции 
    delete Вычисляет новый индексный объект, получающийся после удаления элемента с индексом i 
    drop Вычисляет новый индексный объект, получающийся после удаления переданных значений 
    insert Вычисляет новый индексный объект, получающийся после вставки элемента в позицию с индексом i 
    is_monotonic Возвращает True, если каждый элемент больше или равен предыдущему 
    is_unique Возвращает True, если в индексе нет повторяющихся значений unique Вычисляет массив уникальных значений в индексе
===============================================================================
Базовая функциональность

Переиндексация
    reindex() - создание объектов согласно новому индексу
    obj.reindex(['a', 'b', 'c'], fill_value=0) - заполнить NaN нулями
    obj.reindex(range(6), method='ffill') - заполняет NaN предыдущ знач-ми
        method='ffill' или pad - заполнить NaN предыдущ знач
        method='bfill' или backfill - заполнить NaN в обратном направлении
    reindex(index=[], columns=[]) - в случае с DataFrame
    Аргументы reindex:
        index Последовательность, которая должна стать новым индексом. Может
            быть экземпляром Index или любой другой структурой данных Python,
            похожей на последовательность. Экземпляр Index будет использован
            «как есть», без копирования
        method Метод интерполяции (восполнения), ffill bfill
        fill_value Значение, которой должно подставляться вместо отсутствующих
            значений, появляющихся в результате переиндексации
        limit При прямом или обратном восполнении максимальная длина
            восполняемой лакуны
        level Сопоставить с простым объектом Index на указанном уровне
            MultiIndex, иначе выбрать подмножество
        copy Не копировать данные, если новый индекс эквивалентен старому. По
            умолчанию True (т. е. всегда копировать данные)
=================================================================================
Удаление элементов из оси (нов объект)
    new_obj = obj.drop('c')  - удаление строк
    data.drop('two', axis=1) - удаление столбцов в DataFrame


    
==================================================================================
Арифмитические операции
    obj1 + obj2 -складываются элементы, которые совпадают в обоих объектах,
        если нет то NaN                                                    
        df1.add(df2, fill_value=0) сложение, отсутствующие 
            будут нулями        
        add Сложение (+)
        sub Вычитание (-)                                                 
        div Деление (/)                                                    
        mul Умножение (*)

Укладывание. Операции между сериес и датафрейм.
    пример с массивом np
    arr [[1,2],  arr - arr[0]:  [[0,0],
         [3,4]]                  [2,2]]
         строка вычитается из всех строк маассива
    Укладывание строк с DataFrame-Series
    df       a b  ser=df.ix[0] a 1        df-ser:      a b
        Utah 1 2               b 2                Utah 0 0
        Ohio 3 4               Name: Utah         Ohio 2 2
        по умолчанию индекс сериес сопостав со столбцами дф, укладываются
            строки.
    Укладывание столбцов
    df       a b  ser=df['a']  Utah 1    df.sub(ser, axis=0):     a b
        Utah 1 2               Ohio 3                        Utah 0 1 
        Ohio 3 4               Name: a                       Ohio 0 1
        вычитание выполняем с пом метода, ось - вдоль которой производится
            сопоставление индексов.

Применение функций отображение
    np.sqrt(frame)  применение как в нумпай
    apply(f) функция которая применяется для каждой строки или каждого
        столбца. f - функция def или lambda определяемая программистом.
    f = lambda x: x.max()-x.min() какая то ф-ия, х в данном случае одно
        мерный массив- строка или столбец
    frame.apply(f) - для столбцов
    frame.apply(f, axis=1) - для строк
    applymap(f) - для всех элементов. map(f) метод Series.
================================================================================
Сортировка.
    ser.sort_index() - сортировка по индексу
    df.sort_index() df.sort_index(axis=1) сортировка по индексу по осям
    ser.order() - сортировка по значению
    df.sort_index(by='state') - сортировка по значению, [,] неск. знач.
    .sort_index(ascending=false) в обратном порядке.


Ранжирование
    Присваивание рангов от 1 до числа количества элементов.
    .rank() - средний ранг элементов по отношению к их группе.
    .rank(method='first') ранги по появлению в группе
    .rank(method='first', ascending=false) наоборот
    Способы обработки связанных рангов
        'average' По умолчанию: одинаковым значениям присвоить средний ранг
        'min' Всем элементам группы присвоить минимальный ранг
        'max' Всем элементам группы присвоить максимальный ранг
        'first' Присваивать ранги в порядке появления значений в наборе данных

Одинаковые индексы
    Если индексы одинаковые то вернётся объект с этими индексами, а не чисто данные.
================================================================================
Редукция
    Это методы которые вычисляют единственное значение, типа
    Суммы или среднего, по сравнению с нумпай они игнорируют NaN.
    df.sum() суммы по столбцам
    df.sum(axis=1) сумма по строкам

Параметры методов редукции
    axis Ось, по которой производится редуцирование. В случае DataFrame 0 означает строки, 1 – столбцы.
    skipna Исключать отсутствующие значения. По умолчанию True
    level Редуцировать с группировкой по уровням, если индекс по оси иерархический (MultiIndex)

Описательные и сводные статистики
    count Количество значений, исключая отсутствующие
    describe Вычисляет набор сводных статистик для Series или для каждого столбца DataFrame
    min, max Вычисляет минимальное или максимальное значение
    argmin, argmax Вычисляет позицию в индексе (целые числа), при котором достигается минимальное или максимальное значение соответственно
    idxmin, idxmax Вычисляет значение индекса, при котором достигается минимальное или максимальное значение соответственно
    quantile Вычисляет выборочный квантиль в диапазоне от 0 до 1
    sum Сумма значений
    mean Среднее значение
    median Медиана (50%-ый квантиль)
    mad Среднее абсолютное отклонение от среднего
    var Выборочная дисперсия
    std Выборочное стандартное отклонение
    skew Асимметрия (третий момент)
    kurt Куртозис (четвертый момент)
    cumsum Нарастающая сумма
    cummin, cummax Нарастающий минимум или максимум соответственно
    cumprod Нарастающее произведение
    diff Первая арифметическая разность (полезно для временных рядов)
    pct_change Вычисляет процентное изменение
================================================================================
Корреляция и ковариация
	Некоторые сводные статистики.
    corr cow corrwith 

Уникальные значения, счётчик значений, членство
	isin Вычисляет булев массив, показывающий, содержится ли каждое
		принадлежащее Series значение в переданной последовательности 
	unique Вычисляет массив уникальных значений в Series и возвращает их в
		порядке появления 
	value_counts Возвращает объект Series, который содержит уникальное значение
		в качестве индекса и его частоту в качестве соответствующего значения.
		Отсортирован в порядке убывания частот
================================================================================
Обработка отсутствующих данных.
	Методы обработки отсутствующих данных:
	dropna Фильтрует метки оси в зависимости от того, существуют ли для метки
		отсутствующие данные, причем есть возможность указать различные пороги,
		определяющие, какое количество отсутствующих данных считать допустимым
	fillna Восполняет отсутствующие данные указанным значением или использует
		какой-нибудь метод интерполяции, например 'ffill' или 'bfill' 
	isnull Возвращает объект, содержащий булевы значения, которые показывают, 
		какие значения отсутствуют 
	notnull Логическое отрицание isnull


Фильтрация отсутствующих данных
    ser.dropna() пропуск од
    ser[data.notisnull()] аналогично
    df.dropna() убирает всю строку или столб если есть хоть 1 NaN
    df.dropna(how='all') уберет строки и столбцы где все NaN, можно конечно указать ось.
    df.dropna(trash=3) оставить некоторые строки...хз

Восполнение од
    df.fillna(0) - заполнит NaN нулями
    df.filna({0: 0.5, 1:0.7}) - заполнение по столбцам различными знач
    Аргументы метода fillna:
        value Скалярное значение или похожий на словарь объект для восполнения 
			отсутствующих значений 
        method Метод интерполяции. По умолчанию, если не задано других 
			аргументов, предполагается метод 'ffill' 
        axis Ось, по которой производится восполнение. По умолчанию axis=0 
        inplace Модифицировать исходный объект, не создавая копию 
        limit Для прямого и обратного восполнения максимальное количество 
			непрерывных заполняемых промежутков
===============================================================================

Иерархическое индексирование
    Работа с многомерными данными, приводя их к форме меньшей размерности.
    Multiindex это Index([[1,2],[3,4]])
    ser.stuck() ser.unstuck() - получаем Dataframe из Series
    С датафрем можно построить иерархический индекс по любой оси.
    Существуют уровни индексов level. 
    Имена уровней df.index.names и df.columns.names присваиваются с пом 
		списка/массива ['key1', 'key2']
    Уровни переупорядочения и сортировки
        df.swaplevel('key1', 'key2') перестановка уровней
        df.sortlevel(1) сортировка по уровню
    Сводная статистика по уровню
        df.sum(level='key2')
        df.sum(level='key2', axis=1)
    Работа со столбцами
        set_index(['c', 'd']) создаст из столбцов датафрема многоуровневый дф с 
		индексами этих столбцов.
        set_index(['c', 'd'], drop=false) оставляет эти столбцы на месте.
        reset_index() наоборот, перемещает иерархические индексы в столбцы.

===============================================================================
Чтение и запись файлов.

Текстовый формат
    read_csv Загружает данные с разделителями из файла, URL-адреса или похожего 
		на файл объекта. По умолчанию разделителем является запятая 
    read_table Загружает данные с разделителями из файла, URL-адреса или 
		похожего на файл объекта. По умолчанию разделителем является символ 
		табуляции ('\t')
    read_fwf Читает данные в формате с фиксированной шириной столбцов (без 
		разделителей) 
    read_clipboard Вариант read_table, который читает данные из буфера обмена. 
		Полезно для преобразования в таблицу данных на веб-странице
    read_csv() аналогична read_table(sep=',')
    pd.read_csv('her.csv') - имена колонок - 1 строка файлов - заголовок, 
		индексы по умолчанию.
    pd.read_csv('her.csv', header=None) - не делать заголовок из 1 строки, будут 
		имена колонок по умолчанию.
    pd.read_csv('her.csv', names=['a', 'b']) - назвать по своему
    pd.read_csv('her.csv', names=['a', 'b'], index_col='a') - сделать индексами 
		одну из колонок.
    pd.read_csv("her.csv", index_col=0, parse_dates=True) - даты в Timestamp
    Обработка файлов с различным количеством пробелов или табуляции
        pd.read_table('ch06/ex3.txt', sep='\s+')
    Если первая строка файла содержит на 1 элемент меньше чем остальные, то 
		первая колонка становится индексом.
    Пропуск строк
        pd.read_csv('ch06/ex4.csv', skiprows=[0, 2, 3])
    Обработка отсутствующих данных
        В файле могут данные в таблице вообще отсутствовать либо быть 
		помеченными маркером NA, -1.#IND и NULL, все они будут NaN.
    Аргументы функций
        path Строка, обозначающая путь в файловой системе,     URL-адрес или 
			похожий на файл объект 
        sep или delimiter Последовательность символов или регулярное выражение, 
			служащее для разделения полей в строке 
        header Номер строки, содержащей имена столбцов. По умолчанию равен 0 
			(первая строка). Если строки-заголовка нет, должен быть равен None 
        index_col Номера или имена столбцов, трактуемых как индекс строк в 
			результирующем объекте. Может быть задан один номер (имя) или список 
			номеров (имен), определяющий иерархический индекс 
        names Список имен столбцов результирующего объекта, задается, если 
			header=None 
        skiprows Количество игнорируемых начальных строк или список номеров 
			игнорируемых строк (нумерация начинается с 0) 
        na_values Последовательность значений, интерпретируемых как маркеры 
			отсутствующих данных 
        comment Один или несколько символов, начинающих комментарий, который 
			продолжается до конца строки 
        parse_dates Пытаться разобрать данные как дату и время; по умолчанию 
			False. Если равен True, то производится попытка разобрать все 
			столбцы. Можно также задать список столбцов, которые следует 
			объединить перед разбором (если, например, время и даты заданы в 
			разных столбцах) 
        keep_date_col В случае, когда для разбора данных столбцы объединяются, 
			следует ли отбрасывать объединенные столбцы. По умолчанию True
        converters Словарь, содержащий отображение номеров или имен столбцов на 
			функции. Например, {'foo': f} означает, что нужно применить функцию 
			f ко всем значением в столбце foo 
        dayfirst При разборе потенциально неоднозначных дат предполагать 
			международный формат (т. е. 7/6/2012 означает «7 июня 2012»). 
        date_parser Функция, применяемая для разбора дат nrows Количество 
			читаемых строк от начала файла 
        iterator Возвращает объект TextParser для чтения файла порциями 
        chunksize Размер порции при итерировании 
        skip_footer Сколько строк в конце файла игнорировать     
        verbose Печатать разного рода информацию о ходе разбора, например, 
			количество отсутствующих значений, помещенных в нечисловые столбцы 
        encoding Кодировка текста в случае Unicode. Например, 'utf-8' означает, 
			что текст представлен в кодировке UTF-8 
        squeeze Если в результате разбора данных оказалось, что имеется только 
			один столбец, вернуть объект Series 
        thousands Разделитель тысяч, например, ',' или '.'
    
    Чтение текстовых файлов порциями
        pd.read_csv('ch06/ex6.csv', nrows=5) -пять строк
        chunker = pd.read_csv('ch06/ex6.csv', chunksize=1000)   
        Тип chunker TextParser, позволяет читать файл порциями размера chunksize
        get_chunk - читать куски определенного размера

    Запись в файл
        data.to_csv('ch06/out.csv') запишется через запятую в файл
        data.to_csv(sys.stdout, sep='|') вывод в консоль, разделиткль|
        data.to_csv(sys.stdout, na_rep='NULL') отсутствующие значения не пустые 
			строки,а нулл.
        data.to_csv(sys.stdout, index=False, header=False) подавить запись 
			индексов строк и имён колонок
        data.to_csv(sys.stdout, index=False, cols=['a', 'b', 'c']) запись 
			определенных столбцов в нужном последовательность
==========================================================================        
Двоичные файлы
    df.save('picklefile') запись в файл
    pd.load('picklefile') чтение

Базы данных
    sqlite3 есть инфа по ней, пересмотреть и сравнить с mysql

Слияние как в бд
    pd.merge(df1, df2) слияние по ключам
    Много инфы
Конкатенация укладка или связывание
    np.concatenate([arr, arr], axis=1)
    pd.concat([ser1, ser2])
Комбинирование перекрывающихся данных
    combine_first

Устранение дубликатов
    duplicated() возвращает булев сериес и показывает есть ли дубликат
    drop_duplicates удалить дубликаты

Преобразование данных с помощью функции или отображения
    map объекта сериес принимает словарь или функцию
    data['animal'] = data['food'].map(str.lower).map(meat_to_animal) 
        преобразование данных к нижнему регистру
    data['food'].map(lambda x: meat_to_animal[x.lower()])

Замена значений
    ser.replace(-999, np.nan) замена всех значений -999 на NaN

Переименование индексов осей
    data.index.map(str.upper)
    data.rename(index=str.title, columns=str.upper)

Дискретизация и раскладывание
    pd.cut()
    labels levels
    
Обнаружение и фильтрация выбросов
    col = data[3] выберем колонку
    col[np.abs(col) > 3] найти все значения больше 3 
    data[(np.abs(data) > 3).any(1)] все колонки
    
Вычисление индикаторных переменных   
    
    


===============================================================================
df.nlargest(5, 'Open') выведет 5 самых больших показателя в колонке опен
smallest() наоборот
pd.set_option() различные опции, Макс мин колонок и столбцов, Макс знаков после запятой..
df.shape() размерность фрейма
df.describe() df.info() информация о таблице
df.mycol.value_counts()[:5] показать информациюо количестве элем в колонке mycol
df['Open'] = df['Open'].astype('float32') или np.float32 изменить тип
df.sort_values(by=['Open', 'Date']) сортировка

df['Open'].plot(kind="hist") гистограмма, если много разных значений
df.['Type Star'].value_counts().plot.pie(), если значения одинаковые но в разном количестве


pd.Series---------------------------------------------------------------------
    Series – одномерный похожий на массив объект, содержащий массив данных
    (любого типа, поддерживаемого NumPy) и ассоциированный с ним массив меток,
    который называется индексом.

создание:     
    ser = pd.Series([5, -6, 2])         # Series, метки начинаются с нуля
    ser = pd.Series([0, 1, 8],          # массив numpy/список python
                    name='cube',        # имя of Series
                    index=[3,'f',-0.1], # индексы - преобраз-ся в pd.Index
                    dtype='float64')    # тип
    ser.index  # массив индексов  - Index([2, 's', -0.1], dtype='object')
    ser.values # массив элементов - class array([0., 1., 8.])
    ser.name = 'cube' имя объекта Series

явные индексы
    ser = pd.Series([5, 6, 7], index=['a', 'b', 'c'])
    ser.index = [23, 44, 67] # изменение индексов

доступ к данным по индексам, срезам
    ser['f']            # доступ по ключу
    ser[1]              # доступ по номеру работает тоже
    ser[['a', 'b']])    # вывод определенных значений
    ser[0:-1]           # срезы по номерам
    ser["a":"c"]        # срез по меткам - последняя включается!
    ser[['a', 'b']] = 0 # групповое присваивание
    ser[ser < 2]        # различные условия

мат-е операции
    ser[ser > 0] # вывод всех больше нуля
    ser * 2      # уножене на 2 всех членов
    np.abs(ser)  # функции numpy
    ser1 + ser2  # складываются значения по меткам, если метка отсутствует
                   в одном, то общий объект будет под этой меткой NaN

NaN - не число, отсутствие данных
    pd.isnull(obj)  # ищет NaN
    pd.notnull(obj) # ищет не NaN

===============================================================================
# matplotlib - создание графиков в pandas
df.plot()       # создаются линейные графики для каждого цифрового столбца
df.plot(subplots=True) # для каждого столбца свой график
df['size'].plot()      # линейный график для определенного столбца
df.plot.scatter(x='size', y='pictures', alpha=0.2) # пересечение 2-х величин
df.plot.area    # площадь
df.plot.bar     # бары
df.plot.barh    # бары горизонтальные
df.plot.box     # 
df.plot.density # плотность
df.plot.hexbin  # соты
df.plot.hist    # гистограмма
df.plot.kde     #
df.plot.line    # по умолчанию
df.plot.pie     # пирог

Столбчатые диаграммы
    ser.plot(kind='bar', ax=axes[0], color='k', alpha=0.7) ser.plot.bar()
    df = DataFrame(np.random.rand(6, 4), index=['one', 'two', 'three', 'four', 'five', 'six'], columns=pd.Index(['A', 'B', 'C', 'D'], name='Genus'))
        df.plot(kind='bar') - names будет лэйблом, колонки - ось Х,
            значения рандома - Y, а индексы- бар колонки)
    
Гистограммы и графики плотности
    это разновидность столбчатой диаграммы, показывающая дискретизированное представление частоты. Результаты измерений распределяются по дискретным интервалам равной ширины, а на гистограмме отображается количество точек в каждом интервале
    ser.hist(bins=50) гистограмма, бины - кол-во баров ser.plot.hist()
    ser.plot(kind='kde') график плотности

Диаграммы рассеяния
    полезный способ исследования соотношения между двумя одномерными рядами данных. В пакете matplotlib есть метод scatter.
    plt.scatter(trans_data['m1'], trans_data['unemp']) 
    ser.plot.scatter(x,y)
	from pandas.plotting import scatter_matrix
    scatter_matrix(trans_data, diagonal='kde', color='k', alpha=0.3)
    ser.plot.hexbin(x,y) рассеяние сотами, полезно когда данных много

===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
