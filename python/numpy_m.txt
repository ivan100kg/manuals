Numeric Python

NumPy это open-source модуль для python, который предоставляет общие
математические и числовые операции в виде пре-скомпилированных, быстрых функций.

import numpy as np  # принятое соглашение
ndarray             # массив схожий с list но все элементы одного типа

# документация
help(np.max)        # информация по объекту
np.max?             # используется как короткая замена help в IPython
np.max??            # source code (IPython)

# Создание массивов
array()             # принимает любой объект похожий на последовательность
asaray()            # если на входе ndarray - не копирут, в отлич от array
arange()            # аналог range() возвращает массив
linspace(0, 100, 5) # разб отрезок от 0 до 100 на 5 частей включая 0 и 100
zeros((3, 2))       # 3 на 2 нулями
zeros_like()        # на вход принимает массив, на выходе массив такой же
                      размерностью и типа, но заполненный нулями
ones, like_ones     # то же что и zeros но зап-ся единицами
empty, like_empty , # то же но без иниц-ии (будет мусор)
eye, identity       # единич квадрат матрица(диаганаль - 1, остальные нули)
fromfunction(f,sh)  # f - функция, sh - форма массива

# Индексы, срезы - создается новый массив
a[-1] b[0, 0]       # индексы b[0][0] == b[0,0]
a[0:-1:1]           # срезы [from:to:step]
arr[:,::2]          # все строки, все столбцы с шагом 2
a[0] = 3            # присваивание
a[[0,2,8,9]]        # вывод определенных 
a[0:9:2]            # Извлечение элементов с определенным шагом
a[a<5]              # вывод с опред условием 
(a<5)|(a%2==0)      # можно и так замутить - булев массив
a[(a<5)&(a!=0)]     # булев массив в качестве индексов
a[b]                # целочисленный массив в качестве индексов
nonzero(a<5)        # вернет кортеж массивов с номерами индексов где условие
                      верно на каждую ось 1 массив 
a[[True,False]]     # нов массив только с true

# Типы данных
+--------------+---------+--------------------------------------------------+
|int8,  uint8  |i1, u1   |Знаковое и беззнаковое 8-разрядное(1 байт) целое  |
|int16, uint16 |i2, u2   |Знаковое и беззнаковое 16-разрядное(2 байта) целое|
|int32, uint32 |i4, u4   |Знаковое и беззнаковое 32-разрядное(4 байта) целое|
|int64, uint64 |i8, u8   |Знаковое и беззнаковое 64-разрядное(8 байт) целое |
|float16       |f2       |С плавающей точкой половинной точности            |
|float32       |f4       |Стандартный тип с плавающей точкой одинарной точ  |
|float64       |f8 или d |Стандартный тип с плавающей точкой двойной точ    |
|float128      |f16      |С плавающей точкой расширенной точности           |
|complex64,    |c8       |Комплексные                                       |
|complex128,   |c16      |                                                  |
|complex256    |c32      |                                                  |
|bool          |?        |Булев тип, способный хранить значения True и False|
|object        |O        |Тип объекта Python                                |
|string_       |S        |Тип строки фиксированной длины(1 байт на символ)  |
|unicode_      |U        |Тип Unicode-строки фиксированной длины            |
+--------------+---------+--------------------------------------------------+

# Приведение типа
# если в массиве и числа и строки - все приводится к строкам
b = a.astype(np.float64)    # такой же как а, но другой тип
z = np.uint8(a)             # такой же, но тип uint8

# Некоторые свойства
a.shape         # размерность массива (2, 3)
a.dtype         # тип переменных
a.size          # кол-во элем-ов
a.ndim          # глубина/кол-во осей массива
a.itemsize      # размер 1-го элемента в байтах
a.strides       # размер порядков в байтах, в случае двумерного
                  (размер строки, размер элем)

# Изменение формы массива
# должно быть кратно кол-ву элементов массива
a.reshape(2, 3) # преобразуем в массив 2 стр 3 столбца
a.reshape(3,-1) # -1 авто определение оси
a.flatten()     # вытянуть массив в 1, копия
a.ravel()       # вытянуть массив в 1, тот же адрес
a.T             # a.transpose(), транспонировать, поменять оси местами

# Фиктивные оси
# имеют размерность 1, нужны в некоторых случаях
a[np.newaxis, :]          # добавление фиктивной оси - строка
a[:, np.newaxis]          # добавление фиктивной оси - столбец
np.expand_dims(a, axis=0) # второй способ

# Операции между массивами и скалярами
a*2, a-4 ... a**0.5       # операции происходят поэлементно
a > 0, a <= 22 ...        # различные сравнения, на выходе булевый массив
(a == 0) | (a == 1)       # битовые операторы
a[a < 0] = 0              # замена всех отрицательных нолями
np.dot(a, b), a @ b       # векторно-матричное умножение

# Универсальные функции, быстрые поэлементные операции над массивами.
# Унарные u-функции
np.abs(a)   # абсолютное значение целых
fabs(a)     # абсолютное значение вещественных или комплексных чисел 
sqrt(a)     # квадратный корень из каждого элемента. Эквивалентно arr ** 0.5 
square(a)   # квадрат каждого элемента. Эквивалентно arr ** 2 
exp(a)      # экспоненту ex каждого элемента
log(a)      # Натуральный (по основанию e)
log10(a)    # десятичный
log2(a)     # двоичный
log1p(a)    # функция log(1 + x) 
sign(a)     # знак каждого элемента: 1 0 –1
ceil(a)     # округление до верхнего целого 
floor(а)    # округление до нижнего целого 
rint(a)     # Округлить элементы до ближайшего целого с сохранением dtype 
modf(a)     # дробные и целые части массива в виде отдельных массивов 
isnan(a)    # check for NaN (не числа) 
isinf(a)    # check for inf и NaNnp.inf
# Обычные и гиперболические тригонометрические функции и обратные
cos, cosh, sin, sinh, tan, tanh
arccos, arccosh, arcsin, arcsinh, arctan, arctanh

# Бинарные u-функции
# логические
logical_not         # -a - not x для каждого элемента. Эквивалентно -arr 
logical_and         # a & b - И
logical_or          # a | b - ИЛИ
logical_xor         # a ^ b -исключающее ИЛИ
# сравнение
greater(a,b)        # >
greater_equal(a,b)  # >=
less(a,b)           # <
less_equal(a,b)     # <=
equal(a,b)          # ==
not_equal(a,b)      # !=
# арифметические операции    
add(a,b)            # a + b 
subtract(a,b)       # a - b 
multiply(a,b)       # a * b 
divide(a,b)         # a / b
floor_divide(a,b)   # a // b 
power(a,b)          # a ** b 
mod(a,b)            # a % b 
copysign(a,b)       # знаки значений второго массива в соотв элем первого 
maximum(a,b)        # Поэлементный максимум. 
fmax(a,b)           # игнорирует значения NaN 
minimum(a,b)        # Поэлементный минимум
fmin(a,b)           # игнорирует значения NaN   

# Свои функции
lambda x, y : x[x[:,1].astype(float) > y]

# Обработка данных с приенением массивов, без циклов
meshgrid() # принимает 2 одномерных массива, порождает 2 матрицы со значенрями
             из обоих массивов, строк в первом столько сколько эл во вотором.
             Столбцов во втором - сколько эл в первом.
z = np.sqrt(ar1**2 + ar2**2)  # итерируются 3 массива с их эл-ми.

# Запись логиеских условий в виде операций с массивами
where - соответствует тернарному x if true else y
where(условие,эл1,эл2) # элементами могут быть массивы, скаляры, результат
                         будет новый массив. Массивы итерируются..

# Математические и статистические операции
sum(a)      # Сумма элементов всего массива или вдоль одной оси.
mean(a)     # Среднее арифметическое. Для массивов нулевой длины равно NaN 
std(a)      # Стандартное отклонение(среднее 0, отклонение 1(+-1))
var(a)      # дисперсия 
min(a)      # минимум
max(a)      # максимум 
argmin      # iндексы минимального
argmax      # Индексы максимального элемента 
cumsum      # Нараст сумма каждый элемент массива складывается с предыдущим 
cumprod     # Нарастающее произведение с начальным значением 1 
average     # среднее

# Методы булевых массивов
any()       # есть ли в массиве хоть 1 True
all()       # все ли True
a > 0       # массив True/False

# Сорировка
а.sort()            # сортирует на месте
np.sort(a)          # новый сортированный массив
np.flip(a)          # reverse 
np.argsort          # индексы отсортир Эл 
np.sort(arr,axis=1) # сортировка 2д массива по строкам



# Конкатенация
np.concatenate((a, b), axis=0) # конкатенация массивов
np.vstack((a,b))    # вертикальный стакинг
np.hstack((a,b))    # горизонтальный стакинг
np.row_stack        # is equivalent to vstack for any input arrays
np.column_stack     # эквивалент hstack with 2D arrays 
np.r_[1:4,0,4]      # row по одной оси 
np.c_[1:4,0,4]      # column по одной оси

# Устранение дубликатов и др теоретико-множественные оп-ии с массивами
unique(x)           # отсортированное множество уникальных элементов 
intersect1d(x, y)   # отсортированное множество элементов, общих для x и y 
union1d(x, y)       # отсортированное объединение элементов 
in1d(x, y)          # какие элементы x встречаются в y 
setdiff1d(x, y)     # элементы, принадлежащие x, но не принадлежащие y 
setxor1d(x, y)      # элементы, принадлежащие одному массиву, но не обоим сразу


# Файловый ввод-вывод массивов.
# Хранение массивов в двоичном формате на жеском диске
save('myarr', arr)  # сохранит в myarr.npy, если суффикса не было
load('myarr.npy')   # загрузка
savez('myarrs.npz', a=arr, b=arr2) # несколько массивов в зип
load('myarrs.npz')  # вернет подобие словаря, по ассоц меткам ['а'] 
                      можно обращаться к массивам.
# Сохранение и загрузка текстовых файлов
loadtxt('file.csv', delimitr=',')      # load файл .csv
savetxt('file.txt', arr, delimitr=',') # записывает в файл
savetxt('np.csv', a, fmt='%.2f', delimiter=',', header='1,2,3,4') # headers
genfromtxt(io.StringIO(data), delimiter=",") # более крутая чем loadtxt

# разделение массива на несколько малых
split(x, 3)     # делит на 3 части
hsplit()        # horiz
vsplit()        # vertic

# Копии
c = a           # ссылка, id одинаковые
c = a.copy()    # копия, разные id
c = a.view()    # неглубокая копия - данные не копируются

# Линейная алгебра np.linalg
diag  # диагональные элементы квадратной матрицы в виде одномерного массива
        или преобразует одномерный массив в квадратную матрицу, в которой все 
        элементы, кроме находящихся на главной диагонали, равны нулю
dot   # произведение матриц 
trace # след матрицы – сумму диагональных элементов 
det   # определитель матрицы 
eig   # собственные значения и собственные векторы квадратной матрицы
inv   # обратную матрицу 
pinv  # псевдообратную матрицу Мура-Пенроуза для квадратной матрицы 
qr    # QR-разложение 
svd   # сингулярное разложение (SVD) 
solve # Решает линейную систему Ax = b, где A – квадратная матрица 
lstsq # Вычисляет решение уравнения y = Xb по методу наименьших квадратов 

# Генерация случайных чисел np.random
seed        # Задает начальное значение генератора случайных чисел 
permutation # случайную перестановку последовательности или диапазона 
shuffle     # Случайным образом переставляет последовательность на месте 
rand        # Случайная выборка с равномерным распределением 
randn       # Случайная выборка с нормальным распределением со средним 0
randint     # Случайная выборка целого числа из заданного диапазона 
binomial    # Случайная выборка с биномиальным распределением 
normal      # Случайная выборка с нормальным (гауссовым) распределением 
beta        # Случайная выборка с бета-распределением 
chisquare   # Случайная выборка с распределением хи-квадрат 
gamma       # Случайная выборка с гамма-распределением 
uniform     # Случайная выборка с равном-м распред на полуинтервале [0, 1)

# рекомендуемый генератор с битовым генератором по умолчанию (PCG 64)
rng = np.random.default_rng(0)       # seed
rng.random((3,2))                    # float, random array 0-1, 3x2
rng.integers(low=0, high=10, size=3) # 3 random integers 0-10 

# Plotting arrays with Matplotlib
%matplotlib inline # рисовать графики в jupyter notebook
plt.plot(a) # построить график 1-d array, значения а - координаты н
              координаты х - индексы элементов(0,1,2...)
plt.show()  # добавить это, если работа в ком строке
x = np.linspace(0, 5, 20)  # массив под х-координаты
y = np.linspace(0, 10, 20) # массив под у-координаты
# два графика
plt.plot(x, y, 'purple')   # line, color=purple
plt.plot(x, y, 'o')        # dots
