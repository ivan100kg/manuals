# Python 3

# Иерархия python
    Программа < модули < операторы < выражения < объекты

# Интерпретатор------------------------------------------------------------
Интерпретатор Python — это программа, которая выполняет написанные вами
программы Python.
Исходный код транслируется в байт-код затем выполняется PVM.
Исходный код автоматически компилируется затем интерпретируется.
Исходный код - то что пишет программист
Байт код - код который получается при компиляции исходного кода
PVM - вирт машина - интерпретирует байт код, выполняет программу
    Исходный код --> байт код  --> виртуал машина Python
    source code  --> bytecode  --> python virtual machine
    .py          --> .pyc      --> PVM
Байт код сохраняется только для импортированных модулей в каталог __pycache__ 
Он позволяет пропустить шаг компиляции при следующем
запуске программы,в случае если нет изменений в исх коде.
PVM выполняет байт код.

# Переменные среды-------------------------------------------------------------
Переменные среды, также известные как переменные командной оболочки или
переменные DOS, являются настройками уровня системы, которые находятся вне
интерпретатора Python и потому могут применяться для настройки поведения
интерпретатора.
# Важные переменные среды:
PATH           # Путь поиска командной оболочки системы (для нахожд python)
PYTHONPATH     # Путь поиска модулей Python (для операций импортирования)
PYTHONSTARTUP  # Путь к файлу запуска для интерактивной оболочки Python
TCL_LIBRARY,   # Переменные для расширения tkinter
TK_LIBRARY
PY_PYTHON,     # Стандартные настройки для запускающего модуля Windows
PY_PYTHON3,      (см.приложение Б)
PY_PYTHON2

# Аргументы командной строки---------------------------------------------------
python {-bBdEhiIOqsSuvVWx?} [-c command | -m module | script | -] {args}
[]      # необязательные элем
{}      # кол-во от 0 до неск
|       # альтернативные вар-ты, или
-       # читать команды со стандартного ввода
script  # имя файла/полного или модуля с файлом __main__.py
args    # аргументы ком строки sys.argv[1:] нулевой - имя файла
# args:
-B      # Если этот параметр задан, Python не будет пытаться записывать на диск
          скомпилированные файлы, содержащие байт-код
-c      # Задает выполнение кода Python, указанного в качестве части ком строки
          python3 -c "import sys; print(sys.version)"
-E      # Игнорировать значения всех переменных среды, которые, возможно, были
          установлены
-h      # Вывести полный список доступных параметров и справочную информацию,
          после чего прекратить выполнение команды
-i      # Запустить интерактивный сеанс по завершении выполнения сценария или
          команды (PYTHONINSPECT)
-m      # Задает модуль или пакет Pythoп, который должен быть выполнен в кач  
          основного сценария python3 -m pip install numpy
-O      # Включает режим оптимизации генерируемого байт-кода (обратите внимание
          на то, что здесь используется буква "О" в верхнем регистре)
-OO     # Подобен параметру -O, но задает удаление строк документации
          из байт-кода
-s      # Отключить импорт модуля site, неявно заданный в сценарии автозапуска
          (раздел "Модули si te и si tecustomize" в главе 13)
-t      # Активизировать вывод предупреждающих сообщений о ненадлежащем
          использованием символов табуляции (-t t -то же самое, но в отношении
          сообщений об ошибках)
-u      # Использовать небуферизованные двоичные файлы для стандартных потоков
          ввода-вывода и ошибок (PYTHONUNBUFFERED)
-v      # Активизировать вывод отладочной информации всякий раз, когда
          импортируется модуль или освобождаются используемые им системные
          ресурсы (PYTHONVERBOSE)
-V      # Вывести номер версии Pythoп и выйти из программы интерпретатора
-х      # Исключить (пропустить) первую строку в файле с исходным кодом 
          основного сценария

#!/usr/bin/env python3      # shebang(шебанг) - путь к интерпретатору----------
# -*- coding: cp1252 -*-    # принудительное указание кодировки (UTF-8 по умлч)

# Прописываем в файлах и пользуемся различными интерпретаторами
#!python2
#!/usr/bin/python2.7
#!/usr/bin/env python3  # последняя версия python3

# Выбор интерпретатора из ком строки, верхние инструкции в этом случе онулир  
py m.py  # по умолчанию в Windows последняя 3-я версия    
ру -2 m.ру
ру -2.7 m.ру
ру -3 m.ру

python script.py >  file.txt # вывод в файл с перезаписью
python script.py >> file.txt # вывод в файл с добавлением

выход/EOF  # Ctrl-D on Unix, Ctrl-Z on Windows, exit()

Виртуальная среда/окружение-----------------------------------------+
Изолированная среда с чистым интерпретатором со стандартными библ-ми,
есть свой pip, ставь что хочешь - будет все только в этой папке
# Windows:
python -m venv Myenv            # создать окружение
./Myenv/Scripts/activate.bat    # активировать
          .../deactivate.bat    # деактивировать
# Linux:
pip3 install virtualenv         # установка
python3 -m venv Myenv           # создать окружение
. Myenv/bin/activate            # (source) активировать
deactivate                      # деактивировать     

Документация, справка-----------------------------------------------+
# comments
dir(obj)                            # список всех атрибутов объекта
"""Строки документирования"""       # располагаются в начале модуля или под 
                                      названием класса или функции.
obj.__doc__                         # отображает строки документирования.
python -m pydoc sys или help('sys') # документация PyDoc.
python -m pydoc -b                  # PyDoc(HTTP) в браузере
http://www.python.org               # Документация

Модули ------------------------------------------------------------------+
модуль - каждый файл исходного кода с суффиксом .py
import - импорт, доступ к содержимому модуля (модуль.атрибут)
from hui import reload           # импорт определенных объектов
from her.hui import fui as f     # импорт и переименование
reload(my_script)                # загружает и выполняет тек версию файла(перезагрузка)
from module import name1, name2  # Копировать указанные два имени (только)
# эквивалент
import module          # Извлечь объект модуля
name1 = module.name1   # Копировать имена присваиванием
name2 = module.name2   
del module             # Избавиться от имени модуля
exec(open('module.ру').read()) # является еще одним приемом запуска
                                 файлов из интерактивной подсказки без 
                                 импортирования и последующей перезагруз
dir(модуль)     # список всех имен, доступных внутри модуля
модуль.__dict__ # словарь всех имен модуля
list(модуль.__dict__.keys()) == dir(модуль)
# все атрибуты модуля можно посмотреть в словаре __dict__
sys.__name__ == sys.__dict__['__name__'] == 'sys'
# второй вариант импорта
os = __import__('os') == import os
'__main__' - это имя(__name__) модуля с которого стартует приложение
модуль.атрибут
пакет.модуль.атрибут

Пакеты - директории с необязательным файлом __init__.py который вызывается
    при импортировании, в нем осуществляется настройка для импорта *, с по
    мощью списка __all__

Работа импорта:
1. Ищут файл модуля.
    sys.path - все пути поиска
    1. Домашний каталог программы.
    2. Каталоги PYTHONPATH (если установлены - переменные среды). 
    3. Каталоги стандартной библиотеки.
    4. Содержимое любых файлов .pth (при их наличии).
    5. Подкаталог site-packages, где размещаются сторонние расширения.

2. Компилируют его в байт-код (при необходимости).
3. Выполняют код модуля для создания объектов, которые в нем определены.

Типы---------------------------------------------------------------------------+
Все в python это объекты, встроенные, либо созданные юзером. 
Это порции памяти со значениями и наборами операций.

Встроенные типы(входят в Python)
Числа: ------------------------------------------------------------------------+

 Числовые литералы и конструкторы:
+-----------------------------------+-----------------------------------------+
| Литерал                           | Толкование                              |
+-----------------------------------+-----------------------------------------+
|1234, -6, 0, 99999                 | целые числа(неогр размер)               |
|1.23, 1., 3.14е-10,4Е210, 4.0е+210 | числа с плавающей точкой                |
|0о177, 0x9ff, 0b01010              | Восьмеричный, 16-й и двоич­ный литералы  |
|34-4j, 3.0+4.0j, 3J                | Литералы комплексных чисел              |
|set ('spain'), {1, 2, 3, 4}        | Множества: формы создания Python З.Х    |
|Decimal('1.0'), Fraction(1, 3)     | Типы расшир-й десятичных и дробных чисел|
|bool(x), True, False               | Булевский тип и константы               |
+-----------------------------------+-----------------------------------------+

Использованиe "e/E" в числах --> получим float
    3.14e-1  ==>  3.14 * 10**-1  ==>  3.14 * 0.1 ==>  0.314
    100E2    ==>  100 * 10**2    ==>  100 * 100  ==>  10000.0

Системы исчисления
    99   - 10-тичная = 99  
    0xFF - 16-ричная = 255      hex() - перевод целого в 16си
    0o77 - 8-ричная  = 63       oct() - перевод целого в 8си
    0b11 - двоичная  = 3        bin() - перевод целого в 2си

    int(str, base)  - преобразует строку в целое по СИ=base

    "{0:о}, {1:х}, {2:Ь}".format(64, 64, 64) # с помощью формата строк

Комплексные числа
    действительная + мнимая часть(j/J)(может состоять только из мнимой)
    создать: 2+3j = complex(2, 3)

Встроенные инструменты для обработки объектов чисел:

Операции выражений Python:
    выражения - комбинация объектов и операций, которая вычисляет значение

    Операции                    | Описание
    -------------------------------------------------------------------------+
п   yield x                     | Протокол send функции генератора
р   lambda аргументы: выражение | Создание анонимной функции      
и   х if у else z               | Тернарный выбор (х оценивается, только если 
о                               | у истинно)
р   х or у                      | Логическое ИЛИ (у оценивается, только 
и                               | если х ложно)
т   х and у                     | Логическое И (у оценивается, только если 
е                               | х истинно)
т   not x                       | Логическое НЕ
    х in у, x not in у          | Членство (итерируемые объекты, множества)
|   x is у, x is not у          | Проверки идентичности объектов
v   x < у, x <= у, x > у, >=    | Сравнение по абсолютной величине, проверка
                                | на подмножество и надмножество
    х == у, х != у              | Операции равенства значений
    х | y                       | Побитовое ИЛИ, объединение множеств
    x ^ у                       | Побитовое исключающее ИЛИ, симметричная 
                                | разность множеств
    x & у                       | Побитовое И, пересечение множеств
    x << у, x >> у              | Сдвиг х влево или вправо на у битов
    x + у                       | Сложение, конкатенация
    x - у                       | Вычитание, разность множеств
    x * у                       | Умножение, повторение
    x % у                       | Остаток, формат
    x / у, x // у               | Деление: настоящее и с округлением в 
                                | меньшую сторону
    -х, +х                      | Противоположность, идентичность
    ~х                          | Побитовое НЕ (инверсия)
    x ** у                      | Возведение в степень
    х [1]                       | Индексация (послед-ти, отображения и т.д.)
    x [1: j: к]                 | Нарезание
    х(...)                      | Вызов (функции, метода, класса и прочих
                                | вызываемых объектов)
    х.атрибут                   | Ссылка на атрибут
    (...)                       | Кортеж, выражение, выражение генератора
    [...]                       | Список, списковое включение
    {...}                       | Словарь, множество, включения множеств и 
                                | словарей
    ----------------------------+--------------------------------------------+                            
Преобразование типов
    Python сначала преобразует операнды к типу самого сложного операнда
    неявное преобразование
    40 + 3.14 = float = 43.14
    2 + True = int = 3
    явное преобразование
    40 + int(3.14) = 40  int() - усекает дробную часть
    float(40) + 3.14 = 43.14

Округление/усечение
    math.ceil(2.5)     # 3 ближайшее бОльшее целое
    math.floor(2.5)    # 2 Ближайшее меньшее значение
    math.trunc(2.5)    # 2 Усечение дробной части (в сторону нуля) == int(2.5)
    round(2.532, x)    # 2.53 Стандартное округление (x - кол-во цифр после ,)

Математические ф-ии
    pow(2, 4)   # возведение в степень (корень)
    2 ** 0.5    # корень (степень)
    min(seq)    # минимум
    max(seq)    # максимум
    sum(seq)    # сумма
    abs(num)    # абсолютное значение

Модули для работы с числами
    builtins    - встроеный модуль со всеми функциями(по типу round, abs..)
    math        - различные математические ф-ии
    random      - случайные числа
    decimal     - работа с десятичными числами
    fractions   - дробные числа
    numpy       - вычисления, векторы, матрицы ...
    scipy       - научная библиотека, лин алгебра ...


Строки ----------------------------------------------------------------------+
    неизменяемые последовательности, представлением служит любой текст или 
        байты.

    str       - текстовый формат Unicode, ASCII
    bytes     - двоичный формат
    bytearray - изменяемый bytes

    Распространенные строковые литералы и операции:
    | Операция                  | Описание                             |
    +---------------------------+--------------------------------------+
    s = ''                      | пустая строка
    s = "spam's"                | двойные ковычки = одинарные
    s = 's\np\ta\x00m'          | управляющие последовательности
    s = """ много """           | блочные строки
    s = r'\tspam\n'             | неформатированные строки(без упр посл)
    b = b'sp\xc4m'              | байтовые строки
    u = u'sp\u00c4m'            | строки Юникод
    s1 + s2, 'ss' 'ff'          | конкатенация, явная/неявная
    s3 * 3                      | повтор
    s[i]                        | индекс доступ
    s[i:j:k]                    | срез [от: до: шаг]
    len(s)                      | длина
    "a %s parrot" % kind        | выражение форматирования
    "a {} parrot".format(kind)  | метод форматирования
    f"a {var} parrot"           | аналог метода format
    s.find('pa')                | поиск
    s.rstrip()                  | удаление пробельных символов
    s.replace('pa', 'xx')       | замена
    s.split(',')                | разделение по разделителю
    s.isdigit()                 | это цифры?
    s.lower()                   | ниж регистр
    s.title()                   | все слова с большой буквы
    s.endswith('spam')          | конец
    'spam'.join(strlist)        | объединение с разделителем
    s.encode('latin-1')         | кодирование
    b.decode('utf-8')           | декодирование
    for i in s: print(i)        | итерации
    "spam" in s                 | членство
    [i*2 for i in s]            | генератор списка
    map(ord, s)                 | применение map
    re.match('sp(.*)m', line)   | сопоставление с образцом
    +---------------------------+--------------------------------------+


    Символы коды:
        ord(' ')  -> вернёт цифровое представ символа в 10-тичной системе -> 32
        chr(0x20) -> вернёт символ, системы исч любые -> ' '        

    
    Управляющие последовательности
    | код            | описание/действие
    -----------------+----------------------------------------------+   
    \0 или \x00      | пустой двоичный символ, увеличивает длину len
    \777             | символ по восьмеричной системе, макс 3 цифры 
    \xFF             | символ по 16-ричной системе, 2 цифры строго
    \uffff           | 16-битный Unicode
    \Uffffffff       | 32-битный Unicode
    \another         | любой другой символ просто дублирует \ -> \\
    \\               | \
    \новая стр кода  | игнорируется \
    \n               | нов строка
    \t               | табуляция гор
    \r               | возврат каретки
    \b               | забой
    \a               | звонок
    \v               | табуляция вертик
    \f               | страница
    \" \'            | ковычки 
    -----------------+----------------------------------------------+
    Python печатает все двоичные символы в строках в 16-й системе.

    
    3 варианта записи пути:
        'C:\\new\\test.txt'-> \\
        r'C:\new\test.txt' -> r
        'C:/new/test.txt' в стиле Unix


    Форматирование строк---------------------------------------------------------+
    
    Выражение форматирования строк: '...%s...' % (значения,)
        основан на модели printf языка С

        Расширенный синтаксис выражений форматирования

        % [(имя ключа)] [флаги] [ширина] [.точность] код типа
             имя ключа  - исп-ся для индексации словаря
             '%(a)s and %(b)s' % {'a': 'hui', 'b': 'loh'}.
             флаги 
                выравнивание: -лев - край, пусто - правый
                знак: +плюс ставить принудительно либо пусто
                нули: заполнение нулями поля(либо за точкой либо перед)
                '%-+010.2f' % 12.028 - пример (не совсем логичный)
             ширина - ширина поля
             точность - кол-во цифр после точки для float
             * - указывается в ширине и точности - брать свои значения
                 из следующего элемента во входных значениях прав части выр-я
                 '%*.*f' % (5, 2, 2.345) звёздочки заменяются на след цифру(5, 2)

        Коды типов в форматировании строк
        | код | Описание
        +-----+--------------------------------------------------------+
        s     | Строка (или строка str(X) любого объекта)
        r     | То же, что и s, но применяется герг, а не str
        c     | Символ (int или str)
        d     | Десятичное число (целое число с основанием 10)
        i     | Целое число
        u     | То же, что и d (устарел: больше не является беззнаковым)
        o     | Восьмеричное целое число (с основанием 8)
        x     | Шестнадцатеричное целое число (с основанием 16)
        X     | То же, что и х, но в верхнем регистре
        e     | Число с плавающей точкой со степенью, в нижнем регистре
        E     | То же, что и е, но в верхнем регистре
        f     | Десятичное число с плавающей точкой
        F     | То же, что и f, но в верхнем регистре
        g     | Число с плавающей точкой е или f
        G     | Число с плавающей точкой Е или F
        %     | Литерал % (записывается как %%)
        +--------------------------------------------------------------+


    Вызов метода форматирования строк: '...{}...'.format (значения)
        кое в чем выведен из одноименного инструмента в С#/.NET и частично совпадает по функциональности с выражениями форматирования строк

        Метод format
        {имя_поля компонент !флаг-преобразования:специф-формата}
            имя поля - позиция или ключевое имя
            компонент - индекс[] или .атрибут
            !флаг - !r !s или !a - repr str ascii
            :специф-формата - различные настройки вывода → ниже
                [[заполн] выравн] [знак] [#] [0] [шир] [,] [.точность] [код_типа]
                    заполнение - любой символ кроме фиг скобок
                    выравнивание - < > = - ^
                    знак +- пробел
                    запятая для больших чисел
                    ширина, точность все так же
                    Может содержать вложенные {}
                    код типа - такие же как у формата плюс \b - bin()
                    строковое представление любого типа не требует кодов
        '{0:>10} = {1:<10.02}'.format('spam', 123.4567)

    Сравнение
        'The {} side {} {}' .format('bright', 'of ’, 'life')
        'The %s side %s %s' % ('bright', 'of', 'life')
        f'The {var1} side {var2} {var3}'

        '{0:f), {l:.2f}, {2:06.2f}'.format(3.14159, 3.14159, 3.14159)
        '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159)
        '{var1:f), {var2:.2f}, {var3:06.2f}'

    

Списки---------------------------------------------------------------------------+
    упорядоченная коллекция произвольных объектов, изменяемая последовательность,
    доступ по индексу, представляют собой ссылки на объекты

    Распространенные списковые литералы и операции
    | Операция                 | Описание
    +--------------------------+-------------------------------------------------+
    L = [], L = list()         | Пустой список
    L = [12, -0.2, 'her', {}]  | 4 разных элем
    L = ['Bob',['dev', 'mgr']] | Вложенные подсписки
    L = list('spam')           | Список элементов итерируемого объекта
    L = list(range(-4, 4))     | список последовательных целых чисел
    L[i: j : k]                | индексы, срезы [от: до: шаг]
    len(L)                     | длина
    L1 + L2                    | конкатенация
    L1 * 3                     | повторение
    for х in L: print (х)      | итерация
    3 in L                     | членство
    L.append(4)                | методы: увеличение
    L.extend([5,6,7])          |
    L.insert(i, X)             |
    L.index(X)                 | поиск
    L.count(X)                 |
    L.sort()                   | сортировка
    L.reverse()                | реверс
    L.copy()                   | копия
    L.clear()                  | очистка
    L.pop(i)                   | уменьшение
    L.remove(X)                |
    del L[i]                   |
    del L[i:j]                 |
    L[i:j] = []                |
    L[i] = 3                   | присваивание
    L[i:j] = [4,5,6]           |
    L = [x for x in range(5)]  | списковые включения
    list(map(ord, 'spam'))     | отображения
    +--------------------------+-------------------------------------------------+

    

Словари--------------------------------------------------------------------------+
     неупорядоченные коллекции объектов, доступ к элементам происходит по ключу,
     представляют собой таблицы ссылок на объекты (хеш-таблицы)

      Распространенные словарные литералы и операции
    | Операция                        | Описание
    +---------------------------------+------------------------------------------+
    D = {}                            | Пустой словарь
    D = {'name': 'Bob', 'age': 40}    | Двухэлементный словарь
    E = {'cto':{'a': 1, 'b': 2}}      | Вложение
    D = dict(name='Bob', age=40)      | Альтернативные методики создания:
    D = dict([('name', 'Bob'),        | ключевые слова, пары “ключ/значение”
              ('age', 40)])           | 
    D = dict(zip(keys, values))       | упакованные пары “ключ/значение”
    D = dict.fromkeys(['name','age']) | списки ключей
    D['name']                         | индекс
    E['cto']['age']                   | 
    'age' in D                        | вхождение
    D.keys()                          | ключи
    D.values()                        | значения
    D.items()                         | кортежи ключ+значение
    D.copy()                          | копия
    D.clear()                         | очистка
    D.update(D2)                      | объединение по ключам
    D.get(key, default?)              | извлечь, если отсутствует - default
    D.pop(key, default?)              | удалить, если отсутствует - default
    D.setdefault(key, default?)       | установить, если отсутствует - default
    D.popitem()                       | удаление/возвращение любой пары к+з
    len(D)                            | кол-во элем
    D[key] = 42                       | добавить
    del D[key]                        | удалить
    list(D.keys())                    | Словарные представления
    D1.keys() & D2.keys()             | 
    D = {x: x*2 for x in range(10)}   | Включения словаря
    sorted(D)                         | сортировка словаря по ключам
    +---------------------------------+------------------------------------------+



Кортежи--------------------------------------------------------------------------+
    как списки за исключением того, что не могут быть модифицированы на месте
    (неизменяемы), массивы ссылок на объекты

    Распространенные литералы и операции над кортежами
    | Операция                        | Описание
    +---------------------------------+------------------------------------------+
    ()                                | Пустой кортеж
    T = (О,)                          | Одноэлементный кортеж (не выражение)
    T = (O, 'Ni', 1.2, 3)             | Четырехэлементный кортеж
    T = O, 'Ni', 1.2, 3               | такой же
    Т = (’Bob’, (’dev', 'mgr'))       | Вложенные кортежи
    Т = tuple('spam')                 | Кортеж из элементов итерируемого объекта
    T[i]                              | индексы срезы
    T[i][j]                           |
    T[i:j]                            |
    len(T)                            | длина
    T1 + T2                           | конкатенация
    T*3                               | повторение
    for x in T: print (x)             | итерация
    'spam' in T                       | членство
    [x ** 2 for x in T]               | 
    T.index('Ni')                     | поиск
    T.count('Ni')                     | подсчет
    namedtuple('Emp',['name','jobs']) | именованый кортеж
    +---------------------------------+------------------------------------------+



Файлы----------------------------------------------------------------------------+
    Распространенные файловые операции
    | Операция                        | Описание
    +---------------------------------+------------------------------------------+
    output = open(г'С:\spam', 'w')    | Создает выходной файл w - write — запись
    input = open ('data', 'г')        | r - чтение
    input = open ('data')             | тоже самое
    aString = input.read()            | Читает целый файл в одиночную строку
    aString = input.read(N)           | Читает до N след символов (или байтов)
    aString = input.readline()        | Читает следующую строку файла+ \n
    aList = input.readlines()         | Читает целый файл в список строк c \n
    output.write(aString)             | Записывает строку символов (или байтов)
    output.writelines(aList)          | Записывает все строки из списка в файл
    output.close()                    | Вручную закрывает файл 
    output.flush()                    | Сбрасывает буфер вывода на диск
    anyFile.seek(N)                   | Изменяет позицию на N для след операции
    for line in open('data'):         | Файловые итераторы, читающие строки
        исп-ть строку                 | 
    open('f.txt', encoding='latin-1') | Текстовые файлы Unicode
    open('f.bin', 'rb')               | Байтовые файлы
    +---------------------------------+-----------------------------------------+


    модули связанные с файлами
        pickle - сериализация объектов в файлы
        json - Хранение объектов Python в формате JSON
        struct - Хранение упакованных двоичных данных

+===============================================================================+



Операторы Python-----------------------------------------------------------------+

    Оператор     | Роль | Пример
    +------------+----------------------+----------------------------------------+
    присваивание | создание ссылок      | a, b = 'good', 'bad'
    вызовы и др  | выполнение функций   | log.write('her', loh='lohX')
    print        | Вывод объектов       | print(12)
    if/elif/else | Выбор действий       | if True: pass
    for/else     | итерация             | for i in range(2,100,2): print(i)
    while/else   | универсальные циклы  | while True: pass
    pass         | пустой заполнитель   | pass
    break        | выход из цикла       | while True: break
    continue     | след итерация        | while True: continue
    def          | функции и методы     | def foo(): pass
    return       | возврат из функций   | def foo(): return 0
    yeild        | возврат генератора   | def gen(n): for i in n: yield n**2
    global       | пространство имен    | x = 'old'; def foo(): global x
    nonlocal     | пространство имен    | def foo(): nonlocal x; 
    import       | импорт модулей       | import sys
    from         | доступ к атрибутам   | from sys import version [as ver]
    class        | создание классов     | class Person(superclass): pass
    try/expect/  | перехват исключений  | try: int('gg'); except: print('Error')
        finnaly  |                      |
    raise        | генерация исключений | raise EndSearch(location)
    assert       | отладочные проверки  | assert X > Y, 'X too small'
    with/as      | диспетчеры контекста | with open ('data') asmyfile: pass
    del          | удаление ссылок      | del data[k]
    +------------+----------------------+----------------------------------------+

    Формы оператора присваивания
    Операция                       | Описание
    +----------------------------------------------------------------------------+
    spam = 'spam'                  | базовая форма
    spam, ham = 'yum', 'YUM'       | кортеж, позиционное
    [spam, ham] = ['yum', 'YUM']   | список, позиционное
    a, b, c, d = 'spam'            | присваивание последова-ти, обобщенное
    a, *b = 'spam'                 | расшир-ая расп-ка посл-ти (b = ['p','a','m'])
    spam = ham = 'spam'            | групповое присваивание
    spams += 42                    | дополненное присваивание
    +------------------------------+---------------------------------------------+

    Зарезервированные слова Python
    +-------------------------------+
    | False class finally is return |
    | None continue for lambda try  | 
    | True def from nonlocal while  |
    | and del global not with       |
    | as elif if or yield           |
    | assert else import pass       |
    | break except in raise         |
    +-------------------------------+

    Операции вывода
        Методы файловых объектов  file.write(str)
        Стандартный поток вывода  sys.stdout
        Функция print


    Функция print-----------------------------------------------------------------
    print([object, ...][, sep=' '] [, end='\n’][, file=sys.stdout][, flush=False])

        sep    строка между текстовыми представлениями объектов
        end    строка добавляемая в конец текста
        file   принимает любой объект с методом write, по умолчанию sys.stdout
        flush  Он позволяет вызову print предписывать, что текст должен 
               немедленно сбрасываться через поток вывода в любые
               ожидающие получатели

        object получается путем str(object)

        сравнение выводов
            print (X, Y)  вывод 2-х объектов
            sys.stdout.write(str(X) + ' ' + str(Y) + '\n')  эквивалент

    Перенаправление вывода
        temp = sys.stdout   # сохраним поток вывода
        sys.stdout = open('log.txt', 'a')  # перенаправление в файл
        print(1,2,3)  # вывод в файл
        sys.stdout.close()  # сброс вывода на диск
        sys.stdout = temp   # восстановление исходного потока

        print(x, y, z, file=open('log.txt', 'a'))  # тоже самое единоразово

        сравнение перенаправлений
            print(X, Y, file=open('temp1', 'w'))
            open('temp2', 'w').write(str(X) + ' ' + str(Y) + '\n'
    ------------------------------------------------------------------------------


    Операторы if --------------------------------------+
        
        if True:
            pass
        elif False:
            pass:
        else:
            pass

    Тернарное выражение if/else
        if X:
            A = Y    эквивалентно    A = Y if X else Z
        else:
            A = Z
    +--------------------------------------------------+


    Циклы while/for ----------------------------------------------------------+

        while True:    # пока истина выпонить
            break     выход из цикла
            continue  следующая итерация
        else:
            pass    Выполняются, если не произв выход из цикла с помощью break
                         ^
                         |
        for i in obj:    |  # for - обход последовательностей
            pass         |
        else:            |
            pass --------+

+================================================================================+



Итераторы------------------------------------------------------------------------+
    Любой объект с методом __next__ для перехода на следующий результат, 
    который генерирует искл StopIteration при достижении конца серии результатов.

    все внутренне итерационные инструменты обычно работают, вызывая __next__ на
    каждой итерации и перехватывая исключение Stopiteration для выяснения,
    когда выходить.

    для некоторых объектов полный протокол включает дополнительный первый шаг, 
    связанный с вызовом __iter__, но для файлов он не требуется, файлы уже имеют
    метод __next__, а на вызов __iter__ возвращается тот же объект

    Эквивалентные функции итераторов
        obj.__next__() == next(obj)  # следующая итерация
        obj.__iter__() == iter(obj)  # возвращает итератор

    Ручная итерация, так устроен цикл For(если добавить обработку исключений)
        L = [1,2,3]
        I = iter(L)     # получаем объект итератор
        I.__next__()    # вызываем метод next до исключения StopIteration

    map, zip, filter - возвращают итераторы

    методы словаря keys, values, items - возвращ итерируемые объекты




Генераторы  
    I = (x**2 for x in range(10)) # итерируемое выражение
    
    # генераторная ф-ия
    def foo():
        for i in range(10):
            yield i**2

    Y = foo() # эквивалент генератора выше

    (x**2 for x in range(10))   # итерируемый объект
    [x**2 for x in range(10)]   # списковое включение
    {x**2 for x in range(10)}   # множество
    {x:x**2 for x in range(10)} # словарь
    

    list(map(lambda х: х**2, filter(lambda х: х % 2 == 0), range(10)))
    [х ** 2 for х in range(10) if х % 2 == 0]  # эквивалент

    [x+y for x in range(10) for y in range(5)]  # вложенные циклы





+================================================================================+



Функции -----------------------------------------------------------------------+
    
    # стандартное объявление ф-ии
    def f(a, b='spam', *args, **kwds):
          |      |       |       |
        аргумент |       |       |
                 +-по умолч      +-остальные ключ-е слова формируются в словарь
                         |
                         +-остальные аргументы формируются в список

    # использование '/' и '*' в параметрах
    def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
          -----------    ----------     ----------
            |             |                  |
            |        позиц-ые или ключ-ые    |
            |                                +- только ключевые пар-ры
            +--только позиц-ые пар-ры

    # аннотации (для более быстрой работы - явная типизация)
    def f(ham: str, eggs: str = 'eggs') -> str:
        print("Annotations:", f.__annotations__)

    вызовы функций
        func(знач)              аргумент сопоставляется по позиции
        func(имя=знач)          ключевой арг, сопоставляется по имени
        func(*итерируемый_obj)  перед все члены объекта как отдел поз-ые арг-ты
        func(**словарь)         перед все пары ключ:знач как ключ аргументы



    оператор global
        начинает поиск имен в модуле, продолжает во вложенных областях

    оператор nonlocal
        начинает поиск из области видимости функции наружу, продолжая до модуля


    # пример global и nonlocal
        x = 'spam' ----+
        y = 'ham'      |
                       |
        def f1():      |
            global x --+
            x = 'hui' 
            y = 'her' -------+
            def f2():        |
                nonlocal y---+
                y = 'spam'


+================================================================================+



Динамическая типизация/Сборщик мусора -------------------------------------------+
    a = 3    # переменная a ссылается на объект типа int со значением 3
    a = 'a'  # теперь а ссылается на тип str, а предыдущий объект int удален
               сборщиком мусора, так как на него больше не ссылается ничто.

    b = 3    # оба объекта будут указывать на один и тот же объект int -
    c = 3      кэширование, так сделано для скорости работы Python, а также
               для экономии ОП. b is c == True
    c = 4    # при изменении значения одной переменной, она будет указывать на 
               другой объект

    L1 = [1,2]  # три списка одинаковых по значению, но ссылаются на 2 объекта 
    L2 = [1,2]    L1 is L2 = False  L1 is L3 = True. Равенство копирует ссылку.
    L3 = L1 
    L3[0] = 9   # при изменении значения L3 - не будет создан новый объект,
                  а изменится текущий, и все переменные ссылавшиеся на него
                  получат новые значения соответственно L == [9,2]

    L = L1[:]  # новый объект путем копирования
    import copy
    L = copy.copy(L1)     # еще 1 способ копирования
    L = copy.deepcopy(L1) # еще и скопировать вложенные объекты а не ссылки

    id(obj)  # адрес памяти, где хранится объект
+================================================================================+




Множества ---------------------------------------------------------------------+
    неупорядоченная коллекция уникальных и неизменяемых объектов, которая
    поддерживает операции, соответствующие математической теории множеств.

    создание:
        x = {1,2,3,4}
        y = set((1,2,3,4))
        {х ** 2 for х in [1, 2, 3, 4]}


    операции:
        x - y  # Разность
        x | y  # Объединение
        x & y  # Пересечение
        x ^ y  # Исключающее ИЛИ
        x > y  # Надмножество
        x < y  # Подмножество

        x.add(5)    # вставка
        x.remove(4) # удаление
+================================================================================+


--- Functions ----------------------------------------------------------------+

eval('строка')              # выполняет строку как код Python, eval('print(1)')
                              односоставная команда
exec('строка|файл|объект')  # выполняет как код Python, поддерживает Блок кода
                              объект - то что возвращает compile()
compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)
    возвращает объект для exec
    source: это исходный код или байтовая строка, которую нужно скомпилировать. 
    filename : это имя файла, Если нет, мы можем ввести имя для исходного кода. 
    mode: это режим, в котором будет скомпилирован исходный код. 
        3 режима: eval: этот режим исп, когда исходным кодом является одно выраж
                  single: исп, когда источник содерж 1 интерактивный оператор.
                  exec: этот режим используется, когда источник содержит блок 
    

repr(obj)       # вызов ф-ии __repr__() объекта - возвращает строку, содержащую
                  печатаемое формальное представление объекта. При передаче в 
                  eval() воспр тот же по значению объект. Либо возвращает
                  некую информацию в угловых скобках <нав-ие, адрес>, ориентиро-
                  ванную на разработчиков
yield x         # возвращает из ф-ии генератор, каждый раз результат 1 итерации,
                  с помощью next(). for i in n: yield i*2


vars()          # возвращает словарь со всеми переменными существующими на 
                  момент вызова. От __name__ до своих переменных.


map(foo, obj)   # применяет фун foo к членам итерируемого объекта obj -> ит-р
(foo(x) for x in obj)   # итерируемое выражение - аналог

filter(lambda x: x > 0, range(-5, 5))   # возвр итер с членами для кот x==True
(x for x in range(-5, 5) if x > 0)      # аналог

any(iterable)   # возвращ True если хотя бы 1 True

zip([1,2],[a,b])# возвращает итератор кортежей (1,'a') (2,'b') (пары a[i],b[i])


Decorators/Декораторы----------------
def timer(foo):
'''function-decorator'''
    def wrapper(*args, **kwargs):
    '''function-wrapper'''
        start = datetime.now()
        result = foo(*args, **kwargs)
        print(datetime.now() - start)
        return result
    return wrapper

@timer
def my_foo(count):
'''decorated function'''
    return [x for x in range(count)]

# my_foo(10) == timer(my_foo)(10)

Closures/замыкания-----------------------------------------------------------------
# замыкание - функция со связанными данными
  функция - имеющ ссылки на перем объяв во внеш зоне видимости(охват-щая) - 'inner'
  данные - переменные также не явл пар-ми ф-ии - 'x'
def one():
    x = 'myvar'
    def inner():
        print(x)
        print('id:', id(x))
    return inner
f = one()   # => inner
f()         # output1: myvar; output2: id: 16346367478
f.__closure__[0].cell_contents  # => 'myvar'; the same id


pip-----------------------------------------------------------------------
# get the copy of all installed packages in the current venv
pip freeze > requirements.txt   # write output to file
pip install -r requirements.txt # install the same dependencies to new venv


--- ООП -----------------------------------------------------------------------+
Наследование - способность некоего класса наследовать атрибуты от другого
    существующего класса.
Инкапсуляция - использование объекта через интерфейс без необходимости знать
    как он устроен внутри.
Полиморфизм  - наследуемое свойтво может быть использовано напрямую, а может
    быть переопределено(перегрузка). 

Классы:

class C(B2, A1):    # наследуются справа налево - атрибуты ищутся слева направо!
    """документация класса"""   # C.__doc__
    x = 12      # атрибут класса - общий для всех экз(типа статический член)
    self.y = 2  # атрибут экземпляра - для каждого экз свой

Встроенные атрибуты объектов
    __doc__     #  содержит строку с описанием класса
    __name__    #  содержит строку с именем класса;
    __dict__    #  содержит набор атрибутов экземпляра/класса без унаследов-х

Использование классов/экземпляров
    dir(C)      # все связанные имена, по всей иерархии классов
    c = C()     # создать экземпляр
    c.x         # обращение к полям(данным), не важно свой атр или атр класса
    c.__dict__['x'] # обращение или создание атрибутов через __dict__


Функции для работы с атрибутами экземпляра:     name - строковое имя атр
    getattr(obj, name [, default])  # знач атр объекта, или вернет default
    hasattr(obj, name)              # проверка на наличие атрибута name в obj
    setattr(obj, name, value)       # задает знач атр, если не сущ - создается
    delattr(obj, name)              # удаляет атрибут с именем name
Принадлежность экземпляра:
    isintance(obj, Class)           # проверка на принадлежность классу

Методы:
class C(A):
    def __init__(self, *args):  # констуктор экземпляра
        super().__init__(*args) # вызов конструктора базового класса А

    def foo(self):  # self - ссылка на экз, вызвавшего этот метод(C++ this)
        pass

    @staticmethod
    def bar():      # метод класса, доступен всем экз, общий
        pass

c = C()     # создать экземпляр
c.foo()     # вызов медода, ссылка на этот экз(self) передается автоматом
C.foo(c)    # вызов метода с пом класса, передаем экз вручную

Магические методы __method__:
    __init__(self)      # конструктор/инициализатор вызыв при создании obj
    __del__(self)       # деструктор/финализатор вызыв при уничт экз
    __str__             # более друж вариант, выз-ся print(obj) str(obj)
    __repr__            # подроб вывод для разраб(так выводится в shell)
    __len__             # позволяет применять фун len() к экземплярам класса
    __abs__             # позволяет применять функцию abs() к экз класса

# все методы с 'attr' работают со словарем __dict__
    __setattr__(self, key, value)   # вызыв при изм свойства key класса
    __getattribute__(self, item)    # вызыв при получ св-ва класса item
    __getattr__(self, item)         # вызыв при получ несуществ item 
    __delattr__(self, item)         # вызыв при удал св-ва item(даже если нет) 


Доступ ------------------------------------------------------------------------+
Режимы доступа
    имя | режим доступа| доступ
    ----+--------------+---------------------------------------
    x   | public       | внутри класса, в объектах, наследниках
    _x  | protected    | только внутри класса и в наследниках 
    __x | private      | только внутри класса
    ----+--------------+---------------------------------------

Геттеры и сеттеры
    def setX(self, x):  # сеттер, устан знач приватному члену
        if x > 0:       # различные проверки типа isinstance(x, int) 
            self.__x= x
    def getX(self):     # геттер, возвращ знач приватного члена
        return self.__x

Приватные методы
    def __checkX(x):    # обращ внутри класса, обращ Class.__checkX(x)
        if x:           # различ проверки. 
            return True # такой метод можно встроить в сcеттер для удобства
        return False

Обращение к приватным членам 'в обход'
   obj._Class__x = 100  # к приватным атрибутам
   Class._Class__foo(3) # к приватным функциям
   Class.__dict__['_Class__foo'](3) # аналог верхней записи

Ограничение доступа к приватным членам(функции тоже)
    def __getattribute__(self, item):   # закрыть получение для __x
        if item == "__x":
            raise ValueError("Private attribute")
        else:
            return object.__getattribute__(self, item)
    def __setattr__(self, key, value):  # закрыть изменение __x
        if key == "__x":
            raise AttributeError
        else:
            self.__dict__[key] = value

Запрет на создание новых аттрибутов
class C:
    __slots__ = ['__x', '__y']  # тут размещаем то и только то что будет исп-ся
    такой подход также используют для увеличения скор обращ к атрибутам
    коллекция __dict__ в таких классах отсутствует

Свойства
Обращение к переменным через геттеры/сеттеры, но через 'точку', подобно 
    обращению к обычной переменной, но имея возм-ть вставлять различ проверки.

    def __getX(self):                                    # getter
        return self.__x  
 
    def __setX(self, x):                                 # setter
        if x:
            self.__x = x
    def __delX(self):                                    # deletter
        del self.__x

    coordX = property(__getX, __setX, __delX, "comment") # property

Свойства на декораторах
    @property               # getter
    def foo(self):          # все 3 функции - одинаковые названия, разные декор
        return self.__x  
    
    @foo.setter             # setter
    def foo(self, x):
        if x:
            self.__x = x
    
    @foo.deleter            # deletter
    def foo(self):
        del self.__x

Дескрипторы:
# дескриптор - класс с хотя бы одним переопр методом __get__, __set__, __delete__
Используются для того чтобы не определять для каждого атрибута повторяющиеся
свойства, допустим на проверку на отрицательное число.
class NonNegative:
    def __get__(self, instance, owner): # getter
        return instance.__dict__[self.name]
    def __set__(self, instance, value): # setter
        if value < 0:
            raise ValueError('Cannot be negative.')
        instance.__dict__[self.name] = value
    def __set_name__(self, owner, name): # init
        self.name = name 

# класс использующий дескриптор
class Order:
    price = NonNegative() # передача 'price' в кач name атрибута
    quantity = NonNegative()
    def __init__(self, name, price, quantity):
        self._name = name
        self.price = price
        self.quantity = quantity
    def total(self):
        return self.price * self.quantity
--------------------------------------------------------------------------------


абстрактный класс - без реализации методов, определяются в подклассах



Перегрузка операций


Распространенные перегрузки:
    Конструктор
    Деструктор
    Операция +
    Операция | (побитовое “ИЛИ”)
    Вывод, преобразования
    Вызовы функций
    Извлечение атрибута
    Присваивание атрибута
    Удаление атрибута
    Извлечение атрибута
    Индексирование, нарезание,
    итерация
    Присваивание по индексу и срезу
    Удаление по индексу и срезу
    Длина
    Булевские проверки
    Сравнения
    Правосторонние операции
    Дополненные на месте операции
    Итерационные контексты
    Проверка членства
    Целочисленное значение
    Диспетчер контекста (глава 34)
    Атрибуты дескриптора (глава 38)
    Создание (глава 40)

