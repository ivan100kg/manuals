# Регулянрные выражения Python


# Special characters
.       # any symbol except '\n'(with MULTILINE include '\n')
\d      # [0-9] all digits
\D      # [^0-9] all except digits
\w      # [a-zA-Z0-9А-Яа-яЁё_]  
\W      # [^a-zA-Z0-9А-Яа-яЁё_]
\s      # [\n\t\r\v\f]
\S      # [^\n\t\r\v\f]

# Экранирование спецсимволов
\. [.]  # обр слэш или квадратные скобки

# 1 на выбор из [], спецсимволы в игнорируются
[.,]    # точка как символ точки ИЛИ запятая
[tu2]   # any 1 symbol in brakets
[^tu]   # any chracter expect 't' or 'u'
[1-5]   # Ranges of symbol from 1 to 5
[b-f]   # symbol from b to f

# Выбор ИЛИ
A|B     # A or B, применяется также в группах с выражениями
r"red|green"        # найдет или green или red (findall найдет все)
r"(red|green)bla"   # найдет или green или red без лишних символов
r"(?:red|green)bla" # найдет или greenbla или redbla скобки не учитываются

# повторения символа x{от,до}
{m,n}   # повторенре символа x от min-m до max-n раз
{m}     # {m,m} ровно м раз, мажорный или минорный не имеет смысла
{m,}    # повтор от m и более раз -  минорный:   {m,}?
{,n}    # повторение не более n раз, минорный:   {,n}?
?       # {0,1} или 0 или 1,         минорный:   ??
*       # {0,} от 0 и более раз,     минорный:   *?
+       # {1,} один или более раз,   минорный:   +?

# мажор(жадный) / минор
text = '<p>text</p>'
r"<.+>"    # --> <p>text</p> жадный(greedy)/мажор, захват до послед совпадения
r"<.+?>"   # --> <p> non-greedy/минор, захватывает до первого совпад
r"0{2,3}"  # находит 0 от 2х до 3х повторений, мажорный режим, захватывает
             максимально возможное повторение 0 - '000'
r"0{2,3}?" # находит 0 от 2х до 3х повторений, минорный режим, захватывает
             минимально возможное повторение 0 - '00'
             
# границы
\b  # граница слова
\B  # не граница слова
^   # начало текста, если с флагом MULTILINE - начало каждой строки в тексте
$   # конец текста, если с флагом MULTILINE - конец каждой строки в тексте
\A  # начало текста
\Z  # конец текста


# groups
(...)       # любое рег выражение, создается группа, которая мб исп позже
(?...)      # какое-ниб расширение, не создают групп(1 исключ)

(lvl1(lvl2)(lvl2(lvl3)))   # уровни вложенности - формируется ответ в виде списка кортежей
                               начиная (1,2,3..) уровней
(45) ... \1"  \1,\2,\3... \<g>10... # номера скобок - то же значкние что и в скобках
(?P<val>45) ...(?P=val)"   # именованные скобки


match = re.findall(r"\W*(?:pid|tags)\W*", text)    # (?:или|или).* не сохраняющие скобки
match = re.findall(r"\W*(pid)\W*", text)    # сохраняющие скобки, выведет то что в скобках
match = re.findall(r"(\W?(pid)\W*(\d{3,}))", text)  # список кортежей(то что в скобках), формируется список кортежей по уровням скобок
match = re.findall(r"(['\"])(pid)\1\W*", text)  # \1 - то же значение что и в первой скобке, если в первой скобке выбор[1234] то в \1 будет тот символ которыц нацдется в скобке
match = re.findall(r"(?P<A>['\"])(pid)(?P=A)\W*", text)  # именованные скобки

(?:a|b)\d+  # скобки не учитываются - а с цифрами или b с цифрами
(a|b)\d+    # скобки учитываются - рез-т кортеж с тем что в скобках(a or b)


match = re.findall(r"\bpid\b", text)    # граница слова
#text = "English is the best language in the world!\nI'm serious"
match = re.findall(r"^.", text, flags=re.MULTILINE)
match = re.findall(r"is.*(?=best)", text, flags=re.MULTILINE)
match = re.findall(r"is.*(?<=best)", text, flags=re.MULTILINE)


# flags
re.ASCII   # только аски символы
IGNORECASE # игнорировать регистр
MULTILINE  # ищет совпадения в каждой подстроке влияет на ^ $
DOTALL     # точка включает и \n тоже
VERBOSE    # добавляет режим комментариев
DEBUG      # режим отладки

# functions
search   # находит первое вхождение, объект Match
finditer # все вхождения в итераторе, objects Match
findall  # все вхождения в списке, strings
match    # ищет совпадение с самого начала строки
split    # разбиение текста по шаблону
sub      # замена текста по шаблону
compile  # компилирут заранее шаблон.

match = re.split(r"\"", text)
match = re.sub(r"(pid)\W*\d+","ОТСОСИ У \1 ", text)
