# Регулянрные выражения Python


# Special characters
.       # any symbol except '\n'(with MULTILINE include '\n')
\d      # [0-9] all digits
\D      # [^0-9] all except digits
\w      # [a-zA-Z0-9А-Яа-яЁё_]  
\W      # [^a-zA-Z0-9А-Яа-яЁё_]
\s      # [\n\t\r\v\f]
\S      # [^\n\t\r\v\f]

# Экранирование спецсимволов
\. [.]  # обр слэш или квадратные скобки

# 1 на выбор из [], спецсимволы в игнорируются
[.,]    # точка как символ точки ИЛИ запятая
[tu2]   # any 1 symbol in brakets
[^tu]   # any chracter expect 't' or 'u'
[1-5]   # Ranges of symbol from 1 to 5
[b-f]   # symbol from b to f

# Выбор ИЛИ
A|B     # A or B, применяется также в группах с выражениями
r"red|green"        # найдет или green или red (findall найдет все)
r"(red|green)bla"   # найдет или green или red без лишних символов
r"(?:red|green)bla" # найдет или greenbla или redbla скобки не учитываются

# повторения символа x{от,до}
{m,n}   # повторенре символа x от min-m до max-n раз
{m}     # {m,m} ровно м раз, мажорный или минорный не имеет смысла
{m,}    # повтор от m и более раз -  минорный:   {m,}?
{,n}    # повторение не более n раз, минорный:   {,n}?
?       # {0,1} или 0 или 1,         минорный:   ??
*       # {0,} от 0 и более раз,     минорный:   *?
+       # {1,} один или более раз,   минорный:   +?

# мажор(жадный) / минор
text = '<p>text</p>'
r"<.+>"    # --> <p>text</p> жадный(greedy)/мажор, захват до послед совпадения
r"<.+?>"   # --> <p> non-greedy/минор, захватывает до первого совпад
r"0{2,3}"  # находит 0 от 2х до 3х повторений, мажорный режим, захватывает
             максимально возможное повторение 0 - '000'
r"0{2,3}?" # находит 0 от 2х до 3х повторений, минорный режим, захватывает
             минимально возможное повторение 0 - '00'
             
# границы
\b  # граница слова
\B  # не граница слова
^   # начало текста, если с флагом MULTILINE - начало каждой строки в тексте
$   # конец текста, если с флагом MULTILINE - конец каждой строки в тексте
\A  # начало текста
\Z  # конец текста


# groups
(...)           # любое рег выражение, создается группа, которая мб исп позже
                  группы номеруются по очереди, можно обратиться \1,\2...
                  пример (['"]).*?(\1) - (\1) == (['"])
(?...)          # какое-ниб расширение, не создают групп(1 создает - исключ)
(?aiLmsux)      # флаги(i==re.I), исп для части строки - мб один или неск
(?:...)         # скобки не учитывыются, внутри люб выражение (?:red|blue)
(?P<name>...)   # подстрока, соотв группе, доступна через симв имя группы
                  пример (?P<quote>['"]).*?(?P=quote) - также == \1
(?P=name)       # ссылка на именованную группу(см. выше)
(?#...)         # comment
(?=...)         # найдет выр-е, если после него будет то что в скобках
                  'Isaac (?=Asimov)' найдет 'Isaac ' если за ним след 'Asimov'
(?!...)         # найдет выражение, если за ним НЕ следует то что в скобках
(?<=...)        # найдет выр-е, если перед ним будет то что в скобках
                  '(?<=abc)def', 'abcdef' - найдет def
(?<!...)        # найдет выр-е, если перед ним НЕ будет то что в скобках

# уровни вложенности
(lvl1(lvl2)(lvl2(lvl3)))    # формируется ответ в виде списка кортежей
                              начиная (1,2,3..) уровней
                              <g>10 - нумерация если групп больше 9

# flags
re.ASCII   # только аски символы
IGNORECASE # игнорировать регистр
MULTILINE  # ищет совпадения в каждой подстроке влияет на ^ $
DOTALL     # точка включает и \n тоже
VERBOSE    # добавляет режим комментариев
DEBUG      # режим отладки

# functions
search   # находит первое вхождение, объект Match
finditer # все вхождения в итераторе, objects Match
findall  # все вхождения в списке, strings
match    # ищет совпадение с самого начала строки
split    # разбиение текста по шаблону
sub      # замена текста по шаблону
compile  # компилирут заранее шаблон.
