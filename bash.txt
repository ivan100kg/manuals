# GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu)

--- директории с программами и сценариями ---
/bin            # бинарные файлы исп системой
/sbin           # бинарные файлы исп системой с правами суперпользователя
/usr/bin        # общисистемные бинарные файлы
/usr/sbin       # общисистемные бинарные файлы с правами суперпользователя
/usr/local/bin  # для ваших сценариев и программ
/usr/local/sbin # для установленных с помощью пакет менеджера
~/bin			# для ваших сценариев и программ(создают самостоятельно

--- Правила писания в баш скриптах ---
#!/bin/bash     # шебанг which bash(какой bash используется)
# comment       # строки начинающиеся с # или пустые строки - игнорируются
pwd				# the shell commands are entered one per line.
pwd; ls			# two commands have to be separated with semicolon.
echo "pri\		# \ исп в сценариях для переноса длинных строк
vet"
\n \$ \\ \( \) 	# экранирование спецсимволов
""  			# экранирование текста, можно использовать подстановку $
''  			# полное экранирование, что напишешь то и выведет
;   			# разделитель более 1-ой инструкций в одной строке

--- Код возврата ---
# любой сценарий, ф-я или команда возвращает код завершения
0           # успешное завершение/true
1-255       # ошибка/false
echo $?	    # выводит последний код завершения

--- Пользовательские переменные ---
a=z                	# Присвоит переменной a строку "z".
$a                  # обращение к переменной a
$USER				# обращение к переменной окружения
b="a string"        # Внутренние пробелы должны находиться в кавычках.
c="a string and $b" # При присваивании допускается выполнять подстановку
d=$(pwd)  			# Результат выполнения команды.
d=`pwd`				# Тоже - результат выполнения команды.
e=$((5 * 7))        # Подстановка результата арифметического выражения.
f="\t\ta string\n"  # Экранированные последовательности, такие как \t \n
a=5 b="hui"         # сразу несколько переменных
${myvar}            # {} -можно огораживать, избегать путанницы где-то
                      например a="foo"; echo "${a}bar"
					  
--- Операторы ---
# в Bash можно использовать только целые числа, для дробных - bc.
# 9223372036854775807 максимальное число.
$(($x+2))	            # все матем и побитовые операции пишем в (())
+ -                     # унарные 
+ - * / % ** ++ --      # арифметические
= += -= *= /= %= **=    # присваивание
>> << & | ^ ~           # битовые
== > < != >= <=         # сравнение
$$ || !                 # логические
выражение1?выр2:выр3    # тренарный оператор, если 1 истино то 2, иначе 3

--- Числа ---
23              # число в 10-чной системе
023             # 19 восьмеричная система
0xFF            # 255 шеснадцатиричная система
основание#число # система по основанию # $((2#101)) - 5

--- Строки ---
foo="" foo= foo=''	# пустые строки
echo ${foo:-"hui"}  # при попытке обращения к пустой переменной выведет хуй
echo ${foo:="bar"}  # если переменная пустая, то присвоить bar
echo ${foo:?"ext"}  # если пустая, то выведет ext в стдерр и выйдет с кодом 1
echo ${foo:+"pls"}  # если пустая, то ничего не выведет, 
                      есди не пустая выведет pls, а значение не изменится
${!префикс*}        # выводят все имена переменных начинаю-ся с префикса
${!префикс@}          ${!BASH*} или ${!BASH@} -выведет кучу переменных
$(#строка)          # если параметр строкa - вернет длину строки,
                      если * или @ - вернет число позиционных параметров
${строка:смещ:длин} # срез строки от смещ до длин, если длин нет тотдо конц
${строка#шаблон}    # *. - удаляет все до первого совпадения с шаблоном и шаб
${строка##шаблон}   # -удаляет все до последнего совпад с шаблоном например /
${строка%шаблон}    # то же как и # только с конца строки
${строка%%шаблон}   # тожк чтоти ## только с конца строки

${параметр/шаблон/строка}  # если в параметре нацден шаблон - замена на строку 1-ое
${параметр//шаблон/строка} # вто же, но во всей строке
${параметр/#шаблон/строка} # то жк но начало
${параметр/%шаблон/строка} # то же но конец

--- Ветвление if-else ---
if condition; then		    # условие 
    code
elif condition2; then       # доп проверки
    code
else                        # иначе
    code
fi                          # end if
Examples:
if grep 'ivar' /etc/passwd  # true если grep вернет какие либо строки
if [ -d /etc ] && [ -n $1 ] # combine tests using AND (&&) or OR (||)
if [ $1 -lt 1024 ]          # numbers comparsion
if (($1 < 1024))            # the same numbers comparsion

--- Сравнение чисел ---
        выражение             
--------------+--------------+
test и []     | (())         | true
--------------+--------------+------------
num1 -eq num2 | num1 == num2 | числа равны
num1 -ne num2 | num1 != num2 | числа не равны
num1 -le num2 | num1 <= num2 | меньше или равно
num1 -lt num2 | num1 < num2  | меньше
num1 -ge num2 | num1 >= num2 | больше или равно
num1 -gt num2 | num1 > num2  | больше

--- Сравнение строк ---
выражение            | истино если:
---------------------+-----------
string               | строка не пустая
-n string            | длина строки больше 0
-z string            | длина строки = 0
string1 == string2   | строки равны
string1 != string2   | строки не равны
string1 > string2    | строка1 больше в алфавитном порядке
string1 < string2    | строки1 меньше в алыавитном порядке
string =~ ^-?[0-9]+$ | строка соотв-т регвыр, только для [[]]
string == *.mp3      | сопоставление с шаблоном wildcards, для [[]]

--- Скобки ---
()      Командная группа. Команды будут вып по порядку, в новых подоболочках.
        $(cmd) эквивалентна `cmd`.
        Используется для инициализации массива. 
        Example: $(pwd)             # вызвать команду pwd
                 array=(a b c d)    # иниц массив
(())    ((aexp)) Вычисл результат арифм выр: если 0 - false -> код возврата 1,
        если не 0 - true -> код возврата 0.
        Example: ((12)) - true --> 0.
                 ((0)) - false --> 1.
        ((lexp)) Вычисл результат логич выр: если false -> код возврата 1,
        если true -> код возврата 0.
        Example: ((0>12)) - false --> 1
                 ((0<12)) - true --> 0
        $((exp)) Можно использовать любое выражение и операторы, которое
        соответствуют правилам работы языка C, включая тернарный оператор.
        При использовании чисел отличных от 10-чной сист исч они автоматически
        будут преобразованы к десятичной системе исч. Также не обязательно
        использовать знак '$' в переменных.
        Example: ((x+=3)) Переопределить значение переменной 'x'.
                 ((++x < 120)) Сначала увелич x на 1, затем сравниваем
[]      Внутренние команды bash, эквивалентные командам test, сравнения,
        тест файла, test -e ./file эквивалентен [ -e ./file ].
        '[' - команда /usr/bin/[ 
        test - команда /usr/bin/test
        Используется как часть рег выр для описания диапазона совпадающих симв.
        Также используется для указания индексов в массивах.
        Example: [ "$1" -eq "Ivan" ]
                 arr[1]=12
[[]]    

--- test и различные проверки и сравнения ---
test expression     # любое выражение из таблицы ниже
[ expression ]      # аналогично
test и [] возвращает результат выражения
выражение       | истино если:
----------------+---------------------------------------
file1 -ef file2 | жесткие ссылки на один и тот же объект
file1 -nt file2 | 1 новее 2
file1 -ot file2 | 1 старше 2
        -e file | файл существует
        -b file | файл блочного устр-ва
        -c file | файл символьного устр-ва
        -f file | простой файл
        -d file | каталог
        -L file | символическая ссылка
        -G file | файл пртнадлежит действующей группе
        -O file | файл принадлежит дкйствующему пользователю
        -p file | именованый канал
        -S file | сокет
        -r file | атрибут чтение     \
        -w file | атрибут запись      - для текущего польз-ля
        -x file | атрибут выполнение /
        -u file | атрибут setuid
        -g file | атрибут setgid
        -s file | атрибут sticky bit

bc  # калькулятор в баш

# массивы ----------------------------------------------------------------
a[1]=foo        # создать массив а и присвоить 1-му л значение фуу
                # массивы нумеруются с нуля
declare -a a    # также создать массив а
a=(1 2 3 4)     # присвоитб сразу много щначений
a=([0]=a [1]=3) # множеств-е присваивание по индексу
echo $a{[1]}    # показат , скобки {  }оoбязательны
for i in ${a[*]}; do echo $i; done  # вывод всех эл массива
a=("a" "b" "c d e")
${a[*]}    # "a" "b" "c" "d" "e"
${a[@]}    # "a" "b" "c" "d" "e"
"${a[*]}"  # "a b c d e"
"${a[@]}"  # # "a" "b" "c d e"

${#a[@]}   # кол-во эл-в в массиве
${#a[100]} # длина элемента
"${!a[@]}" # индексы массива которы присвоины переменные
a+=(9)     # добавление нового значения в конец массива

a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort)) # сортировка мас-ва
unset a    # удалить массив а
unset a[0] # удалить 0-й индекс


# функции, 2 вида создания, эквивалентные:
function myfunc {  # 1 вариант
    commands
    return
}
myfunc () {        # 2 вариант
    commands
    return
}
myfunc              -вызов ыункции
myfunc p1 p2 p3     -вызов с параметрами

test -e "$file"  [ -e "$file" ]  [[ -e "$file" ]] # ковычки обязательны, чтобы
    при проверке гарантировано использовалась пустая строка, при отсут-ии файла

# test "str1" ">" "str2" # в команде тест знаки в ковычки,
# [ "str1" > "str2" ]  [[ "str" > "str2" ]]

# test "$num" -eq "$num2"  [ "$num" -eq 10 ] (( "$num" == 10 ))
    
# объединение выражений с помощью логических выражениц
    операция  test []  [[]] (())
       И      -a        &&
      ИЛИ     -o        ||
      НЕ      !         !


# ветвление с помощью операторов управления, подобно && || в [[]]
  команда1 && команда2  # ком1 вып-ся всегда, если true, то вып-ся ком2
  команда1 || команда2  # ком1 вып-ся всегда, если false, то вып-ся ком2
  [ -e myfile ] && cat myfile  # если есть мойфайл то открыть его в кат
  cat myfile || touch myfile   # если есть фацл - открыть, если нет -создать

# case ветвление
case слово in 
    [шаблон[|шаблон]...) команды;;]...
esac

case $REPLY in
    0) echo "program terminsted"
       exit
       ;;
    # используются wildcards, любые шаблоны
    1|2) commands;;
    *.txt) commands;;
    [abs][1-9]) commands;;
    [[:alpha:]]) commands;;
    ???) commands;;
    *) commands;;  # все что не вошло под шаблоны
esac

# read, чтение строки из стдин
read [-параметры] [переменная...] если переменная не указана то сохр в REPLY
  параметры:
    -a массив       - сохр ввод в массив с 0-го индекса
    -d разделмтель  - признак конца ввода, по умолч ентер- \n
    -e              - исп Readline, ввод как в ком строке
    -n число        - читает n-симврлов, а не всю строку
    -p приглашение  - показывать указанное приглашеник к вводу
    -r              - как в питоне строка без поддержки \n\t...
    -s              - sikent режим, не видно что вводишь
    -t секунды      - по истеч времени вернется ненулевое знач
    -u дескриптор   - произвести ввод из файла, а не из стдин
  множество переменных read var1 var2 var3 - пишем через пробел a b c
  REPLY -если не указаны переменные тр сохр сюда
  IFS=":" read var1 var2 var3 <<< /etc/passwd  -временный разделитель ":"
  <<< -оператор встроенная строка, подобно встр документу, но короче-до кон строки

# циклы---------------------------------------------------------------------------
while условие; do команды; done  # пока условие true(0) цикл выполняется
continue # новая итерация
break    # выход из цикла
until    - цикл типа while, только вып-ся условие false
while read distro version release; do  printf "Distro: %s\tVersion: %s\tReleased: %s\n" $distro $version $release; done < distros.txt  
#чтение из файла с пом read, присваивание, вывод
  -либо можно передать по конвейеру: файл|while read var;do ... ; done

# классический for
for переменная [in слова]; do
    команды
done
# без слов обрабатываются по умолчанию позиционные аргументы
for i in a b c d; do...
for i in {a..d}; do...
for i in *.txt; do... # перебор ыацлов тхт

# for в стиле СИ
for ((i=0;i<5;i++)); do
    commands
done

# встроенный метод трассировки, указываем в шебанг +x
#!/bin/bash +x  # будет показано подробное выполнение кода, знак + показывает
  трассировочную информацию, знак + храеится в PS4, ее можно изменить:
  export PS4='$LINENO + '  # поменяли на номер строки +
  set -x  # включение трассировки в коде сценария
  set +x  # выключение трассировки, это можно присеняь прямо в скриптах в коде

# позиционные параметы
# передавая программе аргументы в ком строке их можно использовать так:
    $0    -всегда путь и название программы которая запустилась
    $1-9  -любые аргументы ком строки
    ${10} -если параметров больше 9 - добавляем{}
    $#    -кол-во параметров

    # пример myscript "a" "b" "c d e"
    $*    -все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    $@    -все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    "$*"  -все аргументы в одной строке через пробелы "a b c d e"
    "$@"  -все аргументы, в виде отдельных строк с уч пробелов "a" "b" "c d e"

shift    -команда которая убирает параметр $1, а все последующие сдвигает на одно
          место к началу, $# становится на 1 меньше, $0 всегда неизменен
basename -команда удаляющая начальную часть пути к файлу
./myscript.sh *  -передать все что есть в тек директории в виде парам-в
# в функциях те же правила, $0 -всегда и везде имя скрипта, $1+ -парам ф-ии
    
# Группы команд и подоболочка ------------------
# группа команд вып-ся в текущей оболочке, а подоболочка - в дочерней(копия),
 после выполнения подоболочки все ее окружение и данные уничтожаются
| -всегда выполняется в подоболочке и все переменные уничтожаются после выхода
{ com1; com2; com3; }   # группа команд, с пробелами рядом со скобками и ; в к-це
(com1; com2; com3)      # подоболочка
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt  # перенап-е
(ls -l; echo "Listing of foo.txt"; cat foo.txt) > output.txt
# подстановка процессов
<(список команд)    # для процессов отправляющих рез-ты на стдаут
>(список команд)    # для процессов принимающих данные на стдин
# подстановка процесов интер-ет вывод подоболочки как обычный файл
  cat <(echo "foo")  -передается как типо это файл, заменяет
  echo <(echo "foo") -выведет /dev/fd/63 -файл где сохр эхо
  read < <(echo "foo")  -сохранит foo в REPLY
# подстановка проц-ов часто исп в циклах с read:
while read myvar1 myvar2; do
    cat <<- EOF
            var1: $myvar1
            var2: $myvar2
    EOF
done < <(ls -l|tail -n +2) -вывод подоб-ки напрвл-ся на стдин цикла(read) 

# Ловушки - сигналы исп-ся процессом
trap команда сигнал [сигнал...]
trap echo "I'm the command!" SIGINT SIGTERM -при попытке прервать сценарий,
                                             выводит эхо
  в кач-ве команды часто используют вызов функции под разные сигналы

# Асинхронное выполнение
wait pid  # приостановка процесса, пока не завершится pid(какой-то фон.проц) 

# Именованные каналы
mkfifo pipe1   - сознание именованного канала
ls -l > pipe1  - перенаправление в им канал
cat < pipe1    - разб-ка канала и принятие данных(можно в другом терминале)
