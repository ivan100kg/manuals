# GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu)

--- Директории с программами и сценариями ---
/bin            # бинарные файлы исп системой
/sbin           # бинарные файлы исп системой с правами суперпользователя
/usr/bin        # общисистемные бинарные файлы
/usr/sbin       # общисистемные бинарные файлы с правами суперпользователя
/usr/local/bin  # для ваших сценариев и программ
/usr/local/sbin # для установленных с помощью пакет менеджера
~/bin			# для ваших сценариев и программ(создают самостоятельно)

--- Правила писания в баш скриптах ---
#!/bin/bash     # shebang/шебанг which bash(какой bash используется)
# comment       # строки начинающиеся с # или пустые строки - игнорируются
pwd				# the shell commands are entered one per line.
pwd; ls			# two commands have to be separated with semicolon.
echo "pri\		# \ исп в сценариях для переноса длинных строк
vet"
\n \$ \\ \( \) 	# экранирование спецсимволов
""  			# экранирование текста, можно использовать подстановку $
''  			# полное экранирование, что напишешь то и выведет
;   			# разделитель более 1-ой инструкций в одной строке

--- Код возврата ---
# любой сценарий, ф-я или команда возвращает код завершения
0               # успешное завершение/true
1-255           # ошибка/false
echo $?	        # выводит последний код завершения

--- Пользовательские переменные ---
a="hi"          # Присвоит переменной a строку "hi".
$a              # обращение к переменной a
$USER			# обращение к переменной окружения
b="a string"    # Внутренние пробелы должны находиться в кавычках.
c="$b"          # При присваивании допускается выполнять подстановку
d=$(pwd)  		# Результат выполнения команды.
d=`pwd`			# Тоже - результат выполнения команды.
e=$((5 * 7))    # Подстановка результата арифметического выражения.
f="\t\ta str\n" # Экранированные последовательности, такие как \t \n
a=5 b="hui"     # сразу несколько переменных
${myvar}        # {} -можно огораживать, избегать путанницы где-то
                  например a="foo"; echo "${a}bar"
					  
--- Операторы ---
# в Bash можно использовать только целые числа, для дробных - bc.
# 9223372036854775807 максимальное число.
+ -                     # унарные 
+ - * / % ** ++ --      # арифметические
= += -= *= /= %= **=    # присваивание
>> << & | ^ ~           # битовые
== > < != >= <=         # сравнение
$$ || !                 # логические
выражение1?выр2:выр3    # тренарный оператор, если 1 истино то 2, иначе 3

--- Числа ---
23                  # число в 10-чной системе
023                 # 19 восьмеричная система
0xFF                # 255 шеснадцатиричная система
основание#число     # система по основанию # $((2#101)) - 5

--- Строки ---
foo="" foo= foo=''	# пустые строки
echo ${foo:-"hui"}  # при попытке обращения к пустой переменной выведет хуй
echo ${foo:="bar"}  # если переменная пустая, то присвоить bar
echo ${foo:?"ext"}  # если пустая, то выведет ext в стдерр и выйдет с кодом 1
echo ${foo:+"pls"}  # если пустая, то ничего не выведет, 
                      есди не пустая выведет pls, а значение не изменится
${!префикс*}        # выводят все имена переменных начинаю-ся с префикса
${!префикс@}          ${!BASH*} или ${!BASH@} -выведет кучу переменных
$(#строка)          # если параметр строкa - вернет длину строки,
                      если * или @ - вернет число позиционных параметров
${строка:смещ:длин} # срез строки от смещ до длин, если длин нет тотдо конц
${строка#шаблон}    # *. - удаляет все до первого совпадения с шаблоном и шаб
${строка##шаблон}   # удаляет все до последнего совпад с шаблоном например /
${строка%шаблон}    # то же как и # только с конца строки
${строка%%шаблон}   # тожк чтоти ## только с конца строки
${пар/шаб/строка}   # если в параметре нацден шаблон - замена на строку 1-ое
${пар//шаб/строка}  # вто же, но во всей строке
${пар/#шаб/строка}  # то жк но начало
${пар/%шаб/строка}  # то же но конец

--- Команда test ---
test expression     # любое выражение из таблицы ниже,
                      test возвращ результат выражения 0(true) или 1(false)
                      /usr/bin/test - расположение test.
выражение           | истино если:
--------------------+---------------------------------------
<path1> -ef <path2> | жесткие ссылки на один и тот же объект
<path1> -nt <path2> | 1 новее 2
<path1> -ot <path2> | 1 старше 2
          -e <path> | файл существует
          -b <path> | файл блочного устр-ва
          -c <path> | файл символьного устр-ва
          -f <path> | простой файл
          -d <path> | каталог
          -L <path> | символическая ссылка
          -G <path> | файл пртнадлежит действующей группе
          -O <path> | файл принадлежит дкйствующему пользователю
          -p <path> | именованый канал
          -S <path> | сокет
          -r <path> | атрибут чтение     \
          -w <path> | атрибут запись      - для текущего польз-ля
          -x <path> | атрибут выполнение /
          -u <path> | атрибут setuid
          -g <path> | атрибут setgid
          -s <path> | атрибут sticky bit

--- Скобки ---
()      Командная группа. Команды будут вып по порядку, в новых подоболочках.
        $(cmd) эквивалентна `cmd`.
        Используется для инициализации массива. 
        Example: $(pwd)             # вызвать команду pwd
                 array=(a b c d)    # иниц массив
(())    ((aexp)) Вычисл результат арифм выр: если 0 - false -> код возврата 1,
        если не 0 - true -> код возврата 0.
        Example: ((12)) - true --> 0.
                 ((0)) - false --> 1.
        ((lexp)) Вычисл результат логич выр: если false -> код возврата 1,
        если true -> код возврата 0.
        Example: ((x>12)) - false --> 1, переменные можно исп без $
                 ((x<12)) - true --> 0
        $((exp)) Можно использовать любое выражение и операторы, которое
        соответствуют правилам работы языка C, включая тернарный оператор.
        При использовании чисел отличных от 10-чной сист исч они автоматически
        будут преобразованы к десятичной системе исч. 
        Также не обязательно использовать знак '$' в переменных.
        Example: $((x % 3))     команда --> return остаток от деления
                 ((x+=3))       переопределить значение переменной 'x'.
                 ((x < 120))    сравниваем, пододит для условий
[]      Внутренние команды bash, эквивалентные командам test, сравнения,
        тест файла, test -e ./file эквивалентен [ -e ./file ].
        '[' - команда /usr/bin/[ 
        ']' - это аргумент команды '[', который означает конец аргументов.
        Используется как часть рег выр для описания диапазона совпадающих симв.
        Также используется для указания индексов в массивах.
        Example: [ "$1" -eq "Ivan" ]
                 arr[1]=12
[[]]    Является расширением Bash. 
        '[[' - ключевое слово
        Позволяет использовать круглые скобки и логические операторы 
        !, && и || в скобках для объединения подвыражений.
        Имеет оператор соответствия =~ регулярных выражений.
        Строковые переменные можно исп без ковычек $mystr.
        Можно для сравнения вместо '==' использовать '='.
        Example: [[ -f $file1 && ( -d $dir1 || -d $dir2 ) ]]        # [[]]
                 [ -f "$file1" -a \( -d "$dir1" -o -d "$dir2" \) ]  # []
Diff    test -e "$file"  [ -e "$file" ]  [[ -e $file ]] # ковычки переменных
        [ "$str1" /> "$str2" ]  [[ $str > $str2 ]]      # экранирование < > 
        test $x -eq $y  [[ $x == $y ]]

--- Сравнение чисел ---
        выражение             
--------+--------+-----
test [] | (())   | true
--------+--------+------------
x -eq y | x == y | числа равны
x -ne y | x != y | числа не равны
x -le y | x <= y | меньше или равно
x -lt y | x < y  | меньше
x -ge y | x >= y | больше или равно
x -gt y | x > y  | больше
--------+--------+-------

--- Сравнение строк ---
[ выражение ]        | истино если:
---------------------+-----------------
"string"             | строка не пустая
-n "string"          | длина строки больше 0
-z "string"          | длина строки = 0
"str1" = "str2"      | строки равны '=' или '==' без разницы для [] [[]]
"str1" != "str2"     | строки не равны
string1 > string2    | строка1 больше в алфавитном порядке, для [[]]
string1 < string2    | строки1 меньше в алфавитном порядке, для [[]]
"str1" \> "str2"     | строка1 больше в алфавитном порядке, для test, []
"str1 "<" "str2"     | строки1 меньше в алфавитном порядке, для test, []
string =~ ^-?[0-9]+$ | строка соотв-т регвыр, только для [[]]
string == *.mp3      | сопоставление с шаблоном wildcards, для [[]]
---------------------+---------------------------------------------
    
--- Логические объединения выражений ---
операция | test, [] | [[]] (())
---------+----------+----------
   И     | -a       | &&
  ИЛИ    | -o       | ||
  НЕ     | !        | !
  -------+----------+--

--- Ветвление ------------------------------------------------------------------
--- if-else ---
if condition; then		    # условие 
    code
elif condition2; then       # доп проверки
    code
else                        # иначе
    code
fi                          # end if
Examples:
if grep 'ivar' /etc/passwd  # true если grep вернет какие либо строки
if [ -d /etc ] && [ -n $1 ] # combine tests using AND (&&) or OR (||)
if [ $x -lt 1024 ]          # numbers comparsion
if ((x < 1024))             # the same numbers comparsion

--- case ---
case str in 
    [шаблон[|шаблон]...) команды;;]...
esac
Example:
case $REPLY in
    0) echo "program terminsted"
       exit
       ;;
    # используются wildcards, любые шаблоны
    1|2) commands;;
    *.txt) commands;;
    [abs][1-9]) commands;;
    [[:alpha:]]) commands;;
    ???) commands;;
    *) commands;;  # все что не вошло под шаблоны
esac

--- Ветвление, операторы управления ---
command1 && command2  # если com1 вернет true, то пробовать выполнить com2
command1 || command2  # если com1 не вернет true, то пробовать вып com2
Examples:
[ -e myfile ] && cat myfile  # если есть мойфайл то открыть его в кат
cat myfile || touch myfile   # если есть файл - открыть, если нет -создать

# массивы ----------------------------------------------------------------
a[0]=foo        # создать массив а и присвоить 1-му л значение фуу
                # массивы нумеруются с нуля
declare -a a    # также создать массив а
a=(1 2 3 4)     # присвоитб сразу много щначений
a=([0]=a [1]=3) # множеств-е присваивание по индексу
echo ${a[0]}    # показат , скобки {  }оoбязательны
for i in ${a[*]}; do echo $i; done  # вывод всех эл массива
a=("a" "b" "c d e")
${a[*]}    # "a" "b" "c" "d" "e"
${a[@]}    # "a" "b" "c" "d" "e"
"${a[*]}"  # "a b c d e"
"${a[@]}"  # # "a" "b" "c d e"

${#a[@]}   # кол-во эл-в в массиве
${#a[100]} # длина элемента
"${!a[@]}" # индексы массива которы присвоины переменные
a+=(9)     # добавление нового значения в конец массива

a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort)) # сортировка мас-ва
unset a    # удалить массив а
unset a[0] # удалить 0-й индекс

# функции, 2 вида создания, эквивалентные:
function myfunc {  # 1 вариант
    commands
    return
}
myfunc () {        # 2 вариант
    commands
    return
}
myfunc              -вызов ыункции
myfunc p1 p2 p3     -вызов с параметрами

--- IFS ---
Internal Field Separator, переменная окружения - разделитель полей.
Разделители по умолчанию - ' ', '\t', '\n' (любой из этих).
Bash встречая эти символы, считает, что перед ним следующий элемент списка.
IFS=$'\n'	- оптимально для чтения файлов.
IFS=":" 	- удобно для /etc/passwd.

--- read, чтение строки из стдин ---
read [-параметры] [переменная...] если переменная не указана то сохр в REPLY
параметры:
    -a массив       - сохр ввод в массив с 0-го индекса
    -d разделитель  - признак конца ввода, по умолч ентер- \n
    -e              - исп Readline, ввод как в ком строке
    -n число        - читает n-симврлов, а не всю строку
    -p приглашение  - показывать указанное приглашеник к вводу
    -r              - как в питоне строка без поддержки \n\t...
    -s              - silent режим, не видно что вводишь
    -t секунды      - по истеч времени вернется ненулевое знач
    -u дескриптор   - произвести ввод из файла, а не из стдин
переменная:
	read var1		- сохранит ввод в эту переменную
	read var1 var2  - неск перем, 
	$REPLY 			- если не указаны переменные то сохр сюда

Examples:	
read -p "Enter your name: " name		-аналогична двум командаам ниже
echo -n "Enter your name: "
read name
read -p "Enter your name: " first last	-несколько переменных (исп пробел)
read -s -p "Enter your password: " pass	-скрытый ввод пароля  
<<< -оператор встроенная строка, подобно встр документу, но короче-до кон стр
Example: чтение файла
cat myfile | while read line; do
	echo $line
done
echo "Finished"

--- while ---
while condition; do # пока условие true(0) цикл выполняется
    commands
done                # end loop
continue 			# новая итерация
break    			# выход из цикла
until    			# цикл типа while, только вып-ся условие false
Examples:
while [ $repeat -gt 0 ]; do {
    printf "$string"
    repeat=$((repeat - 1))
}
done
while read distro version release; do 
	printf "Distro: %s\tVersion: %s\tReleased: %s\n" $distro $version $release
done < distros.txt  
#чтение из файла с пом read, присваивание, вывод
  -либо можно передать по конвейеру: файл|while read var;do ... ; done

--- for ---
for i in <list>; do         # <list> список аргументов через пробел
    commands    
done
Examples:
file="/home/ivar/myfile"
for i in $(cat $file);do    # перебор строк в файле
    echo $i
done > myfile.txt			# перенаправление вывода в файл(для примера)
for i; do                   # обрабатываются по умолч позиц аргументы ком строки
for i in a b c d; do        # перебор строк разделенных пробелом
for i in {a..d}; do         # перебор символов из диапазона a-d включительно
for i in *; do          	# перебор файлов в тек дир можно с полным путем
for i in ~/dir/*.sh; do		# перебор файлов .sh с полными путями

--- for в стиле СИ ---
for ((i=0;i<5;i++)); do
    commands
done

# встроенный метод трассировки, указываем в шебанг +x
#!/bin/bash +x  # будет показано подробное выполнение кода, знак + показывает
  трассировочную информацию, знак + храеится в PS4, ее можно изменить:
  export PS4='$LINENO + '  # поменяли на номер строки +
  set -x  # включение трассировки в коде сценария
  set +x  # выключение трассировки, это можно присеняь прямо в скриптах в коде

--- Параметы ком строки---
# передавая программе аргументы в ком строке их можно использовать так:
    $0    	-всегда путь и название программы которая запустилась
    $1-9  	-любые аргументы ком строки
    ${10} 	-если параметров больше 9 - добавляем{}
    $#    	-кол-во параметров
	${!#}	-последний параметр
# пример myscript "a" "b" "c d e"
    $*    	-все аргументы, в виде одной строки  "a b c d e"
    $@    	-все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    "$*"  	-все аргументы в одной строке через пробелы "a b c d e"
    "$@"  	-все аргументы, в виде отдельных строк с уч пробелов "a" "b" "c d e"

shift    -команда которая убирает параметр $1, а все послед сдвигает на одно
          место к началу, $# становится на 1 меньше, $0 всегда неизменен.
		  
Example: перебор и вывод параметров
while [ -n "$1" ]; do
	echo "$1"
	shift
done
Example: как различать ключи и параметры
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "Found the -a option" ;;
		-b) echo "Found the -b option";;
		-c) echo "Found the -c option" ;;
		--) shift	# ключи и параметры можно разделить с помощью "--"
		break ;;
		*) echo "$1 is not an option";;
	esac
	shift	# сдвиг, по идее дальше могут идти параметры
done
count=1
for param in $@; do	# вывод нумерованных параметров
	echo "Parameter #$count: $param"
	count=$(( $count + 1 ))
done

basename -команда удаляющая начальную часть пути к файлу
./myscript.sh *  -передать все что есть в тек директории в виде парам-в
# в функциях те же правила, $0 -всегда и везде имя скрипта, $1+ -парам ф-ии

--- Ключи ---
-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.

    
# Группы команд и подоболочка ------------------
# группа команд вып-ся в текущей оболочке, а подоболочка - в дочерней(копия),
 после выполнения подоболочки все ее окружение и данные уничтожаются
| -всегда выполняется в подоболочке и все переменные уничтожаются после выхода
{ com1; com2; com3; }   # группа команд, с пробелами рядом со скобками и ; в к-це
(com1; com2; com3)      # подоболочка
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt  # перенап-е
(ls -l; echo "Listing of foo.txt"; cat foo.txt) > output.txt
# подстановка процессов
<(список команд)    # для процессов отправляющих рез-ты на стдаут
>(список команд)    # для процессов принимающих данные на стдин
# подстановка процесов интер-ет вывод подоболочки как обычный файл
  cat <(echo "foo")  -передается как типо это файл, заменяет
  echo <(echo "foo") -выведет /dev/fd/63 -файл где сохр эхо
  read < <(echo "foo")  -сохранит foo в REPLY
# подстановка проц-ов часто исп в циклах с read:
while read myvar1 myvar2; do
    cat <<- EOF
            var1: $myvar1
            var2: $myvar2
    EOF
done < <(ls -l|tail -n +2) -вывод подоб-ки напрвл-ся на стдин цикла(read) 

# Ловушки - сигналы исп-ся процессом
trap команда сигнал [сигнал...]
trap echo "I'm the command!" SIGINT SIGTERM -при попытке прервать сценарий,
                                             выводит эхо
  в кач-ве команды часто используют вызов функции под разные сигналы

# Асинхронное выполнение
wait pid  # приостановка процесса, пока не завершится pid(какой-то фон.проц) 

# Именованные каналы
mkfifo pipe1   - сознание именованного канала
ls -l > pipe1  - перенаправление в им канал
cat < pipe1    - разб-ка канала и принятие данных(можно в другом терминале)
