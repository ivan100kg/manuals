--- 8 часто используемых структур: ----
    Массив              Array           коллекции элементов одного типа [0][1][2][3]-подряд в оперативке   
    Динамический массив Dinamic Array   массив, размер которого может меняться Java ArrayList
    Список              List            динамический маасив, может менять размер
    Связный список      Linked List     односвязные, двухсвязные - ссылка на пред/след элемент
    Стек                Stack           LIFO элементы добавляются и удаляются с одного конца
    Очередь             Queue           FIFO элементы добавляются в конец а удаляются с начала
    Дерево              Tree            иерархические структуры данных, состоящие из узлов, 
                                        где каждый узел может иметь несколько дочерних узлов
    Граф                Graph           набор узлов (вершин), соединенных ребрами. 
                                        Они могут быть направленными или ненаправленными
    Префиксное дерево   Trie            каждая нода (узел) в trie представляет собой символ строки. 
                                        Корень дерева представляет пустую строку, 
                                        а дочерние узлы хранят символы, формирующие строки
    Хэш-Таблица         Hash Table      структуры данных, которые используют хэш-функции для вычисления 
                                        индекса, по которому будут храниться данные

--- Array/Массив ---
    Массив – это самая простая и наиболее широко используемая из структур. 
    Стеки и очереди являются производными от массивов.
    Каждому из них присваивается неотрицательное числовое значение – индекс, 
    который соответствует позиции этого элемента в массиве. Большинство языков 
    определяют начальный индекс массива как 0.

    Java: int[]

    Время выполнения операций:
    чтение      O(1)
    изменение   O(1)
   
    Существует два типа массивов:
                        0  1  2  3
    Одномерные массивы [ ][ ][ ][ ]          00  01  02  03
    Многомерные массивы (массивы массивов)  [  ][  ][  ][  ]
                                             10  11  12  13
                                            [  ][  ][  ][  ]
    Основные операции с массивами
    Get     - получение элемента.
    Update  - изменить значение ячейки 
    Size    - получение общего количества элементов в массиве.
    
    Применяются:
    В качестве блоков для более сложных структур данных
    Для хранения несложных данных небольших объёмов
    Для сортировки данных

--- Dinamic Array/Динамический массив ---
    Массив, размер которого может меняться

    [0][1][2][3][4]

    Java: ArrayList
    
    Основные операции с массивами
    Insert  - вставка.
    Get     - получение элемента.
    Update  - изменить значение ячейки
    Delete  - удаление.
    Size    - получение общего количества элементов в массиве.

    Время выполнения операций:
    чтение      O(1)
    изменение   O(1)
    вставка     O(n)
    удаление    O(n)

    Применяются:
    В качестве блоков для структур данных
    Для хранения неопределённого количества элементов

--- LinkedList/Связный список ---
    Связный список – это группа из узлов

    Java: LinkedList
         +------+  +-----+  +------+
        /        \/       \/        \
    [][0][]...[][1][]...[][2][]...[][3][]
     head                           tail
    
    В каждом узле содержатся:
    данные
    указатель или ссылка на следующий узел
    в двухсвязных списках - ссылка на предыдущий узел

    Типы связных списков:
    Однонаправленный
    Двунаправленный

    Основные операции со связными списками
    Insert  - вставка
    Get     - получение элемента
    Update  - изменить значение ячейки
    Delete  - удаление
    Size    - получение общего количества элементов в массиве

    Применяются:
    Для построения более сложных структур данных
    Для реализации файловых систем
    Для формирования хэш-таблиц
    Для выделения памяти в динамических структурах данных

--- Stack/Стеки ---
    LIFO (Last In First Out, последним пришел – первым ушел).
    Пример стека из реальной жизни – куча книг, лежащих друг на друге.

    | ^
    v |
    [3]
    [2]
    [1]
    [0]

    Java: Stack
    
    Основные операции со стеками
    Push    – вставка элемента наверх стека.
    Pop     – получение верхнего элемента и его удаление.
    isEmpty – возвращает true, если стек пуст.
    Top     – получение верхнего элемента без удаления.

    Применяются:
    Для реализации рекурсии
    Для вычислений постфиксных значений
    Для временного хранения данных, например истории запросов или изменений

--- Queue/Очереди ---
    FIFO (First in First Out, первым пришел – первым ушел).
    Пример этих структур в реальной жизни – очереди людей в билетную кассу.

    <--[0][1][2][3]<--

    Основные операции с очередями
    Enqueue – вставка в конец.
    Dequeue – удаление из начала.
    isEmpty – возвращает true, если очередь пуста.
    Top     – получение первого элемента.

    Применяется:
    Для реализации очередей, например на доступ к определённому ресурсу.
    Для управления потоками в многопоточных средах.
    Для генерации значений.
    Для создания буферов

--- Set/Множество ---
    Неупорядоченная коллекция, содержит уникальные элементы

    Java: HashSet

    Применяется:
    Для поддержания множества уникальных элементов
    Для хранения данных, которые не нужно сортировать
    Для сравнения, объединения наборов данных и других операций с ними

--- Map/Карта/Словарь/Ассоциативный массив ---
    Данные здесь хранятся в паре «ключ/значение», причем каждый ключ уникален, 
    а вот значения могут повторяться
    
    [k1] -> [val1]
    [k2] -> [val2]
    [k3] -> [val2]

    Java: HashMap

    Применяется:
    Для быстрого поиска данных.
    Для создания баз, в которых нужно хранить уникальное соответствие между двумя 
    множествами значений. Их помещают в ключ, и структура проверяет, чтобы ключ не повторялся

--- Деревья ---
    Дерево – это иерархическая структура данных, состоящая из вершин/узлов и ребер
    У каждого узла могут быть один или несколько дочерних узлов и только один родитель, 
    то есть они расходятся, как ветви дерева

                [8]
              /     \
            [3]    [10]
            / \     /
          [1] [6] [19]


    Типы деревьев:
    бинарное дерево         - узел имеет не более двух дочерних узлов
    бинарное дерево поиска  - для каждого узла значение левого < правого
    N-арное дерево          - до N дочерних узлов
    сбалансированное дерево: 
        дерево AVL          - логарифмическое время поиска
        красно-чёрное дерев - логарифмическое время поиска
    
    Они похожи на графы, но есть одно
    важное отличие: в дереве не может быть цикла
    Деревья широко используются в искусственном интеллекте и сложных 
    алгоритмах для обеспечения эффективного механизма хранения данных.


--- Графы ---
    Это структура данных, состоящая из узлов (вершин) и ребер, которые соединяют пары узлов

    Типы графов:
    Неориентированный (ребра не имеют направление)
    Ориентированный (ребра имеют направление)
    Взвешанный (ребра имеют веса)
    Невзвешанный (ребра не имеют веса)

    Компоненты графа:
    Вершины (узлы): основная единица графа
    Ребра: связи между вершинами. У ориентированных графов ребра имеют направление
    Вес: числовое значение, которое может быть присвоено ребрам в взвешенных графах

    В языке программирования графы могут быть представлены в двух формах:
    Список смежности
    Матрица смежности

    Общие алгоритмы обхода графов:
    В ширину
    В глубину

    Список смежности:
    Это массив списков, где каждый индекс представляет вершину, а список содержит все соседние вершины
    Java:  HashMap<Integer, List<Integer>> adjList
    
--- Префиксное дерево ---
    Префиксные деревья (tries) – древовидные структуры данных, эффективные 
    для решения задач со строками. Они обеспечивают быстрый поиск и 
    используются преимущественно для поиска слов в словаре, автодополнения 
    в поисковых системах и даже для IP-маршрутизации.

--- Хеш-Таблица ---
    Хеширование – это процесс, используемый для уникальной идентификации 
    объектов и хранения каждого из них в некотором предварительно вычисленном 
    уникальном индексе – ключе. Итак, объект хранится в виде пары 
    ключ-значение, а коллекция таких элементов называется словарем. 
    Каждый объект можно найти с помощью его ключа. Существует несколько 
    структур, основанных на хешировании, но наиболее часто используется 
    хеш-таблица, которая обычно реализуется с помощью массивов.

    Производительность структуры зависит от трех факторов:
    функция хеширования;
    размер хеш-таблицы;(коэф переполнения идеально не больше 0.7)
    метод обработки коллизий.(попадание эл-ов в одну ячейку)