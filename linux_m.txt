# Linux

# общее понимание ------------------------------------------------------------+
Kernel/ядро — основа операционной системы. Оно непосредственно взаимодействует 
  с аппаратурой. С ядром можно взаимодействовать с помощью приложений — 
  с помощью предоставляемого приложениям программного кода.
Linux is kernel (ядро ОС).
Дистрибутив включает ядро и доп компоненты.
GNU — операционная система типа Unix, программы которой свободны (cat, grep, 
  awk, bash унаследованы от Unix)

командная оболочка # программа принимающая команды от пользователей, 
                     передает системе, it's bash или shell.
терминал           # файл устройства реализующий команды чтения-записи.
консоль            # терминал в физическом смысле. Терминалы TTY, переключ
                     между ними ctrl+alt+F(n)
эмулятор терминала # программы обеспеч доступ к терминалу. (Xterm, tmux…)
командная строка   # интерфейс, где пользователь вводит команды

# загрузка системы -----------------------------------------------------------+
процессы загрузки:
1.  включить
        блок питания самотестируется и при + тесте подает RESET на CPU
2.  загрузить BIOS/UEFI из NVRAM
        процессор выполняет код стартового блока хранящ-ся в NVRAM
3.  собрать сведения об аппаратуре
        проверка CPU, напряжение, температура, частота шины ...
        проверка ПЗУ(NVRAM)
4.  выбрать устройство для запуска(диск, сеть..)
        вкладка boot
5.  идентифицировать системный раздел EFI
        BIOS предполаг что загрузочное устройсто начинается с записи
        называемой MBR, эта запись содержит первичный загрузчик bootblock и
        простую таблицу разделов диска. Далее он загр 2-ой загрузчик.
        UEFI включ в себя GPT, микропрограмма обращ к GPT и идентиф ESP
        далее загружает из раздела второй загр. UEFI может обойтись без
        второго загручика и запускать ОС.
        efibootmgr  # утилита позволяет изиенить порядок загрузки(выбор устр)
6.  Загрузить загрузчик (например GRUB)
        GRUB - GRand Unified Boot.
7.  Определить какое ядро загрузить
8.  Загрузить ядро
9.  Создать структуры данных ядра
10. Запустиь init/systemd как PID 1
11. Выполнить сценарии запуска
12. Запустить систему

efibootmgr  #   UEFI утилита позволяет изиенить порядок загрузки(выбор устр)
# GRUB --
позволяет указать параметры: загрузочное ядро, режим работы для загрузки
/boot/grub/grub.cfg # config file, не редактировать
/etc/default/grub   # общие пар-ры конфигурации, редактируем тут
/etc/grub.d         # различные конфигурации
grub-mkconfig       # генерировать конф файл после изменений в grub настр-х
update-gruЬ         # то же что и выше
командная строка GRUB - нажать "c" на экране загрузки
команды GRUB:
    boot    Загружает систему из указанного образа ядра
    help    Получает интерактивную помощь для команды
    linux   Загружает ядро Linux
    reЬoot  Перезагружает систему
    search  Поиск устройств по файлу, метке файловой системы или UUID
    usb     Проверка поддержки USB
параметры загрузки ядра Linux: (до перезагрузки)
    debug           Включает отладку ядра
    init=/Ьin/bash  Запускает только оболочку bash
    root=/dev/foo   Инструктирует ядро исп /dev/foo в кач корневого устройства
    single          Загрузка в однопольэовательском режиме
постоянные изменения загрузки ядра:
    /etc/grub.d/40-custom или /etc/default/grub # ищем тут ->
    GRUB_CMDLINE_LINUX  # нужная переменная

# Демоны управления системой -------------------------------------------------+
init - основной главный демон управления системой
основная задача - запуск комлектов служб и демонов в нужный момент режимы, в 
которых может работать система:
    однопользовательский режим: минимальный набор, ком строка
    многопользовательский режим: обычный режим с граф интерфейсом
    режим сервера: как многопол только без граф интерфейса
Реализации демона init:
    классический init
    FreeBSD init
    systemd

# systemd
это не отдельный демон, а набор программ, демонов, библиотек, технологий
и компонентов ядра
unit    - модули(юниты), сущность которой управляет менеджер systemd
          модулем может быть служба, сокет, устройство, точка монтирования,
          точка автоматического монтирования, файл или раздел подкачки, 
          цель запуска, просматриваемый файловый путь, таймер, управляемый
          systemd, часть ресурса управления, группа созданных извне процессов
          Поведение модулей настраивается с пом модульных файлов
Расположение модульных файлов:
    /usr/lib/systemd/system # основное место
    /lib/systemd/system     # исп в нек системах
    /etc/systemd/system     # файлы локальных файлов и настройки(высш приоритет)
    /run/systemd/system     # есть каталог мод, кот явл раб обл для перех мод
Разновидности модульных файлов:
    .automount  - автоматически присоединяемое устройство.
    .device     - устройство, которое распознало ядро ОС.
    .path       - путь.
    .scope      - процесс, созданный извне.
    .service    - собственно сервис (служба).
    .slice      - группа иерархически орг-х юнитов, упр системными процессами.
    .snapshot   - сохраненное состояние менеджера systemd.
    .socket     - сокет.
    .swap       - файл подкачки.
    .target     - цель запуска (она же - уровень). Предназначены для групп-ки
                  вместе других юнитов systemd через цепочку зависимостей.
    .timer      - таймер systemd.
    .mount      - присоединяемое устройство.
Состояния модульных файлов:
    bad         - проблема с модульным файлом.
    disabled    - модульный файл присутствует в системе, но не настроен для
                  автономного запуска. Применяется только к модульным файлам,
                  которые находятся в одном из системных каталогов systemd.
    enabled     - модульный файл инсталлирован и запущен. Стартует автономно.
                  Применяется только к модульным файлам, которые находятся в
                  одном из системных каталогов systemd.
    indirect    - модульный файл отключен, но имеет одинаковые значения в
                  разделах Also, которые могут быть включены.
    linked      - модульный файл доступен через символическую ссылку.
                  Создавался командой systemctl link. Такие модульные файлы
                  могут обрабатываться командами или указываться в качестве
                  зависимостей, но они не являются полноправными элементами
                  системы и имеют некоторые заметные отклонения. Например,
                  применение команды systemctl. disable к модульному файлу в
                  состоянии linked приводит к удалению связи и всех
                  ссылок на него.
    masked      - нежелательный статус с логической точки зрения. Означает
                  "заблокирован администратором". Менеджер systemd знает о
                  модуле, но ему запрещено активировать его или действовать
                  по любой из ero конфигурационных директив с помощью команды
                  systemctl mask. В этом случае следует отключить модули,
                  находящиеся в состоянии enabled или linked, с помощью команды
                  systemctl disable и зарезервировать команду systemctl mask
                  для модулей в состоянии static.
    static      - зависит от другого устройства. Не требует установки. Это
                  состояние характерно для тех модулей, у которых нет процедуры
                  инсталляции. Запускаются они вручную, либо указываются в
                  качестве зависимостей от других активных модулей.

Пример модульного файла rsync.service
    [Unit]
    Description=fast remote file copy program daemon
    Documentation=man:rsync(1) man:rsyncd.conf(5)
    ConditionPathExists=/etc/rsyncd.conf
    After=network.target

    [Service]
    ExecStart=/usr/bin/rsync --daemon --no-detach

    [Install]
    WantedBy=multi-user.target

# systemctl
это универсальная команда для изучения состояния менеджера systemd и внесения
изменений в его конфигурацию
Команды systemctl:
    list-units      - все загруж и активные службы, сокеты, цели, смонт диски
                      и устр-ва. Флаг --type=service - только службы
    list-unit-files - все инсталлированные модульные файлы
    enable          - вкл модуль для активации при загрузке
    disable         - выкл запуск модуля при загрузке
    isolate         - изм режим работы на целевой
    start           - немедленно активирует модуль
    stop            - немедленно деактивирует модуль
    restart         - перезапукает/запускает модуль
    status          - состояние модуля, посл записи журнала
    kill            - отправ сигнал модулю, соотв шаблону
    reboot          - перезап компа
    daeman-reload   - перезагр файлы модулей и конфигурацию systemd
	
# WSL
	sudo service postgresql start

# навигация ------------------------------------------------------------------+
cd  # смена директории cd - -пред.каталог, cd .. -вверх на каталог
ls  # список содержимого, . -тек каталог, .. -каталог на ур выше, ~ -дом кат.
pwd # print work directory тек раб каталог                                  --+

# время дата-------------------------------------------------------+
date # системное время, настройка вывод... date +%A - день недели...
     # date "+%d %m %y %H %M %S" - дата и время
cal  # календарь, ncal -M - наш кал-рь...                       ---+

# инфо о системе---------------------------------+
# память
df   # место на дисках, df -h..
free # опер память занято/свободно/всего free -h..
du   # показывает сколько занято места определенными фацлами рекурсивно
     # du -sh ./* # текущий дир без рекурсии
     # -s -показывает только общий размер каталогов
/proc/meminfo   # вся информация о памяти

--- Шаблон соответствия ---------------------------------------------------
Шаблоны сопоставляются с файлами в файловой системе.
Набор файлов соответствующий шаблонам. ./* - все файлы в тек директории
# wildcards групповые символы ----+
* # любые символы                 |
? # любой 1 символ                |
[abc]  # символ из множества      |
[!abc] # символ не из множества   |
[^abc] # символ не из множества   |
[0-9]  # любой от 0-9             |
[[:класс:]]  # символ из класса   |
[![:класс:]] # люб симв не из кл  |
[123[:класс:]] # или 123 или кл   |
[[:alnum:]]* # любое кол-во цифр  |
\* "*" '*'   # экранирование      |
# классы  | Описание
----------+-------------------
[:alnum:] | Алфавитно-цифровой
[:alpha:] | Буквенный
[:ascii:] | ASCII (американский стандартный код для обмена информацией)
[:blank:] | Пробел и символ табуляции
[:ctrl:]  | Управляющий символ
[:digit:] | Число
[:graph:] | Все что угодно, кроме управляющих символов и пробела
[:lower:] | Символы в нижнем регистре
[:print:] | Все, кроме управляющих символов
[:punct:] | Символы пунктуации
[:space:] | Пробелы, включая разрывы строк
[:upper:] | Символы в верхнем регистре
[:word:]  | Буквы, цифры и символ подчеркивания
[:xdigit:]| Шестнадцатеричный символ

# опрации с файлами/каталогами------------------------------------------------+
file  # тип файла
stat  # подробная инфо о файле
cp    # copy -rfuv.. копирование -u --update только тех каких нет либо свежие
mv    # move перемещение --force --recursivity
rm    # remove -rf(удалит каталоги и все внутри без предупреждения)
mkdir # make directory -p - можно создать каталог в каталоге...
ln    # ссылка жесткая
ln -s # - символическая ссылка
{}    # до{10..12}после или {1..31}{1..12}{2004..2020} форм-т всякие послед-ти.

# справка------------------------------------+
man    # справочное рук-во программ(комманд)
info   # справочное рук-во
help   # справка встроенных комманд(ls,cd,...)
--help # инструкция по исп-ию             ---+

# man--------------------------------------------------------------------------+
manpath         # путь поиска man страниц
mandb           # обновить бд man
man -f sed      # ищет точное совпадение в коммандах
man -k sed      # ищет слово в описаниях комманд, выводит все рез-ты
man -L ru man   # полная инструкция по man на русском                        --+


# команды----------------------------------------------------------------------+
compgen - # -c доступные команды - исполняемые файлы. (ls, zip, tar ...)
            -b встроенные функции - это часть оболочки. Они выглядят как 
               исполняемые файлы, но файла не существует (bg, fg, trap ...)
            -k ключевые слова - выглядят как команды, но на самом деле
               являются частью языка оболочки (if, then, else ...)
type      # чем является конкретное слово — ключевым словом, встроенной функцией
            , командой или ничем из перечисленного 
type -t   # результат в 1 слово
which     # адрес файла команды(программы), если установлена
apropos   # man -k 
whatis    # man -f 
alias     # псевдоним для комманды          
source    # или . file -выполняет file в этой же самой оболочке и все переменные
            остаются после выполнения (вирт окружение на этом основаны)
shutdown  #             
sleep n   # приостановка программы на n секунд
basename  # команда удаляющая начальную часть пути к файлу
exit      # CTRL-D(на пустом вводе) завершить работу с терминалом            --+

# перенаправление ввода-вывода, конвейеры--------------------------------------+
1>  # или > перенаправление стандартного вывода в файл, stdout
2>  # перен-е вывода ошибок в файл, stderr, 2> /dev/null - подавление вывода
&>  # весь вывод, перенаправление в файл, аналогично:   > file.txt 2>&1

>>  # дозапись в конец файла
1>> # дозапись std в конец файла
2>> # дозапись err в конец файла
&>> # дозапись both в конец файла

0<  # или < стандартный ввод, stdin
|   # конвейер - ком1 | ком2 - стд вывод ком1 подается на стандартный ввод ком2
<<  # команда << 'индикатор' - обычно индикатор _EOF_
     команде передается на вход данные с стдин, при достижении _EOF_ -Ctrl+D
     _EOF_ должен находится в начале строки и больше ничего.
    # Example: ищем результат в подаваемом тексте с помощью grep
    grep 100 <<EOF  # \EOF если хотим экранировать символы в тексте (типа $1)
    # name amt      
    pete $100       # $1 тут прочит-ся как арг ком строки если EOF а не \EOF
    joe  $200
    sam  $25
    bill $9
    EOF


<<- # тоже самое только игнор символы табуляции перед _EOF_(в скрипте удобно)
<<< # чтение из 1 строки: <<< "Hello world"

# в скриптах:
exec 0< myfile	# позволяет сделать источником данных файл
exec 1>outfile	# перенаправит весь stdout в скрипте в файл
exec 2>myerror	# перенаправит stderr в скрипте в файл
>&1 			# вывод отдельной строки(в скрипте) в стдаут: echo "hi" >&1
>&2 			# вывод отдельной строки(в скрипте) в стдерр

# Создание собственного перенаправления вывода
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"

# Создание дескрипторов файлов для ввода данных
  Перенаправить ввод в скрипте можно точно так же, как и вывод. 
  Сохраните STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных
exec 6<&0
exec 0< myfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
y) echo "Goodbye";;
n) echo "Sorry, this is the end.";;
esac

# Закрытие дескрипторов файлов
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3

# Получение сведений об открытых дескрипторах
lsof            # список всех открытых в Linux дескрипторов
lsof -p <PID>   # указать ID процесса
lsof -d <num>   # указать номер дескриптора
echo $$         # узнать PID текущего процесса
lsof -a -p $$ -d 0,1,2  # объединение вывода

# Подавление вывода
2> /dev/null            # подавить вывод сообщений об ошибках
cat /dev/null > myfile  # очистить файл, не удаляя его

# работа с текстом------------------------------------------------------------+
cat  # объединение строк, cat file или cat < file или cat 0< file - чтение файла
     # cat > file "text" ctrl+D(EOF) чтение с клав-ры и запись в файл
     # cat >> file "text" ctrl+D чтение с клав-ры и дозапись в файл
     # cat << mystr пишем все, как напишем mystr(на отд строке) - вывод
     # cat -A -показывает табы ^I и конец строки $
     # -s - подавление пустых строк если больше 1
     # -n - нумерация строк
      
sort # сортировка строк текстовых файлов
     # sort [парам] файл(ы)
     # -b -сортировка пропускакт начальные пробелы
     # -f -игнор регистра
     # -n -сортировка по целым числам а не строкам
     # -g -сортировка по числам в математическом выр-ии т.е. с точкой дроби ...
     # -h -сортировка по числам если вывод в --human
     # -u -уникальные строки
     # -r -реверс
     # -k поле[,поле] -сортировка по опредкленным полям
     # -k2 - сортировка со второго поля
     # -k2.3 - сортировка со второго поля с 3 символа
     # -k2,2 - сортировка со второго поля по второе
     # -k2,3 -k4.4nr - со 2 по 3 поле и по 4-му с 4-го симв по ном рев
     # -k2.2,3.1br -k4.4nrb
     # -k4M -сортировка по месяцам если столбец из January-December
     # -t -определить символ-разделитель полей sort -t ':' -k3n /etc/passwd
           
uniq # принимает сортированный текст и выводит уникальные или повторяющиеся
     # sort text.txt | uniq -не выводит повтопяющиеся строки
     # -u - только уникальные 
     # -c - вывод количества повтгров строк
     # -d - только повторяющиеся
     # -f n - пропустить n полей
     # -s n - пропустить n символов
     # -i - игнор регистра

cut  # извлекае фрагменты текста из строк файлов и вывод в стд поток
     # cut -f3 -c1-3 file.txt -выводит 3 поле 3 символа, по умолч TAB раз-ль
     # -c символы 1-9[,11-12] -диапазон(ы) символов -c6,7-9,13- 
     # -f поля, диапазоны полей -f1,2,3-5,7-
     # -d символ разделитель, по умолчанию ТАБ

paste # обратная cut - добавляет колонки в файл -d - разделитель
      # paste file1.txt file2.txt - добавляет столбцы(поля)(колонки) 1 --> 2

join # объединяет поля из файлов по общему ключу поля(типа реляц. базы)
     # одно поле должно быть одинаковое и отсортированное, добавляет поля,
     # разделитель ТАБ -1 поле -2 поле  -указываются номера одинак поля в фай-х

wc   # вывод кол-ва: строки, слова, байты
head # первые 10 строк -n 5 5строк..
tail # последние 10 строк, tail -f -следит и выводит добавленные строки ctrlC
tee  # |tee file| копир со стд вывода в file и [передает дальше по конвейеру]
less # содержимое файла с возм-ю прокрутки
echo # выводит строку в стд поток
     # поддерживает wildcards echo *?[[:digit:]] ..
     # echo до{1,2,3}после - до1после до2после до3после - до{1..3}после..{Z..A}
     # подстановка переменных/комманд echo $(ls) $((2+2))                -----+

# проверка орфографии
aspell check myfile

# изменение текста
tr   # перекодирование или удаление текста, посимвольная операция поиска/замены
     # echo "some stdout"|tr [парам] 'что преобразовать' 'во чтг преобразовать'
     # tr a A < file.txt > new.txt -замена а на А в файле 1 и запимь в ыайл 2
     # tr -d '\r' < file.dos > file.unix -удаление символов
     # tr a-zA-Z A-Za-z - дипазоны
     # tr abc 123 -наборы символов или tr abcd # -абцд будут решетками
     # tr [:lower:] [:upper:] -posix классы

sed  # потоковый редактор, фильтрует и преобразовывает текст
     # прога исп рег выражения как в grep, они пишутся /так/
     # p - печать sed '1p' - печать 1 строки, '!p' - все кроме 1-ой
     # q - выходит при нахождении чего-либо
     # sed -i ... - сразу применить к файлу, иначе просто принт в стдаут
     
     #---замена---
     # sed [params] [file]... или echo "sometext" | sed [params]
     # команды применяются к каждой строке в файле/стдауте
     # -i -сразу поменять в исходном файле
     # sed 's/было/стало/' ./myfile  -замена первого вхождения в кажд строке
     # sed 's_old_new_' # можно применять любой разделитель после s, например
        для замены адресов удобнее так sed 's_/bin/bash_/bin/sh_' или экран ,\/
     # sed -e 's/old/new/'; 's/old2/new2/' ./file  # нескольк команд:
       -e com1; com2; com3; ...
     $ sed -e '  # вводим -е ковычка и многосточная команда :
     > s/This/That/
     > s/test/another test/' ./myfile
     # sed -f cfile ./myfile  # -f файл с командами, а не из стдин
        cfile: пример файла с командами
        # комменты через решетку
        s/This/That/
        s/test/another test/
     # sed 's/old/new/flags' # флаги:
        1  -цифра, каждое 1-е вхождение или какое указано цифрой в строке замещ
        g  -глобально все нахождения в строке замещаются
        p  -print строки в кот-х найд вхождения(исп с ключом -n -подав обыч выв)
        w file  -запись результатов обработки в файл 
     # sed '2s/было/стало/' ./myfile  -замена только во 2-й строке
     # sed '2,3s/было/стало/' ./myfile  -замена в дипазоне с 3-4 строки включ
     # sed '2,$s/было/стало/' ./myfile  -замена со второй до конца
     # sed '/шаблон/s/было/стало/' ./myfile  -поиск строк по регв и применение
     
     #---удаление---
     # sed '1d' ./myfile -удалить 1 строку
     # sed '1$' ./myfile -удалить последнюю строку
     # sed '2,3' ./myfile -удалить диапазон
     # sed '2,$' ./myfile -от и до конца
     # sed '/reg/d' ./myfile - поиск и удаление по шаблону
     # sed '/reg1/,/reg2/d' ./myfile - удал по шаблону плюс строки между ними
     # sed 's/^.//'  -удалить первый символ    ^.. ^...  -первые 2,3...
     # sed 's/.$//'  -удалить последний символ ..$ ...$  -послед 2,3...
     
     #---вставка---
     # 1 - первая строка, $ - последеяя строка
     # sed '1a\some string' myfile -вставляет строку после зад-ой а\ строки
     # sed '1i\some string' myfile -вставляет строку перед зад-ой i\ строкой
     # sed '3r textfile myfile -вставляет текст из файла после 3-й строки
     # sed '/reg/r textfile myfile -вставляет текст из файла после cтрок с шабл
     
     #---замена целой строки и отдельных символов---
     # sed '3c\modif string' myfile -замена 3-ей строки
     # sed '/reg/c New changed line' .myfile  -амена строк с исп шаблона
     # y/множество1/множество2  -замена как в tr y/123a/456A - пример
     
     #---номера строк
     # sed '=' myfile Выводит номера строк
     # sed -n '/reg/=' myfile  -выведет строки по шаблону с номерами 

# awk - обработка и фильтрация текста ---
# поля по умолчанию разделены пробелом, -F "*" - указать другой разделитель
echo "one two three"| awk '{print $1}' -выборка 1-го поля $NF -последнее
# awk использует переменные, операторы, циклы, условия, целый ЯП...------------

# Форматирование вывода--------------------------------------------------------
nl      # нумерация строк, в простейшем исп как cat -n
        # логическая страница в nl: заголовок: \:\:\:
                                   тело:      \:\:
                                   низ:       \:
        # эти эл-ты стоят отдельно в своих строках, удаляются после фильт-ии nl
        # каждая лог страница нумеруется заново
        # -w6  -по умолчанию поле 6 символов
        # -v1  -начать нумерацию с 1
        # -s'. ' - добавить после номера в кажд строке 
        # -ln -rn -rz  -выравнять по левому,правому,правому+00000
        # также можно нумеровать заголовки и низ, смотреть --help

fold    # перенос строк после указанной длины
        # принимает текст из файла или стд, по умолчанию 80 символов
        # -w12 -s  -перенос с 12 символов, по словам(ближайший пробел)

fmt     # простое форматирование текста, переносы, абзацы
        # -w 39 -ширина текста
        # -c -обработка края. 
        # -p # -обработать строки нач-ся с # или люб др символы

pr      # форматирование текста для печати, разбивка по страницам, длина, шир..

printf  # форматирование и выаод данных, не применяется в стд, только в сцен-ях
        # printf "формат" аргументы
        # printf "строка для форматиро%s\n" "вания" -пример подстановки
        # спецификаторы %s %d %f %o %x(%X) %% -строка, десятич, с точкой,8,16,%
        # %[флаги][ширина][.точность]спецификатор
        # флаги: # -альтернативный формат вывода, для 8-х и 16-х чисел
                0 -нули в начало поля, 00045 к примеру
                - -выравнивание по лев краю, по умолч по правому
                  -пробел добавляет пробел перед положительными числами
                + -выводит знак плюс перед положительными числами
        # ширина: минимальная ширина поля вывода
        # .точность: сколько символов после запятоц, для строк -кол-во символов
        # printf "Line: %05d %15.3f Result: %+15d\n" 1071 3.14156295 32589
        # 
        # 
        # 
groff   # система форматирования докум-в, отдельеая большая тема

# печать ---------------------------------------------------------------------+
pr      # преобразует текстовые файлы для печати 
lpr     # печатает файлы 
lp      # печатает файлы (System V) 
a2ps    # форматирует файлы для печати на принтере с поддержкой PostScript 
lpstat  # выводит информацию о состоянии принтера 
lpq     # выводит информацию о состоянии очереди печати 
lprm    # отменяет задания печати 
cancel  # отменяет задания печати (System V) 

# сравнение-------------------------------------------------------------------+
comm # построчное сравнение 2-х сортированных файлов
     # comm file1 file2  # два сортированных файла, выводятся в 3 колонки
     # 1- уник в 1 файле, 2- во втором, 3- в обоих
     # -123 # цифра параметра соответствует колонке вывод кот-ой подавляется

diff # сравнение построчно. 
     # -c контекстный формат -u унифицированный формат - -строка только в 1ф
                                                       + -строка только во 2ф
patch # изменения в файле 2 относительно файла 1
      # diff -Naur oldfile newfile > patchh.txt
      # patch < patchh.txt - применит изменения и oldfile будет равен newfile

cmp  # сравнения файлов побайтно -s -подавление вывода ----------------------+

# экранирование-------------------------------------------+
"" # экранируют все кроме $ \ `
'' # экранируют все
\  # экранирует спецсимволы в строке в "" $&\` также \n\t\a

# окружение-----------------------------------------------------+
printenv # (/usr/bin/env) - переменные окружения $USER, $PATH ... 
set      # выводит переменные и окружения и оболочки 
alias    # шаблоны
$PATH    # /etc/environment -тут все пути
export   # export PATH делает доступной переменную в дочерних процессах
# файлы запуска для сеансов ком оболочки входа(перед началом сеанса)
/etc/profile    # общисистемный конф сценарий для всех пользователей
~/.bash_profile # собственный файл запуска для определения/переопред сист настроек
~/.bash_login   # либо этот
~/.profile      # либо этот в ubuntu обычно
# файлы запуска для обычной сессии ком оболочки(работа в оболочке)
/etc/bash.bashrc # общесистемный
~/.bashrc        # личный, export PATH=~/bin:$PATH -добавление bin в пути
MYVAR=lalala    # моя переменная
export MYVAR    # добавить в окружение мою переменную
unset MYVAR     # убрать из окружения

# перемещение курсора--------------+
CTRL+A # в начало
CTRL+E # в конец
CTRL+F # символ вперед
CTRL+B # символ назад
ALT+F  # слово вперед
ALT+B  # слово назад
CTRL+D # удалить символ
CTRL+K # удалить до конца строки
CTRL+U # удалить до начала строки
ALT+D  # удалить до конца слова
ALT+BS # удалить до начала слова
CTRL+Y # вставить из буфера
CTRL+T # меняет символ с предыдущим
ALT+T  # меняет слово с предыдущим
CTRL+S # стоп-кадр терминала
CTRL+Q # выход из стоп-кадра терминала

# история--------------------------------------------------------------------+
clear # Ctrl+L очистка экрана
history # история команд !№ком в истории - вып-ся команда
        # поиск в ист CTRL+R ком-да ENTER(вып-ть) или CTRL+J(скопир в ком стр)
        # CTRL+R еще раз - след совпад в поиске.
        # CTRL+G CTRL+C - отмена/выход
!!      # last command
!:0     # номер слова строки(последней команды)
!xyz    # последняя команда нач-ся на 'xyz'
script  # запись сеанса оболочки в файл                                  ----+

# привилегии-----------------------------------------------------------------+
/etc/passwd # уч записи
/etc/group  # группы
/etc.shadow # пароли

-rwxrw-r-- 
|\|/\|/\|/
| u  g  o  ugo = a  u-user, g-group, o-other, a-all
|  
+--+ #тип файла
   | - файл
   | d каталог 
   | l симлинк(симв ссылка)
   | с симв.устр(терминал, модем)
   | b блочное устр(hdd, cd-rom)
 
    #файл______________| #каталог______________________
r   читать/открывать   | читать(если +x)
w   запись/усекать     | создавать, удалять, перемещать(если +x)
x   выполнение         | разрешен вход(cd)
-   никаких действий   | никаких действий
s   вып-ся от влад-ца  | совместный каталог группы
t   нет действий       | нельзя удалять и переименовывать (sticky)

bin  oct    +-     umask
0    000    ---    6
1    001    --x       
2    010    -w-    0
3    011    -wx
4    100    r--    2
5    101    r-x
6    110    rw-    0
7    111    rwx

chmod  # изменить режим доступа к файлу
       # chmod u+x, g=rw, o-wx # изменение прав в буквенном знач
       # chmod 600 = (u=rwx, go-rwx) -rwx------ # цифровое изменение
       # chmod u+s, go=rx   = 4755 -rwsr-xr-x, вып-ся от имени владедьца
       # chmod g+s, = 2772 = drwxrwsr-- , совместная директория группы
       # chmod +t dir = 1777 = drwxrwxrwt , нельзя удалять преим
umask  # доступ к файлам по умолчанию
+-актуальные маски имеющие смысл---------+
|umask | bin           |права            | 
|0000  |000 000 000 000| --- rw- rw- rw- |
|0002  |000 000 000 010| --- rw- rw- r-- |
|0022  |000 000 010 010| --- rw- r-- r-- |
|0006  |000 000 000 110| --- rw- rw- --- |
|0026  |000 000 010 110| --- rw- r-- --- |
|0066  |000 000 110 110| --- rw- --- --- |

adduser # по умолчанию создаются параметры дистрибутива
useradd # низкоуровневая утилита, все в ручную
id      # идентичность пользователя uid-номер юзера gid-номер группы юзера..
su      # смена пользователя su user
sudo    # root привилегии (суперпользователь - сп)
sudo su # войти в режим сп в этой же директории с .bashrc .profile пользователя
sudo -i # режим суперпользователя в его директории с его bashrc and profile
chown   # смена владельца chown user
        # смена группы файла chown :user
        # смена влад+группа user:user
sudo visudo # настройка разрешенных sudo комманд без ввода пароля
passwd  # passwd user - смена пароля пользователя   -----------------------+

# процессы------------------------------------------------------------------+
ps       # список процессов, вып-ся в данный момент
         # ps -el(unix режим) aux(bsd режим) все процессы
         # R - выполняется/готов к выполнению
         # S - приостановлен, в ожидании события   
         # D - приостановлен без возможности прерывания
         # T - остановлен принудительно, либо режим трассировки
         # Z - зомби, завершенный но не удален
         # < - выс приоритет
         # N - низк приоритет
         # niceness - уступчивость от -19 до 20
         # очень много параметров, смотреть man
!        # pid последнего фонового процесса -  echo $!
top      # вып-ся процессы в динамике, показывает загрузку cpu ram
CTRL+C   # прерывание вып-ия прог-мы
CTRL+Z   # приостановить процесс переднего плана(fg)
comm* &  # программа(процесс) запустится в фоновом режиме(на заднем плане bg)
jobs     # список заданий запущенных в терминале, '+' приоритетное задание 
jobs -l  # список заданий запущенных в терминале с PID
ps -l    # приостановленные задания
bg       # bg №задания - переведет процесс из приост-х на задний план
fg       # fg №задания - переведет процесс(приос-ый или bg) на передний план 
kill     # завершение процесса kill [-сигнал] PID 
kill -l  # список сиг-в  
killall  # послать сигнал на завершение сразу несколь№им пр-ссам
pstree   # дерево процессов
vmstat   # Выводит мгн снимок с информацией об использовании системных рес-в
pidof
pgrep
nice     # добавить уступчивочти -20 - 19
renice   # установить уступчивость -20 - 19
xload    # нагрузка на систему с теч времени (gui)
tload    # тоже самое но без граф инт --------------------------------------+

# сигналы
Код сигнала Название    Описание
1           SIGHUP      Закрытие терминала
2           SIGINT      Сигнал остановки процесса пользователем с терминала
                        (CTRL + C)
3           SIGQUIT     Сигнал остановки процесса пользователем с терминала 
                        (CTRL + \) с дампом памяти
9           SIGKILL     Безусловное завершение процесса
15          SIGTERM     Сигнал запроса завершения процесса
17          SIGSTOP     Принудительная приостановка выполнения процесса, 
                        но не завершение его работы
18          SIGTSTP     Приостановка процесса с терминала (CTRL + Z), 
                        но не завершение работы
19          SIGCONT     Продолжение выполнения ранее остановленного процесса

# репозитории дистрибутивы пакеты-------------------------------------
# 32 or 64 bit
  i386, x86, IA-32 # 32 bit
  amd64, x86_64    # 64 bit
# пакеты - сжатая кол-ция файлов программ сценариев метаданных...
  debian  # .deb
  red hat # .rpm
# репозиторий - коллекция пакетов
# дистрибутив включает 1 центральный репозиоорий и несколько сторонних
# инструменты управления пакетами
  debian: высокоур: apt, apt-get, aptitude. низкоур: dpkg
  redhat: высокоур: yum. низкоур: rpm
# поиск пакетов
  apt-cache search "pak"
  yum search "pak"
# установка пакетов из репозитория
  apt install "pak"
  yum install "pak"
# установка пакетов из файла
  dpkg --install "pak"
  rpm -i "pak"
#  удаление пакетов
  apt remove "pak"
  yum erase "pak"
# обновление пакетов из реп-ия
  sudo apt update; apt upgrade
  sudo pacman -Syu # Arch
  yum update
# обновление пакетов из файла
  dpkg --install "pak"
  rpm -U "pak"
# список установленнвх пакетов
  dpkg -l(--list)
  rpm -qa
# определение установлен ли пакет
  dpkg --status 'name'
  rpm -q 'name'
  apt --help # дружелюбный интерфейс всеикоманды
# сборка и установка программ
  .configure   # поставляется со сборкоц, анализирует сборку, создает Makefile
  make         # выполняет инструкции в макефайле
  sudo make install # установка программы

# устройства хранения----------------------------------------------------------+
/etc/fstab # устройства монтируемые на этапе загрузки
/dev       # директория со всеми устройствами
/dev/sd*   # подключенные уст-ва
df -h      # показывает свободное простанство на дисках
lsblk      # список всех блочных устройств
fdisk -l   # таблица разделов на всех блочных устройствах
blkid      # выводит UUID ид-ры всех подкл устройств, а также файловую систему
lsusb      # информация о всех портах, подробности в man
parted -l  # таблица разделов MBR/GPT


mount  # список монтируемых устр-в
       # mount -t iso9660 /dev/sd? "folder" # монтирование cd-rom
       # mount /dev/sd?1(2,3..) "folder"    # монт флешки
       # mount -t iso9660 -o loop image.iso "folder" # монтирование образа диска
umount # umount /dev/sd? # размонтировать устр-во
fdisk  # проверка диска
fsck   # создание и редактирование разделов на диске/носителе
mkfs   # создание файловой системы на разделе
dd     # копирование устройств
       # dd if=/dev/sdb of=/dev/sdc # копипование диска1 в диск2
       # dd if=/dev/sdb of=disk.img # копипование диска1 в файл
       # dd if=/media/sdrom of=disk.iso # создание образа из cd
       # dd if=disk.iso of=/dev/sdc # загрузочная флешка с образа
md5sum # контрольная сумма md5sum image.iso - проверка после записи
genisoimage # genisoimage -o cd-rom.iso ~/mydir - образ из дир-ии
wodim  # wodim dev=/dev/cdrw blank=fast - очистка cd-rw
       # wodim dev=/dev/cdrw image.iso - запись образа

# форматирование размонтированной флешки
mkfs -t vfat -n NAME /dev/diskname # t - тип ф.системы L или n(для fat32) - имя
# либо использовать сразу без указания фс
mkfs.bfs     mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.vfat
mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.ntfs    mkfs.xfs

# network --------------------------------------------------------------------+
ip          # может выводить сведения о сетевых адресах, позволяет управлять 
              маршрутизацией трафика и, кроме того, способна давать данные о 
              различных сетевых устройствах, интерфейсах и туннелях.
ifconfig    # устаревшее средство, используй ip
ifup
ethtool
route
nmcli
nc
nmap
host
nslookup

mtr         # инструмент для диагностики сетей и устранения сетевых неполадок. 
              Эта команда совмещает в себе возможности ping и traceroute.
tcpdump     # предназначена для захвата и анализа пакетов
netstat     # используется для вывода сведений о сетевых соединениях и таблицах 
              маршрутизации, данных о работе сетевых интерфейсов, о 
              masquerade-соединениях, об элементах групп многоадресной рассылки.
ss          # пришел на замену netstat (тот же пакет net-tools)
nslookup    # применяется для выполнения DNS-запросов и получения сведений о 
              доменных именах или IP-адресах, а так же — для получения любых 
              других специальных DNS-записей.
ping        # проверка, на уровне IP, возможности связи одной TCP/IP-системы с 
              другой. Делается это с использованием эхо-запросов протокола ICMP
arp         # таблица ARP
traceroute  # маршрут, по которому движутся сетевые пакеты
dig         # более крутая чем nslookup
vnstat      # A Network Traffic Monitor   
iftop       # Displays Bandwidth Usage
nload       # Displays Network Usage
nethogs     # Monitor Network Traffic Bandwidth
bmon        # Bandwidth Monitor and Rate Estimator
iperf3      # Network Bandwidth Measurement Tool
cbm         # Color Bandwidth Meter
nmap        # показывает открытые порты
wget        # узел/file загрузка файлов из сети
ssh         # -p port user@ip - подключение к удаленному компу
scp         # -P port user@ip:/file ./ передача файлов сюда
scp         # -P port ./ user@ip:/file передача файлов туда
ftp/sftp    # передача файлов get put вход как по ssh                          

# ssh настройка сервера --------------------------------------------------------+
sudo apt install openssh-server  # установка сервера
sudo systemctl enable sshd       # автозагрузка
/etc/ssh/sshd_config             # фвйл настройки
Port 22                    # изменить на другой
PermitRootLogin - no       # root доступ запрет
PubkeyAuthentication yes 
PasswordAuthentication  - yes # авторизация по паролю
sudo systemctl restart ssh # рестарт юнита
 
ssh-keygen # запустить на клиенте генератор ключа
id_rsa.pub # скопировать на сервер в .ssh/authorized_keys
id_rsa     # остается на клиентской машине
cat ~/.ssh/id_rsa.pub | ssh username@remote_host "cat >> ~/.ssh/authorized_keys"
PasswordAuthentication - no # авторизацию по паролю отключить                   
sudo systemctl restart ssh # рестарт юнита                                    --+

# Поиск файлов ----------------------------------------------------------------+
locate # поиск в базе данных имен locate zip, locatedb - обновить бд. 
find   # сложный способ поиска find "путь" "проверки" "операции" "параметры"
       # проверки: -type [fdbsl] тип файла(файл, каталог, устр-ва, ссылки)
                   -name "*.jpg" имя
                   -size +1M файлы более 1Мб (ckMG) байты кило мега гига
                   -perm 777 ищет файлы rwxrwxrwx 
                   -user -group -cmin ...
                   -regex рег выражение 
       # операторы -or -and -not () (файл с одними perm) -or (каталог с др.)
                   -and идет по умолчанию между параметрами
       # операции: -print(по умолч) - выводит полный путь к файлу в стд 
				   -prinf "%f\n" - выводит filename без пути
                   -print0| xargs -0 -во избежании проблем с пробелами в файлах
                   -delete - удаляет найденный файл
                   -ls  - ком-да ls -dils в отношении найд файла
                   -quit - завершает ком после нахождения
                   -exec команда '{}' ';' -вып-ся команда для найд файла
                   -ok команда '{}' ';' -запрос y/n перед выполнением ком
                   # меняем ';' на + -все нахождения предадутся команде в виде
                     аргументов и команда вып-ся один раз, тоже самое xargs
                   -exec comm '{}' +  эквивал | xargs comm
                   # find . -name "*.jpg" -exec cp '{}' ./mydir ';' -копирова-
                    ние файлов .jpg в свою дир-ию
                   -print0| xargs -0 -во избежании проблем с пробелами в файлах
       # параметры: 
                   -noleaf - поиск не в Unix системах
                   -depth снач файлы потом каталоги в кот эти файлы, с del поум
                   -mount не вып обход кат-гов в кот смортир др сист
                   -maxdepth -midepth -глубина --------------------------------+

# поиск текста grep------------------------------------------------------------+
grep # поиск в тексте по шаблонам(рег выражениям)
grep [парам] рег.выр [файл...]
     # параметры:
     -E # применять метасимволы из расширенного режима - egrep
     -i # игнор регистр
     -v # инверсия поиска, сочетается с др пар-ми
     -c # счетчик совпадений
     -l # вывод только имен файлов где найдено совпад
     -L # вывод имен файлов где нет совпадений
     -n # плюс выводятся нумера строк с совпадениями
     -h # вывод без имен файлов, если не одие файл выбран для поиска
     -f # читать шаблон поиска, находящийся в предоставленном файле
     -P # включить механизм регулярных выражений Perl
     -R # -r - выполнить рекурсивный поиск подкаталогов.
     +------------------------------------------------------------------------+
     | базовые регулярные выражения и расширенные grep -E
     |grep  egrep   discribe
     | .            любой символ обязательный
     | \?   ?       совпадение с предыдущим элементом 0 или 1 раз
     | *            совпадение с предыдущим элементом 0 или более раз
     | \+   +       совпадение с предыдущим элементом 1 или более раз
     | ^            якорь начало строки
     | $            якорь конец строки
     | \(\) ()      объединение(захват) выраж (10|20){1,2}
     | \|   |       (или|или) одно из обязательное
     | []           любой символ в скобках, обязательный
     | [^]          любой симво не из скобок, обязательный
     | [0-9]        любой из диапазона, обязательныЙ [A-Z]
     | \{\} {}      повтор пред символа(группы символов){1,2}   
     | {n}          предыдущий элемент встречается n раз
     | {n,m}        предыдущий элемент встречается не менее n не бoлее m
     | {n,}         предыдущий элемент встречается n или более раз
     | {,m}         предыдущий элемент встречается не более m раз 
     | [:class:]    классы POSIX(стандарт)
     +------------------------------------------------------------------------+ 
zgrep # поиск в сжатых файлах -------------------------------------------------

# Архивация и резервное копирование
gzip/gunzip  # упаковать/распаковать gzip -d == gunzip, gunzip -t - просм архива  
bzip2        # поблочная упаковка bunzip2 - распаковка
tar          # помещает файлы и каталоги в архив
             # tar c(создать архив) x(извлеч из архива) t(просмотр) f(имя)
             # tar cf 'имя нового архива.tar' dir - новый архив
             # tar rf dir.tar 'ваши файлы' - добавить в конец архива
             # tar xf dir.tar - извлеч из архива все
             # find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
               добавит в архив только определенные найденные файлы
             # tar cf new.tar --wildcards *.txt - созд архив из .txttar
             # tar czf|cxf new.tgz|new.tbz - создаст сжатый архив gzip|bzip2
             # find . -name "*.txt"|tar cf tar.tar -T -  # дефис - это стд вывод
                                                           -T == --files-from=
             # ssh 192.168.0.106 'tar cf - ~/Music'|tar xf -  # создаем архив
               в стд вывод(cf -) из каталога на удаленном узле и со стд вывода
               извлекам к себе (xf -)
zip          # zip -r dir.zip dir | unzip dir.zip
             # ls -l /etc/ | zip ls-etc.zip -   # исп стд выв для записи в архив
             # unzip -p ls-etc.zip | less   # просмотр (-p - pipe конвейер)
rsync        # синх-я файлов и кат-ов с уд-ой сист-ой: rsync парам ист-к при-к
             # rsync -a dir1 dir2 # -a -рекурсив+права
             # sudo rsync -av --delete --rsh=ssh /etc /usr/local remsys:/backup
                -rsh=ssh -по сети, --delete -удалит на приемнике лишние ф-лы
             # такжe можно настроить синх с серверами rsync в интернете

# ==========================================================================
# Сценарии-------------------------------------------------------------------
--- Директории с программами и сценариями ---
/bin            # бинарные файлы исп системой
/sbin           # бинарные файлы исп системой с правами суперпользователя
/usr/bin        # общисистемные бинарные файлы
/usr/sbin       # общисистемные бинарные файлы с правами суперпользователя
/usr/local/bin  # для ваших сценариев и программ
/usr/local/sbin # для установленных с помощью пакет менеджера
~/bin			# для ваших сценариев и программ(создают самостоятельно)

--- Правила писания в баш скриптах ---
#!/bin/bash     # shebang/шебанг which bash(какой bash используется)
# comment       # строки начинающиеся с # или пустые строки - игнорируются
pwd				# the shell commands are entered one per line.
pwd; ls			# two commands have to be separated with semicolon.
echo "pri\		# \ исп в сценариях для переноса длинных строк
vet"
\n \$ \\ \( \) 	# экранирование спецсимволов
""  			# экранирование текста, можно использовать подстановку $
''  			# полное экранирование, что напишешь то и выведет
;   			# разделитель более 1-ой инструкций в одной строке

--- Код возврата ---
# любой сценарий, ф-я или команда возвращает код завершения
0               # успешное завершение/true
1-255           # ошибка/false
echo $?	        # выводит последний код завершения

--- Пользовательские переменные ---
a="hi"          # Присвоит переменной a строку "hi".
$a              # обращение к переменной a
$USER			# обращение к переменной окружения
b="a string"    # Внутренние пробелы должны находиться в кавычках.
c="$b"          # При присваивании допускается выполнять подстановку
d=$(pwd)  		# Результат выполнения команды.
d=`pwd`			# Тоже - результат выполнения команды.
e=$((5 * 7))    # Подстановка результата арифметического выражения.
f="\t\ta str\n" # Экранированные последовательности, такие как \t \n
a=5 b="hui"     # сразу несколько переменных
${myvar}        # {} -можно огораживать, избегать путанницы где-то
                  например a="foo"; echo "${a}bar"
					  
--- Операторы ---
# в Bash можно использовать только целые числа, для дробных - bc.
# 9223372036854775807 максимальное число.
+ -                     # унарные 
+ - * / % ** ++ --      # арифметические
= += -= *= /= %= **=    # присваивание
>> << & | ^ ~           # битовые
== > < != >= <=         # сравнение
$$ || !                 # логические
выражение1?выр2:выр3    # тренарный оператор, если 1 истино то 2, иначе 3

--- Числа ---
23                  # число в 10-чной системе
023                 # 19 восьмеричная система
0xFF                # 255 шеснадцатиричная система
основание#число     # система по основанию # $((2#101)) - 5

--- Строки ---
foo="" foo= foo=''	# пустые строки
echo ${foo:-"hui"}  # при попытке обращения к пустой переменной выведет хуй
echo ${foo:="bar"}  # если переменная пустая, то присвоить bar
echo ${foo:?"ext"}  # если пустая, то выведет ext в стдерр и выйдет с кодом 1
echo ${foo:+"pls"}  # если пустая, то ничего не выведет, 
                      есди не пустая выведет pls, а значение не изменится
${!префикс*}        # выводят все имена переменных начинаю-ся с префикса
${!префикс@}          ${!BASH*} или ${!BASH@} -выведет кучу переменных
$(#var)             # если параметр строкa - вернет длину строки,
                      если * или @ - вернет число позиционных параметров
${var:смещ:длин}    # срез строки от смещ до длин
${var#шаблон}       # вырезание шаблона если он найден вначале строки
${var#*шаблон}      # вырезание шаблона и всего предыдущего текста строки
${var##*шаблон}     # вырезание последнего совпадения с шаблоном и всего до
${var%шаблон}       # вырезание шаблона если он найден вконце строки
${var%шаблон*}      # вырезание шаблона и все что после, поиск с конца строки 
${var%%шаблон*}     # вырезание послед шаб и все что после, поиск с кон строки
${var/шаб/"str"}    # замена в var найденного шаблона на str
${var//шаб/"str"}   # то же, но во всей строке
${var/#шаб/"str"}   # то жe но начало
${var/%шаб/"str"}   # то же но конец

# examples:
$ prefix="hell"
$ suffix="ld"
$ string="hello-world"
$ foo=${string#"$prefix"}
$ foo=${foo%"$suffix"}
$ echo "${foo}"     # o-wor

--- Команда test ---
test expression     # любое выражение из таблицы ниже,
                      test возвращ результат выражения 0(true) или 1(false)
                      /usr/bin/test - расположение test.
выражение           | истино если:
--------------------+---------------------------------------
<path1> -ef <path2> | жесткие ссылки на один и тот же объект
<path1> -nt <path2> | 1 новее 2
<path1> -ot <path2> | 1 старше 2
          -e <path> | файл существует
          -b <path> | файл блочного устр-ва
          -c <path> | файл символьного устр-ва
          -f <path> | простой файл
          -d <path> | каталог
          -L <path> | символическая ссылка
          -G <path> | файл пртнадлежит действующей группе
          -O <path> | файл принадлежит дкйствующему пользователю
          -p <path> | именованый канал
          -S <path> | сокет
          -r <path> | атрибут чтение     \
          -w <path> | атрибут запись      - для текущего польз-ля
          -x <path> | атрибут выполнение /
          -u <path> | атрибут setuid
          -g <path> | атрибут setgid
          -s <path> | атрибут sticky bit

--- Скобки ---
()      Командная группа. Команды будут вып по порядку, в новых подоболочках.
        $(cmd) эквивалентна `cmd`.
        Используется для инициализации массива. 
        Example: $(pwd)             # вызвать команду pwd
                 array=(a b c d)    # иниц массив
(())    ((aexp)) Вычисл результат арифм выр: если 0 - false -> код возврата 1,
        если не 0 - true -> код возврата 0.
        Example: ((12)) - true --> 0.
                 ((0)) - false --> 1.
        ((lexp)) Вычисл результат логич выр: если false -> код возврата 1,
        если true -> код возврата 0.
        Example: ((x>12)) - false --> 1, переменные можно исп без $
                 ((x<12)) - true --> 0
        $((exp)) Можно использовать любое выражение и операторы, которое
        соответствуют правилам работы языка C, включая тернарный оператор.
        При использовании чисел отличных от 10-чной сист исч они автоматически
        будут преобразованы к десятичной системе исч. 
        Также не обязательно использовать знак '$' в переменных, но нумеров
        аргументы ком строки исп-ть с $1 $2 ...
        Example: $((x % 3))     команда --> return остаток от деления
                 ((x+=3))       переопределить значение переменной 'x'.
                 ((x < 120))    сравниваем, пододит для условий
[]      Внутренние команды bash, эквивалентные командам test, сравнения,
        тест файла, test -e ./file эквивалентен [ -e ./file ].
        '[' - команда /usr/bin/[ 
        ']' - это аргумент команды '[', который означает конец аргументов.
        Используется как часть рег выр для описания диапазона совпадающих симв.
        Также используется для указания индексов в массивах.
        Example: [ "$1" -eq "Ivan" ]
                 arr[1]=12
[[]]    Является расширением Bash. 
        '[[' - ключевое слово
        Позволяет использовать круглые скобки и логические операторы 
        !, && и || в скобках для объединения подвыражений.
        Имеет оператор соответствия =~ регулярных выражений.
        Строковые переменные можно исп без ковычек $mystr.
        Можно для сравнения вместо '==' использовать '='.
        Example: [[ -f $file1 && ( -d $dir1 || -d $dir2 ) ]]        # [[]]
                 [ -f "$file1" -a \( -d "$dir1" -o -d "$dir2" \) ]  # []
Diff    test -e "$file"  [ -e "$file" ]  [[ -e $file ]] # ковычки переменных
        [ "$str1" \> "$str2" ]  [[ $str > $str2 ]]      # экранирование < > 
        test $x -eq $y  [[ $x == $y ]]

--- Сравнение чисел ---
        выражение             
--------+--------+-----
test [] | (())   | true
--------+--------+------------
x -eq y | x == y | числа равны
x -ne y | x != y | числа не равны
x -le y | x <= y | меньше или равно
x -lt y | x < y  | меньше
x -ge y | x >= y | больше или равно
x -gt y | x > y  | больше
--------+--------+-------

--- Сравнение строк ---
[ выражение ]        | истино если:
---------------------+-----------------
"string"             | строка не пустая
-n "string"          | длина строки больше 0
-z "string"          | длина строки = 0
"str1" = "str2"      | строки равны '=' или '==' без разницы для [] [[]]
"str1" != "str2"     | строки не равны
string1 > string2    | строка1 больше в алфавитном порядке, для [[]]
string1 < string2    | строки1 меньше в алфавитном порядке, для [[]]
"str1" \> "str2"     | строка1 больше в алфавитном порядке, для test, []
"str1 "<" "str2"     | строки1 меньше в алфавитном порядке, для test, []
string =~ ^-?[0-9]+$ | строка соотв-т регвыр, только для [[]]
string == *.mp3      | сопоставление с шаблоном wildcards, для [[]]
---------------------+---------------------------------------------
    
--- Логические объединения выражений ---
операция | test, [] | [[]] (())
---------+----------+----------
   И     | -a       | &&
  ИЛИ    | -o       | ||
  НЕ     | !        | !
  -------+----------+--

--- Ветвление ------------------------------------------------------------------
--- if-else ---
if condition; then		    # условие 
    code
elif condition2; then       # доп проверки
    code
else                        # иначе
    code
fi                          # end if
Examples:
if grep 'ivar' /etc/passwd  # true если grep вернет какие либо строки
if [ -d /etc ] && [ -n $1 ] # combine tests using AND (&&) or OR (||)
if [ $x -lt 1024 ]          # numbers comparsion
if ((x < 1024))             # the same numbers comparsion

--- case ---
case str in 
    [шаблон[|шаблон]...) команды;;]...
esac
Example:
case $REPLY in
    0) echo "program terminsted"
       exit
       ;;
    # используются wildcards, любые шаблоны
    1|2) commands;;
    *.txt) commands;;
    [abs][1-9]) commands;;
    [[:alpha:]]) commands;;
    ???) commands;;
    *) commands;;  # все что не вошло под шаблоны
esac

--- Ветвление, операторы управления --------------------------------------
command1 && command2  # если com1 вернет true, то пробовать выполнить com2
command1 || command2  # если com1 не вернет true, то пробовать вып com2
Examples:
[ -e myfile ] && cat myfile  # если есть мойфайл то открыть его в кат
cat myfile || touch myfile   # если есть файл - открыть, если нет -создать

# можно объединять неск комманд {com1; com2} || com3
[[ -d $DIR ]] || { echo "error: no such directory: $DIR" ; exit ; }

# массивы ----------------------------------------------------------------
a[0]=foo        # создать массив а и присвоить 1-му л значение фуу
                # массивы нумеруются с нуля
declare -a a    # также создать массив а
a=(1 2 3 4)     # присвоитб сразу много щначений
a=([0]=a [1]=3) # множеств-е присваивание по индексу
echo ${a[0]}    # показат 1-ый эл, скобки {  }оoбязательны
for i in ${a[*]}; do echo $i; done  # вывод всех эл массива

a=("a" "b" "c d e")
${a[*]}    # "a" "b" "c" "d" "e"
${a[@]}    # "a" "b" "c" "d" "e"
"${a[*]}"  # "a b c d e"
"${a[@]}"  # # "a" "b" "c d e"

${#a[@]}   # кол-во эл-в в массиве
${#a[100]} # длина элемента
"${!a[@]}" # индексы массива которы присвоины переменные
a+=(9)     # добавление нового значения в конец массива

a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort)) # сортировка мас-ва
unset a    # удалить массив а
unset a[0] # удалить 0-й индекс

--- функции -----------------------------------------
glob=10             # глобальная переменная, можно исп/измен в функции
myfunc () {         # функцию объявляем до ее вызова
    local temp=5    # локальная пременная - видна только в ф-ии
    commands
    return 0        # вернуть код возврата 0-255, обрабатывать в парам $?
}
myfunc              # вызов функции(в подоболочке)
myfunc p1 p2 p3     # вызов с аргументами
myfunc $1 $2        # пересылка парам ком строки в ф-ю
echo $?             # используем код возврата функции 0-255

# в функциях те же правила 
  $0    -всегда и везде имя скрипта
  $1    -парам ф-ии
  $#    -кол-во параметров

# in loop
while [ $count -le 3 ]; do
    myfunc          # функция будет выполняться в подоболочке
    count=$((count + 1))
done

# передача массива
function myfunc {
    local newarray=("$@")
    echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}    # передаем массив

# рекурсивная Функция
function factorial {
    if [ $1 -eq 1 ]; then
        echo 1
    else
        local temp=$(( $1 - 1 ))
        local result=$(factorial $temp)
        echo $(( $result * $1 ))
    fi
}

# вызов функции из другого скрипта
# script1
    function addnum {
        echo $(( $1 + $2 ))
    }
# script2
    #!/bin/bash
    . ./script1                     # . или sourse 
    result=$(addnum 10 20)          # вызов ф-ии из др скипта
    echo "The result is: $result"

# Вызов bash-функций из командной строки
. ./script1     # или source ./script1
addnum 10 20    # использование прямо в ком строке


basename -команда удаляющая начальную часть пути к файлу


--- IFS -----------------------------------------------------------
Internal Field Separator, переменная окружения - разделитель полей.
Разделители по умолчанию - ' ', '\t', '\n' (любой из этих).
Bash встречая эти символы, считает, что перед ним следующий элемент списка.
IFS=$'\n'	- оптимально для чтения файлов.
IFS=":" 	- удобно для /etc/passwd.

--- read, чтение строки из стдин -------------------------------------------
read [-параметры] [переменная...] если переменная не указана то сохр в REPLY
параметры:
    -a массив       - сохр ввод в массив с 0-го индекса
    -d разделитель  - признак конца ввода, по умолч ентер- \n
    -e              - исп Readline, ввод как в ком строке
    -n число        - читает n-симврлов, а не всю строку
    -p приглашение  - показывать указанное приглашеник к вводу
    -r              - как в питоне строка без поддержки \n\t...
    -s              - silent режим, не видно что вводишь
    -t секунды      - по истеч времени вернется ненулевое знач
    -u дескриптор   - произвести ввод из файла, а не из стдин
переменная:
	read var1		- сохранит ввод в эту переменную
	read var1 var2  - неск перем, 
	$REPLY 			- если не указаны переменные то сохр сюда

Examples:	
read -p "Enter your name: " name		-аналогична двум командам ниже
echo -n "Enter your name: "
read name
read -p "Enter your name: " first last	-несколько переменных (исп пробел)
read -s -p "Enter your password: " pass	-скрытый ввод пароля  
<<< -оператор встроенная строка, подобно встр документу, но короче-до кон стр
Example: чтение файла
cat myfile | while read line; do
	echo $line
done
echo "Finished"

--- while -------------------------------------------------
while condition; do # пока условие true(0) цикл выполняется
    commands
done                # end loop
continue 			# новая итерация
break    			# выход из цикла
until    			# цикл типа while, только вып-ся условие false
Examples:
while [ $repeat -gt 0 ]; do {
    printf "$string"
    repeat=$((repeat - 1))
}
done
# чтение из файла с пом read, присваивание, вывод
while read distro version release; do 
	printf "Distro: %s\tVersion: %s\tReleased: %s\n" $distro $version $release
done < distros.txt  
# либо можно передать по конвейеру: файл|while read var;do ... ; done

--- for -----------------------------------------------------------
for i in <list>; do         # <list> список аргументов через пробел
    commands    
done
Examples:
file="/home/ivar/myfile"
for i in $(cat $file);do    # перебор строк в файле
    echo $i
done > myfile.txt			# перенаправление вывода в файл(для примера)
for i; do                   # обрабатываются по умолч позиц аргументы ком строки
for i in a b c d; do        # перебор строк разделенных пробелом
for i in {a..d}; do         # перебор символов из диапазона a-d включительно
for i in *; do          	# перебор файлов в тек дир можно с полным путем
for i in ~/dir/*.sh; do		# перебор файлов .sh с полными путями

--- for в стиле СИ ---
for ((i=0;i<5;i++)); do
    commands
done

--- trap/перехват сигналов --------------------------------------------------
# Команда trap позволяет скрипту реагировать на сигналы, в противном случае 
  их обработка выполняется оболочкой без его участия.
  В кач-ве команды часто используют вызов функции под разные сигналы.
trap "echo my msg" SIGINT SIGQUIT   #  код, который надо выполнить, и сигнал
                                       или сигналы, кот перехватываются.
trap "echo Goodbye..." EXIT         # перехватить сигнал выхода из скрипта
trap -- SIGINT                      # отмена перехвата сигнала

--- способы сохранения активности процессов при закрытии терминала -----
# Выполнение скриптов, не завершающих работу при закрытии терминала
./command &       # запуск программы в фоне           \
jobs -l           # посмотреть номер нужного процесса  -1 способ
disown %1         # удаление задачи                   /

nohup ./command & # вывод перенаправлен в 'nonhup.out' -2 способ(best)

screen and tmux   # также используются для этих целей  -3 способ

--- Параметы ком строки------------------------------------------------
# передавая программе аргументы в ком строке их можно использовать так:
    $0    	-всегда путь и название программы которая запустилась
    $1-9  	-любые аргументы ком строки
    ${10} 	-если параметров больше 9 - добавляем{}
    $#    	-кол-во параметров
	${!#}	-последний параметр
# пример myscript "a" "b" "c d e"
    $*    	-все аргументы, в виде одной строки  "a b c d e"
    $@    	-все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    "$*"  	-все аргументы в одной строке через пробелы "a b c d e"
    "$@"  	-все аргументы, в виде отдельных строк с уч пробелов "a" "b" "c d e"

shift    -команда которая убирает параметр $1, а все послед сдвигает на одно
          место к началу, $# становится на 1 меньше, $0 всегда неизменен.
		  
Example: перебор и вывод параметров
while [ -n "$1" ]; do
	echo "$1"
	shift
done
Example: как различать ключи и параметры
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "Found the -a option" ;;
		-b) echo "Found the -b option";;
		-c) echo "Found the -c option" ;;
		--) shift	# ключи и параметры можно разделить с помощью "--"
		break ;;
		*) echo "$1 is not an option";;
	esac
	shift	# сдвиг, по идее дальше могут идти параметры
done
count=1
for param in $@; do	# вывод нумерованных параметров
	echo "Parameter #$count: $param"
	count=$(( $count + 1 ))
done

--- Ключи, договоренности ---
-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.

# встроенный метод трассировки, указываем в шебанг +x
#!/bin/bash +x  # будет показано подробное выполнение кода, знак + показывает
  трассировочную информацию, знак + храеится в PS4, ее можно изменить:
  export PS4='$LINENO + '  # поменяли на номер строки +
  set -x  # включение трассировки в коде сценария
  set +x  # выключение трассировки, это можно присеняь прямо в скриптах в коде
    
--- Группы команд и подоболочка --------------------------------------------
# группа команд вып-ся в текущей оболочке, а подоболочка - в дочерней(копия),
 после выполнения подоболочки все ее окружение и данные уничтожаются
| -всегда выполняется в подоболочке и все переменные уничтожаются после выхода
{ com1; com2; com3; }   # группа команд в тек оболоч (пробелы и ; обязательны)
(com1; com2; com3)      # группа команд в подоболочке
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt  # перенап-е
(ls -l; echo "Listing of foo.txt"; cat foo.txt) > output.txt
# подстановка процессов
<(список команд)    # для процессов отправляющих рез-ты на стдаут
>(список команд)    # для процессов принимающих данные на стдин
# подстановка процесов интер-ет вывод подоболочки как обычный файл
  cat <(echo "foo")  -передается как типо это файл, заменяет
  echo <(echo "foo") -выведет /dev/fd/63 -файл где сохр эхо
  read < <(echo "foo")  -сохранит foo в REPLY
# подстановка проц-ов часто исп в циклах с read:
while read myvar1 myvar2; do
    cat <<- EOF
            var1: $myvar1
            var2: $myvar2
    EOF
done < <(ls -l|tail -n +2) -вывод подоб-ки напрвл-ся на стдин цикла(read) 
# различные примеры
rm $(find . -name '*.class')    # удалить рез-ты

--- Databases --------------------------------------------------------------
# Postgres, можно разрешить sudo без пароля, будет удобнее (sudo visudo)
sudo -u postgres psql -d mydb -c "SELECT * FROM celebrities;"
# with root
psql -U postgres -d mydb -c "SELECT * FROM celebrities;"
su -c "psql -d mydb -c \"SELECT * FROM celebrities;\"" postgres


# Асинхронное выполнение
wait pid  # приостановка процесса, пока не завершится pid(какой-то фон.проц) 

# Именованные каналы
mkfifo pipe1   - сознание именованного канала
ls -l > pipe1  - перенаправление в им канал
cat < pipe1    - разб-ка канала и принятие данных(можно в другом терминале)

--- Планирование запуска скриптов -------------------------------
# Linux предоставляет пару способов запуска bash-скриптов в заданное время. 
  Это команда at и планировщик заданий cron.

--- at ---------------------------------------------------------------
at -f filename 'time'   # запуск скрипта по времени
# форматы указания времени/даты в место 'time' в команде:
    Стандартный, с указанием часов и минут, например — 10:15.
    С исп индикаторов AM/PM, до или после полудня, например — 10:15PM.
    С исп спец имён, таких, как now, noon, midnight.
    Станд формат даты, по шаблонам MMDDYY, MM/DD/YY, или DD.MM.YY.
    Текстовое представление даты, например, Jul 4 или Dec 25, 
    при этом год можно указать, а можно обойтись и без него.
    Запись вида now + 25 minutes.
    Запись вида 10:15PM tomorrow.
    Запись вида 10:15 + 7 days.
atq     # список заданий, ожидающих выполнения
atrm 18 # Удалить задание, ожидающее выполнения

--- cron -----------------------------------------------------------+
/etc/crontab        # главный файл который запускает все задачи
/etc/cron.minutely  # каждую минуту
/etc/cron.hourly    # каждый час
/etc/cron.daily     # каждый день
/etc/cron.weekly    # каждую неделю
/etc/cron.monthly   # каждый месяц
run-parts ./        # запуск всех скриптов +x в тек директории фонов реж     

grep CRON /var/log/syslog # логи

# crontab -l # список задач
# crontab -r # удалить все задачи
# crontab -e # создать задачу
    минута час день месяц день_недели /путь/к/исполняемому/файлу
    все расписано в комментах в crontab -e
    rm -f /var/run/crond.pid    # при ошибке «Resource temporarily unavailable»

# Example of job definition:
     .---------------- minute (0 - 59)
     |  .------------- hour (0 - 23)
     |  |  .---------- day of month (1 - 31)
     |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
     |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) 
     |  |  |  |  |       or sun,mon,tue,wed,thu,fri,sat
     |  |  |  |  |
     *  *  *  *  * user-name command to be executed

    # every minute
     * * * * * /home/ivar/bin/test.txt
    # every Monday at 0:00...
    0 0 * * 1 echo "every monday at 0:00 $(date)" >> /tmp/test.txt
    # every 1st and 15th days of each month at 1:25
    25 1 1,15 * * echo "1, 15 days $(date)" >> /tmp/test.txt
    # every 10 minutes every hour every day...
    */10 * * * * echo "every 10 minutes $(date)" >> /tmp/test.txt
    # every every 3 days...
    0 0 */3 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # every hour(between 0 to 5) at 2:30...
    30 2 0-5 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # 30 Mon-Fri 9am-5pm
    */30 5-9 * * 1-5 echo "every bla-bla-bla $(date)" >> /tmp/test.txt

# cron examples
# every minutes every hour every day...
* * * * * echo "every minutes $(date)" >> /tmp/test
# 0:30, 1:30, 2:30, 3:30 ... 
30 * * * * echo "each 30 min every hours $(date)" >> /tmp/test
# each 5:30 every day, every month...
30 5 * * * echo "each 5:30 every day $(date)" >> /tmp/test
# every 1st day in month at 5:30 every month...
30 5 1 * * echo "each 1st day in month at 5:30  $(date)" >> /tmp/test
# every feb 1st day in month at 5:30 every year`...
30 5 1 2 * echo "each 1st day in Feb at 5:30 every year $(date)" >> /tmp/test

--- anacron --------------------------------------------------------------
Anacron имеет приоритет над cron если он установлен в системе, работает не
в абсолютном времени, а относительно самой последней загрузки системы.
/etc/anacrontab     # файл с заданиями
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
HOМE=/root
LOGNAМE=root
1 5 cron.daily run-parts --report /etc/cron.daily   
7 10 cron.weekly run-parts --report /etc/cron.weekly
@monthly 15 cron.monthly run-parts --report /etc/cron.monthly
1 5     # каждый день через 5 минут после загрузки системы
7 10    # каждый седьмой день через 10 мин после загрузки системы


--- Запуск скриптов при входе в систему и при запуске оболочки -----------
# скрипты можно расположить в следующих файлах
$HOME/.bash_profile # при входе в систему
$HOME/.bash_login   # при входе в систему
$HOME/.profile      # при входе в систему This file is not read by
                      bash(1), if ~/.bash_profile or ~/.bash_login exists.
$HOME/.bash_logout  # when leaving the console
$HOME/.bashrc       # при открытии оболочки bash
    
--- locale -------------------------------------------------------------------
locale          # информация о текущем языковом окружении
locale -a       # список всех установленных языков и кодировок -v - подробно
echo $LANG      # посмотреть настройки языка и кодировки
/etc/locale.gen # Список всех поддерживаемых (доступных для установки) локалей
locale-gen      # установить все локали из /etc/locale.gen()
locale-gen de_DE.UTF-8  # установка какой-либо локали
LANG=ru_RU.utf8         # изменить локаль на текущую сессию
export LANG=en_US.utf8  # добавить в .bashrc для изменения на постоянной основе
localectl set-locale LANG=en_US.utf8  # изменить локаль по умолчанию
/etc/default/locale     # локаль по умолчанию

--- PostgreSQL server --------------------------------------------------------
1	sudo nano /etc/postgresql/12/main/postgresql.conf
	#listen_addresses = 'localhost'
	заменить на
	listen_addresses = '*'
2	sudo nano /etc/postgresql/12/main/pg_hba.conf
	допишем в конец файла
	host      mydb       myuser  all          md5
3	Рестарт сервера
	sudo service postgresql restart
	
