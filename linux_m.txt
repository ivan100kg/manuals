# Linux

# общее понимание ------------------------------------------------------------+
+ терминал           # файл устройства реализующий команды чтения-записи.
+ командная оболочка # программа принимающая команды от пользователей, 
                       передает системе, it's bash или shell.
+ эмулятор терминала # программы обеспеч доступ к терминалу. (Xterm, tmux…)
+ консоль            # терминал в физическом смысле. Терминалы TTY, переключ
                       между ними ctrl+alt+F(n)
+ командная строка   # интерфейс, где пользователь вводит команды

# навигация ------------------------------------------------------------------+
cd  # смена директории cd - -пред.каталог, cd .. -вверх на каталог
ls  # список содержимого, . -тек каталог, .. -каталог на ур выше, ~ -дом кат.
pwd # print work directory тек раб каталог                                  --+


# время дата-------------------------------------------------------+
date # системное время, настройка вывод... date +%A - день недели...
     # date "+%d %m %y %H %M %S" - дата и время
cal  # календарь, ncal -M - наш кал-рь...                       ---+

# инфо о системе---------------------------------+
# память
df   # место на дисках, df -h..
free # опер память занято/свободно/всего free -h..
du   # показывает сколько занято места определенными фацлами рекурсивно
     # du -sh ./* # текущий дир без рекурсии
     # -s -показывает только общий размер каталогов

# wildcards групповые символы ----+ # regular expression рег-е выраж-я
* # любые символы                 |
? # любой 1 символ                |
[abc]  # символ из множества      |
[!abc] # символ не из множества   |
[0-9]  # любой от 0-9             |
[[:класс:]]  # символ из класса   |
[![:класс:]] # люб симв не из кл  |
[123[:класс:]] # или 123 или кл   |
# классы                          |
[:alnum:] # любая буква или цифра |
[:alpha:] # алфавитный символ     |
[:digit:] # цифровой символ       |
[:lower:] # буква в ниж рег       |  
[:upper:] # буква в врех рег------+

# опрации с файлами/каталогами------------------------------------------------+
file  # тип файла
stat  # подробная инфо о файле
cp    # copy -rfuv.. копирование -u --update только тех каких нет либо свежие
mv    # move перемещение --force --recursivity
rm    # remove -rf(удалит каталоги и все внутри без предупреждения)
mkdir # make directory -p - можно создать каталог в каталоге...
ln    # ссылка жесткая, ln -s - символическая ссылка
{}    # до{10..12}после или {1..31}{1..12}{2004..2020} форм-т всякие послед-ти.

# справка------------------------------------+
man    # справочное рук-во программ(комманд)
info   # справочное рук-во
help   # справка встроенных комманд(ls,cd,...)
--help # инструкция по исп-ию             ---+

# man-----------------------------------------
man -L ru man  # полная инструкция по man на русском

# комманды---------------------------------------------------------------------+
type      # интерпритация имени
which     # какая команда будет выполнена
apropos   # man -k -список подходящих справочных страниц где встречается слово
whatis    # man -f -краткое описание комманды
alias     # псевдоним для комманды          
source    # или . file -выполняет file в этой же самой оболочке и все переменные
            остаются после выполнения (вирт окружение на этом основаны)
shutdown  #             
sleep n   # приостановка программы на n секунд
basename  # команда удаляющая начальную часть пути к файлу
exit      # CTRL-D(на пустом вводе) завершить работу с терминалом            --+

# перенаправление ввода-вывода, конвейеры--------------------------------------+
1>  # или > перенаправление стандартного вывода в файл, stdout
2>  # перен-е вывода ошибок в файл, stderr, 2> /dev/null - подавление вывода
&>  # весь вывод, перенаправление в файл == > 2>&1
>&1 # вывод в стдаут
>&2 # вывод в стдерр
>>  # дозапись в конец файла
0<  # или < стандартный ввод, stdin
|   # конвейер - ком1 | ком2 - стд вывод ком1 подается на стандартный ввод ком2
<<  # команда << индикатор  -обычно индикатор _EOF_
     команде передается на вход данные с стдин, при достижении _EOF_ -Ctrl+D
     _EOF_ должен находится в начале строки и больше ничего
<<-  -тоже самое только игнорируются символы табуляции перед _EOF_
<<< # встроенная строка, типа встp докум, только короче, до конца строки.

# работа с текстом------------------------------------------------------------+
cat  # объединение строк, cat file или cat < file или cat 0< file - чтение файла
     # cat > file "text" ctrl+D(EOF) чтение с клав-ры и запись в файл
     # cat >> file "text" ctrl+D чтение с клав-ры и дозапись в файл
     # cat << eof пишем все, как встретится eof - произойдет вывод
     # cat -A -показывает табы ^I и конец строки $
     # -s - подавление пустых строк если больше 1
     # -n - нумерация строк
      
sort # сортировка строк текстовых файлов
     # sort [парам] файл(ы)
     # -b -сортировка пропускакт начальные пробелы
     # -f -игнор регистра
     # -n -сортировка по целым числам а не строкам
     # -g -сортировка по числам в математическом выр-ии т.е. с точкой дроби ...
     # -h -сортировка по числам если вывод в --human
     # -u -уникальные строки
     # -r -реверс
     # -k поле[,поле] -сортировка по опредкленным полям
     # -k2 - сортировка со второго поля
     # -k2.3 - сортировка со второго поля с 3 символа
     # -k2,2 - сортировка со второго поля по второе
     # -k2,3 -k4.4nr - со 2 по 3 поле и по 4-му с 4-го симв по ном рев
     # -k2.2,3.1br -k4.4nrb
     # -k4M -сортировка по месяцам если столбец из January-December
     # -t -определить символ-разделитель полей sort -t ':' -k3n /etc/passwd
           
uniq # принимает сортированный текст и выводит уникальные или повторяющиеся
     # sort text.txt | uniq -не выводит повтопяющиеся строки
     # -u - только уникальные 
     # -c - вывод количества повтгров строк
     # -d - только повторяющиеся
     # -f n - пропустить n полей
     # -s n - пропустить n символов
     # -i - игнор регистра

cut  # извлекае фрагменты текста из строк файлов и вывод в стд поток
     # cut -f3 -c1-3 file.txt -выводит 3 поле 3 символа, по умолч TAB раз-ль
     # -c символы 1-9[,11-12] -диапазон(ы) символов -c6,7-9,13- 
     # -f поля, диапазоны полей -f1,2,3-5,7-
     # -d символ разделитель, по умолчанию ТАБ

paste # обратная cut - добавляет колонки в файл -d - разделитель
      # paste file1.txt file2.txt - добавляет столбцы(поля)(колонки) 1 --> 2

join # объединяет поля из файлов по общему ключу поля(типа реляц. базы)
     # одно поле должно быть одинаковое и отсортированное, добавляет поля,
     # разделитель ТАБ -1 поле -2 поле  -указываются номера одинак поля в фай-х

wc   # вывод кол-ва: строки, слова, байты
head # первые 10 строк -n 5 5строк..
tail # последние 10 строк, tail -f -следит и выводит добавленные строки ctrlC
tee  # |tee file| копир со стд вывода в file и [передает дальше по конвейеру]
less # содержимое файла с возм-ю прокрутки
echo # выводит строку в стд поток
     # поддерживает wildcards echo *?[[:digit:]] ..
     # echo до{1,2,3}после - до1после до2после до3после - до{1..3}после..{Z..A}
     # подстановка переменных/комманд echo $(ls) $((2+2))                -----+

# проверка орфограыии
aspell check myfile

# изменение текста
tr   # перекодирование или удаление текста, посимвольная операция поиска/замены
     # echo "some stdout"|tr [парам] 'что преобразовать' 'во чтг преобразовать'
     # tr a A < file.txt > new.txt -замена а на А в файле 1 и запимь в ыайл 2
     # tr -d '\r' < file.dos > file.unix -удаление символов
     # tr a-zA-Z A-Za-z - дипазоны
     # tr abc 123 -наборы символов или tr abcd # -абцд будут решетками
     # tr [:lower:] [:upper:] -posix классы

sed  # потоковый редактор, фильтрует и преобразовывает текст
     # прога исп рег выражения как в grep, они пишутся /так/
     # p - печать sed '1p' - печать 1 строки, '!p' - все кроме 1-ой
     # q - выходит при нахождении чего-либо
     
     #---замена---
     # sed [params] [file]... или echo "sometext" | sed [params]
     # команды применяются к каждой строке в файле/стдауте
     # -i -сразу поменять в исходном файле
     # sed 's/было/стало/' ./myfile  -замена первого вхождения в кажд строке
     # sed 's_old_new_' # можно применять любой разделитель после s, например
        для замены адресов удобнее так sed 's_/bin/bash_/bin/sh_' или экран ,\/
     # sed -e 's/old/new/'; 's/old2/new2/' ./file  # нескольк команд:
       -e com1; com2; com3; ...
     $ sed -e '  # вводим -е ковычка и многосточная команда :
     > s/This/That/
     > s/test/another test/' ./myfile
     # sed -f cfile ./myfile  # -f файл с командами, а не из стдин
        cfile: пример файла с командами
        # комменты через решетку
        s/This/That/
        s/test/another test/
     # sed 's/old/new/flags' # флаги:
        1  -цифра, каждое 1-е вхождение или какое указано цифрой в строке замещ
        g  -глобально все нахождения в строке замещаются
        p  -print строки в кот-х найд вхождения(исп с ключом -n -подав обыч выв)
        w file  -запись результатов обработки в файл 
     # sed '2s/было/стало/' ./myfile  -замена только во 2-й строке
     # sed '2,3s/было/стало/' ./myfile  -замена в дипазоне с 3-4 строки включ
     # sed '2,$s/было/стало/' ./myfile  -замена со второй до конца
     # sed '/шаблон/s/было/стало/' ./myfile  -поиск строк по регв и применение
     
     #---удаление---
     # sed '1d' ./myfile -удалить 1 строку
     # sed '2,3' ./myfile -удалить диапазон
     # sed '2,$' ./myfile -от и до конца
     # sed '/reg/d' ./myfile - поиск и удаление по шаблону
     # sed '/reg1/,/reg2/d' ./myfile - удаление по шаблону плюс строки между ними
     # sed 's/^.//'  -удалить первый символ    ^.. ^...  -первые 2,3...
     # sed 's/.$//'  -удалить последний символ ..$ ...$  -послед 2,3...
     
     #---вставка---
     # 1 - первая строка, $ - последеяя строка
     # sed '1a\some string' myfile -вставляет строку после зад-ой а\ строки
     # sed '1i\some string' myfile -вставляет строку перед зад-ой i\ строкой
     # sed '3r textfile myfile -вставляет текст из файла после 3-й строки
     # sed '/reg/r textfile myfile -вставляет текст из файла после cтрок с шабл
     
     #---замена целой строки и отдельных символов---
     # sed '3c\modif string' myfile -замена 3-ей строки
     # sed '/reg/c New changed line' .myfile  -амена строк с исп шаблона
     # y/множество1/множество2  -замена как в tr y/123a/456A - пример
     
     #---номера строк
     # sed '=' myfile Выводит номера строк
     # sed -n '/reg/=' myfile  -выведет строки по шаблону с номерами 

# awk - обработка и фильтрация текста ---
# поля по умолчанию разделены пробелом, -F "*" - указать другой разделитель
echo "one two three"| awk '{print $1}' -выборка 1-го поля $NF -последнее
# awk использует переменные, операторы, циклы, условия, целый ЯП...------------

# Форматирование вывода--------------------------------------------------------
nl     # нумерация строк, в простейшем исп как cat -n
       # логическая страница в nl: заголовок: \:\:\:
                                   тело:      \:\:
                                   низ:       \:
       # эти эл-ты стоят отдельно в своих строках, удаляются после фильт-ии nl
       # каждая лог страница нумеруется заново
       # -w6  -по умолчанию поле 6 символов
       # -v1  -начать нумерацию с 1
       # -s'. ' - добавить после номера в кажд строке 
       # -ln -rn -rz  -выравнять по левому,правому,правому+00000
       # также можно нумеровать заголовки и низ, смотреть --help

fold   # перенос строк после указанной длины
       # принимает текст из файла или стд, по умолчанию 80 символов
       # -w12 -s  -перенос с 12 символов, по словам(ближайший пробел)

fmt    # простое форматирование текста, переносы, абзацы
       # -w 39 -ширина текста
       # -c -обработка края. 
       # -p # -обработать строки нач-ся с # или люб др символы

pr     # форматирование текста для печати, разбивка по страницам, длина, шир..

printf # форматирование и выаод данных, не применяется в стд, только в сцен-ях
       # printf "формат" аргументы
       # printf "строка для форматиро%s\n" "вания" -пример подстановки
       # спецификаторы %s %d %f %o %x(%X) %% -строка, десятич, с точкой,8,16,%
       # %[флаги][ширина][.точность]спецификатор
       # флаги: # -альтернативный формат вывода, для 8-х и 16-х чисел
                0 -нули в начало поля, 00045 к примеру
                - -выравнивание по лев краю, по умолч по правому
                  -пробел добавляет пробел перед положительными числами
                + -выводит знак плюс перед положительными числами
       # ширина: минимальная ширина поля вывода
       # .точность: сколько символов после запятоц, для строк -кол-во символов
       # printf "Line: %05d %15.3f Result: %+15d\n" 1071 3.14156295 32589
       # 
       # 
       # 
groff  # система форматирования докум-в, отдельеая большая тема

# печать ---------------------------------------------------------------------+
pr.—.преобразует.текстовые.файлы.для.печати.
lpr.—.печатает.файлы.
lp.—.печатает.файлы.(System.V).
a2ps.—.форматирует.файлы.для.печати.на.принтере.с.поддержкой.PostScript.
lpstat.—.выводит.информацию.о.состоянии.принтера.
lpq.—.выводит.информацию.о.состоянии.очереди.печати.
lprm.—.отменяет.задания.печати.
cancel.—.отменяет.задания.печати.(System.V).

# сравнение-------------------------------------------------------------------+
comm # построчное сравнение 2-х сортированных файлов
     # comm file1 file2  # два сортированных файла, выводятся в 3 колонки
     # 1- уник в 1 файле, 2- во втором, 3- в обоих
     # -123 # цифра параметра соответствует колонке вывод кот-ой подавляется

diff # сравнение построчно. 
     # -c контекстный формат -u унифицированный формат - -строка только в 1ф
                                                       + -строка только во 2ф
patch # изменения в файле 2 относительно файла 1
      # diff -Naur oldfile newfile > patchh.txt
      # patch < patchh.txt - применит изменения и oldfile будет равен newfile

cmp  # сравнения файлов побайтно -s -подавление вывода ----------------------+

# экранирование-------------------------------------------+
"" # экранируют все кроме $ \ `
'' # экранируют все
\  # экранирует спецсимволы в строке в "" $&\` также \n\t\a

# окружение-----------------------------------------------------+
printenv # (/usr/bin/env) - переменные окружения $USER, $PATH ... 
set      # выводит переменные и окружения и оболочки 
alias    # шаблоны
$PATH    # /etc/environment -тут все пути
export   # export PATH делает доступной переменную в дочерних процессах
# файлы запуска для сеансов ком оболочки входа(перед началом сеанса)
/etc/profile    # общисистемный конф сценарий для всех пользователей
~/.bash_profile # собственный файл запуска для определения/переопред сист настроек
~/.bash_login   # либо этот
~/.profile      # либо этот в ubuntu обычно
# файлы запуска для обычной сессии ком оболочки(работа в оболочке)
/etc/bash.bashrc # общесистемный
~/.bashrc        # личный, export PATH=~/bin:"$PATH" -добавление bin в пути

# перемещение курсора--------------+
CTRL+A # в начало
CTRL+E # в конец
CTRL+F # символ вперед
CTRL+B # символ назад
ALT+F  # слово вперед
ALT+B  # слово назад
CTRL+D # удалить символ
CTRL+K # удалить до конца строки
CTRL+U # удалить до начала строки
ALT+D  # удалить до конца слова
ALT+BS # удалить до начала слова
CTRL+Y # вставить из буфера
CTRL+T # меняет символ с предыдущим
ALT+T  # меняет слово с предыдущим

# история--------------------------------------------------------------------+
clear # Ctrl+L очистка экрана
history # история команд !№ком в истории - вып-ся команда
        # поиск в ист CTRL+R ком-да ENTER(вып-ть) или CTRL+J(скопир в ком стр)
        # CTRL+R еще раз - след совпад в поиске.
        # CTRL+G CTRL+C - отмена/выход
script  # запись сеанса оболочки в файл                                  ----+

# привилегии-----------------------------------------------------------------+
/etc/passwd # уч записи
/etc/group  # группы
/etc.shadow # пароли

-rwxrw-r-- 
|\|/\|/\|/
| u  g  o  ugo = a  u-user, g-group, o-other, a-all
|  
+--+ #тип файла
   | - файл
   | d каталог 
   | l симлинк(симв ссылка)
   | с симв.устр(терминал, модем)
   | b блочное устр(hdd, cd-rom)
 
    #файл______________| #каталог______________________
r   читать/открывать   | читать(если +x)
w   запись/усекать     | создавать, удалять, перемещать(если +x)
x   выполнение         | разрешен вход(cd)
-   никаких действий   | никаких действий
s   вып-ся от влад-ца  | совместный каталог группы
t   нет действий       | нельзя удалять и переименовывать (sticky)

bin  oct    +-     umask
0    000    ---    6
1    001    --x       
2    010    -w-    0
3    011    -wx
4    100    r--    2
5    101    r-x
6    110    rw-    0
7    111    rwx

chmod  # изменить режим доступа к файлу
       # chmod u+x, g=rw, o-wx # изменение прав в буквенном знач
       # chmod 600 = (u=rwx, go-rwx) -rwx------ # цифровое изменение
       # chmod u+s, go=rx   = 4755 -rwsr-xr-x, вып-ся от имени владедьца
       # chmod g+s, = 2772 = drwxrwsr-- , совместная директория группы
       # chmod +t dir = 1777 = drwxrwxrwt , нельзя удалять преим
umask  # доступ к файлам по умолчанию
+-актуальные маски имеющие смысл---------+
|umask | bin           |права            | 
|0000  |000 000 000 000| --- rw- rw- rw- |
|0002  |000 000 000 010| --- rw- rw- r-- |
|0022  |000 000 010 010| --- rw- r-- r-- |
|0006  |000 000 000 110| --- rw- rw- --- |
|0026  |000 000 010 110| --- rw- r-- --- |
|0066  |000 000 110 110| --- rw- --- --- |

adduser # по умолчанию создаются параметры дистрибутива
useradd # низкоуровневая утилита, все в ручную
id      # идентичность пользователя uid-номер юзера gid-номер группы юзера..
su      # смена пользователя su user
sudo    # root привилегии (суперпользователь - сп)
sudo su # войти в режим сп в этой же директории с .bashrc .profile пользователя
sudo -i # режим суперпользователя в его директории с его bashrc and profile
chown   # смена владельца chown user
        # смена группы файла chown :user
        # смена влад+группа user:user
passwd  # passwd user - смена пароля пользователя   -----------------------+

# процессы------------------------------------------------------------------+
ps       # список процессов, вып-ся в данный момент
         # ps -el(unix режим) aux(bsd режим) все процессы
         # R - выполняется/готов к выполнению
         # S - приостановлен, в ожидании события   
         # D - приостановлен без возможности прерывания
         # T - остановлен принудительно
         # Z - зомби, завершенный но не удален
         # < - выс приоритет
         # N - низк приоритет
         # niceness - уступчивость от -19 до 20
         # очень много параметров, смотреть man
!        # pid последнего фонового процесса -  echo $!
top      # вып-ся процессы в динамике, показывает загрузку cpu ram
CTRL+C   # прерывание вып-ия прог-мы
CTRL+Z   # приостановить процесс переднего плана(fg)
comm* &  # программа(процесс) запустится в фоновом режиме(на заднем плане bg)
jobs     # список заданий запущенных в терминале
bg       # bg %№задания - переведет процесс из приост-х на задний план
fg       # fg %№задания - переведет процесс(приос-ый или bg) на передний план 
kill     # завершение процесса kill [-сигнал] PID|%№, kill -l - список сиг-в  
killall  # послать сигнал на завершение сразу нескольким пр-ссам
pstree   # дерево процессов
vmstat   # Выводит мгн снимок с информацией об использовании системных рес-в
xload    # нагрузка на систему с теч времени (gui)
tload    # тоже самое но без граф инт --------------------------------------+

# репозитории дистрибутивы пакеты-------------------------------------
# 32 or 64 bit
  i386, x86, IA-32 # 32 bit
  amd64, x86_64    # 64 bit
# пакеты - сжатая кол-ция файлов программ сценариев метаданных...
  debian  # .deb
  red hat # .rpm
# репозиторий - коллекция пакетов
# дистрибутив включает 1 центральный репозиоорий и несколько сторонних
# инструменты управления пакетами
  debian: высокоур: apt, apt-get, aptitude. низкоур: dpkg
  redhat: высокоур: yum. низкоур: rpm
# поиск пакетов
  apt-cache search "pak"
  yum search "pak"
# установка пакетов из репозитория
  apt install "pak"
  yum install "pak"
# установка пакетов из файла
  dpkg --install "pak"
  rpm -i "pak"
#  удаление пакетов
  apt remove "pak"
  yum erase "pak"
# обновление пакетов из реп-ия
  apt update; apt upgrade
  yum update
# обновление пакетов из файла
  dpkg --install "pak"
  rpm -U "pak"
# список установленнвх пакетов
  dpkg -l(--list)
  rpm -qa
# определение установлен ли пакет
  dpkg --status 'name'
  rpm -q 'name'
  apt --help # дружелюбный интерфейс всеикоманды
# сборка и установка программ
  .configure   # поставляется со сборкоц, анализирует сборку, создает Makefile
  make         # выполняет инструкции в макефайле
  sudo make install # установка программы

# устройства хранения----------------------------------------------------------+
/etc/fstab # устройства монтируемые на этапе загрузки
/dev       # директория со всеми устройствами
/dev/sd*   # подключенные уст-ва
df -h      # показывает свободное простанство на дисках
lsblk      # список всех блочных устройств
fdisk -l   # таблица разделов на всех блочных устройствах
blkid      # выводит UUID ид-ры всех подкл устройств, а также файловую систему
lsusb      # информация о всех портах, подробности в man
parted -l  # таблица разделов MBR/GPT


mount  # список монтируемых устр-в
       # mount -t iso9660 /dev/sd? "folder" # монтирование cd-rom
       # mount /dev/sd?1(2,3..) "folder"    # монт флешки
       # mount -t iso9660 -o loop image.iso "folder" # монтирование образа диска
umount # umount /dev/sd? # размонтировать устр-во
fdisk  # проверка диска
fsck   # создание и редактирование разделов на диске/носителе
mkfs   # создание файловой системы на разделе
dd     # копирование устройств
       # dd if=/dev/sdb of=/dev/sdc # копипование диска1 в диск2
       # dd if=/dev/sdb of=disk.img # копипование диска1 в файл
       # dd if=/media/sdrom of=disk.iso # создание образа из cd
       # dd if=disk.iso of=/dev/sdc # загрузочная флешка с образа
md5sum # контрольная сумма md5sum image.iso - проверка после записи
genisoimage # genisoimage -o cd-rom.iso ~/mydir - образ из дир-ии
wodim  # wodim dev=/dev/cdrw blank=fast - очистка cd-rw
       # wodim dev=/dev/cdrw image.iso - запись образа

# форматирование размонтированной флешки
mkfs -t vfat -n NAME /dev/diskname # t - тип ф.системы L или n(для fat32) - имя
# либо использовать сразу без указания фс
mkfs.bfs     mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.vfat
mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.ntfs    mkfs.xfs

# Сети ------------------------------------------------------------------------+
ping       # ping www.yandex.ru - посылает пакеты узлу, проверка работосп-ти
traceroute # показывает все переходы между лок машиной и узлом
netstat    # настройки сети и статистика -ie - интерфейсы
wget       # узел/file загрузка файлов из сети
ssh        # -p port user@ip - подключение к удаленному компу
scp        # -P port user@ip:/file ./ передача файлов сюда
scp        # -P port ./ user@ip:/file передача файлов туда
ftp/sftp   # передача файлов get put вход как по ssh                          

# ssh настройка сервера --------------------------------------------------------+
sudo apt install openssh-server  # установка сервера
sudo systemctl enable sshd       # автозагрузка
/etc/ssh/sshd_config             # фвйл настройки
Port 22                    # изменить на другой
PermitRootLogin - no       # root доступ запрет
PubkeyAuthentication yes 
PasswordAuthentication  - yes # авторизация по паролю
sudo systemctl restart ssh # рестарт юнита
 
ssh-keygen # запустить на клиенте генератор ключа
id_rsa.pub # скопировать на сервер в .ssh/authorized_keys
id_rsa     # остается на клиентской машине
cat ~/.ssh/id_rsa.pub | ssh username@remote_host "cat >> ~/.ssh/authorized_keys"
PasswordAuthentication - no # авторизацию по паролю отключить                   
sudo systemctl restart ssh # рестарт юнита                                    --+

# Поиск файлов ----------------------------------------------------------------+
locate # поиск в базе данных имен locate zip 
find   # сложный способ поиска find "проверки" "операции" "параметры"
       # проверки: -type [fdbsl] тип файла(файл, каталог, устр-ва, ссылки)
                   -name "*.jpg" имя
                   -size +1M файлы более 1Мб (ckMG) байты кило мега гига
                   -perm 777 ищет файлы rwxrwxrwx 
                   -user -group -cmin ...
                   -regex рег выражение 
       # операторы -or -and -not () (файл с одними perm) -or (каталог с др.)
       # операции: -print(по умолч) - выводит полный путь к файлу в стд 
                   -delete - удаляет найденный файл
                   -ls  - ком-да ls -dils в отношении найд файла
                   -quit - завершает ком после нахождения
                   -exec команда '{}' ';' -вып-ся команда для найд файла
                   -ok команда '{}' ';' -запрос y/n перед выполнением ком
                   # меняем ';' на + -все нахождения предадутся команде в виде
                   # аргументов и команда вып-ся один раз, тоже самое xargs
                   -exec comm '{}' +  эквивал | xargs comm
                   # find . -name "*.jpg" -exec cp '{}' ./mydir ';' -копирова-
                    ние файлов .jpg в свою дир-ию
       # параметры: 
                   -noleaf - поиск не в Unix системах
                   -depth снач файлы потом каталоги в кот эти файлы, с del поум
                   -mount не вып обход кат-гов в кот смортир др сист
                   -maxdepth -midepth -глубина --------------------------------+

# поиск текста grep------------------------------------------------------------+
grep # поиск текста по шаблону
grep [парам] рег.выр [файл...]
     # параметры:
     # -E применять метасимволы из расширенного режима - применять всегда
     # -i игнор регистр
     # -v инверсия поиска, сочетается с др пар-ми
     # -c счетчик совпадений
     # -l вывод только имее файлов гдк найдкно совпад
     # -L вывод имен файлов где нет совпадений
     # -n плюс выводятся нумера строк с совпадениями
     # -h вывод без имен файлов, если не одие файл выбран для поиска
     +------------------------------------------------------------------------+
     | базовые регулярные выражения и расширенные grep -E
     | .     - любой символ обязательный
     | ?     - совпадение с предыдущим элементом 0 или 1 раз
     | *     - совпадение с предыдущим элементом 0 или множество раз
     | +     - совпадение с предыдущим элементом 1 или множество раз
     | ^     - якорь начало строки
     | $     - якорь конец строки
     | |     - (или|или) одно из обязательное
     | []    - любой символ в скобках, обязательный
     | [^]   - любой симво не из скобок, обязательный
     | [0-9] - любой из диапазона, обязательныЙ [A-Z]
     | [:class:] - классы POSIX(стандарт)
     | [:alnum:] - Алфавитно-цифровые символы; эквивалент диапазона [A-Za-z0-9]
     | [:word:]  - То же, что и [:alnum:], с дополнительным символом подчерк
     | [:alpha:] - Алфавитные символы; эквивалент диапазона [A-Za-z]
     | [:digit:] - Цифры от 0 до 9
     | [:punct:] - Знаки пунктуации; [-!"#$%&'()*+,./:;<=>?@[\\\]_`{|}~]
     | [:space:] - Пробельные символы [ \t\r\n\v\f]
     |           - и другие
     | {n}   - предыдущий элемент встречается n раз
     | {n,m} - предыдущий элемент встречается не менее n не бoлее m
     | {n,}  - предыдущий элемент встречается n или более раз
     | {,m}  - предыдущий элемент встречается не более m раз 
     +------------------------------------------------------------------------+ 
zgrep # поиск в сжатых файлах -------------------------------------------------

# Архивация и резервное копирование
gzip/gunzip  # упаковать/распаковать gzip -d == gunzip, gunzip -t - просм архива  
bzip2        # поблочная упаковка bunzip2 - распаковка
tar          # помещает файлы и каталоги в архив
             # tar c(создать архив) x(извлеч из архива) t(просмотр) f(имя)
             # tar cf 'имя нового архива.tar' dir - новый архив
             # tar rf dir.tar 'ваши файлы' - добавить в конец архива
             # tar xf dir.tar - извлеч из архива все
             # find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
               добавит в архив только определенные найденные файлы
             # tar cf new.tar --wildcards *.txt - созд архив из .txttar
             # tar czf|cxf new.tgz|new.tbz - создаст сжатый архив gzip|bzip2
             # find . -name "*.txt"|tar cf tar.tar -T -  # дефис - это стд вывод
                                                           -T == --files-from=
             # ssh 192.168.0.106 'tar cf - ~/Music'|tar xf -  # создаем архив
               в стд вывод(cf -) из каталога на удаленном узле и со стд вывода
               извлекам к себе (xf -)
zip          # zip -r dir.zip dir | unzip dir.zip
             # ls -l /etc/ | zip ls-etc.zip -   # исп стд выв для записи в архив
             # unzip -p ls-etc.zip | less   # просмотр (-p - pipe конвейер)
rsync        # синх-я файлов и кат-ов с уд-ой сист-ой: rsync парам ист-к при-к
             # rsync -a dir1 dir2 # -a -рекурсив+права
             # sudo rsync -av --delete --rsh=ssh /etc /usr/local remsys:/backup
                -rsh=ssh -по сети, --delete -удалит на приемнике лишние ф-лы
             # такжe можно настроить синх с серверами rsync в интернете

# ==========================================================================
# Сценарии-------------------------------------------------------------------
#!/bin/bash  -шебанг, дополненный #!/bin/sh, исп-ся в скриптаx bash.
#comment     -комментарии через решетку

# директории с программами и сценариями
/bin            # бинарные файлы исп системой
/sbin           # тоже самое но с правами суперпользователя
/usr/bin        # общисистемные бинарные файлы
/usr/sbin       # тоже самое но с правами суперпользователя
/usr/local/bin  # тоже самое но для ваших сценариев и программ, не устанавливаемых
/usr/local/sbin # с помощью пакет менеджера


# правила писания в баш скриптах
\ -обратный слэш исп в сценариях для разбиения длинных строк \ + перенос стр
echo "pri\
vet"
\n \t \\ \( \) # экранирование спецсимволов
""  # экранирование текста, можно использовать подстановку $
''  # полное экранирование, что напишешь то и выведет
;   # разделитель инструкций в одной строке, так как якобы они в разных
    ls; cd  то же что и ls
                        cd

# код завершения, любой сценарий, ф-я или команда возвращает код завершения
  0       # успешное завершение
  1-255   # ошибка
  echo $? # выводит последний код завершения
  true    # 0
  false   # 1-255

# переменные:---
a=z                 # Присвоит переменной a строку "z".
$a                  # обращение к переменной a
b="a string"        # Внутренние пробелы должны находиться в кавычках.
c="a string and $b" # При присваивании допускается выполнять подстановку
d=$(ls -l foo.txt)  # Результат выполнения команды.
e=$((5 * 7))        # Подстановка результата арифметического выражения.
f="\t\ta string\n"  # Экранированные последовательности, такие как \t \n
a=5 b="hui"         # сразу несколько переменных
${myvar}            # {} -можно огораживать, избегать путанницы где-то
                      например a="foo"; echo "${a}bar"

#строки-----------------------------------------------------------------------
foo=                # пустая переменная
echo ${foo:-"hui"}  # при попытке обращения к пустой переменной выведет хуй
echo ${foo:="bar"}  # если переменная пустая, то присвоить bar
echo ${foo:?"ext"}  # если пустая, то выведет ext в стдерр и выйдет с кодом 1
echo ${foo:+"pls"}  # если пустая, то ничего не выведет, 
                      есди не пустая выведет pls, а значение не изменится
${!префикс*}        # выводят все имена переменных начинаю-ся с префикса
${!префикс@}          ${!BASH*} или ${!BASH@} -выведет кучу переменных
$(#строка)          # если параметр строкa - вернет длину строки,
                      если * или @ - вернет число позиционных параметров
${строка:смещ:длин} # срез строки от смещ до длин, если длин нет тотдо конц
${строка#шаблон}    # *. - удаляет все до первого совпадения с шаблоном и шаб
${строка##шаблон}   # -удаляет все до последнего совпад с шаблоном например /
${строка%шаблон}    # то же как и # только с конца строки
${строка%%шаблон}   # тожк чтоти ## только с конца строки

${параметр/шаблон/строка}  # если в параметре нацден шаблон - замена на строку 1-ое
${параметр//шаблон/строка} # вто же, но во всей строке
${параметр/#шаблон/строка} # то жк но начало
${параметр/%шаблон/строка} # то же но конец

# числа ------------------------------------------------------------------------
$((выражение))      # выражение- любое допустимое арифметическое выражение
# формы записи:
    число           # число в 10-ой системк
    0число          # восьмеричная система
    0xчисло         # шеснадцатиричная система
    основание#число # система по основанию # $((2#010101))
# унарные операторы: + -положительные - -отрицательные
# арифм.  операторы: + - * /(целочмсленное) % **
# опер. присваив.  : = += -= *= /= ++ -- (префиксы, помтфиксы подд-ся)
# битовые опер.    : >> << & | ^ ~(отрицание)
# операторы сравн. : == > < != >= <= && || 
выражение1?выр2:выр3 -тренарный оператор, если 1 истино то 2, иначе 3

bc  # калькулятор в баш

# массивы ----------------------------------------------------------------
a[1]=foo        # создать массив а и присвоить 1-му л значение фуу
                # массивы нумеруются с нуля
declare -a a    # также создать массив а
a=(1 2 3 4)     # присвоитб сразу много щначений
a=([0]=a [1]=3) # множеств-е присваивание по индексу
echo $a{[1]}    # показат , скобки {  }оoбязательны
for i in ${a[*]}; do echo $i; done  # вывод всех эл массива
a=("a" "b" "c d e")
${a[*]}    # "a" "b" "c" "d" "e"
${a[@]}    # "a" "b" "c" "d" "e"
"${a[*]}"  # "a b c d e"
"${a[@]}"  # # "a" "b" "c d e"

${#a[@]}   # кол-во эл-в в массиве
${#a[100]} # длина элемента
"${!a[@]}" # индексы массива которы присвоины переменные
a+=(9)     # добавление нового значения в конец массива

a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort)) # сортировка мас-ва
unset a    # удалить массив а
unset a[0] # удалить 0-й индекс


# функции, 2 вида создания, эквивалентные:
function myfunc {  # 1 вариант
    commands
    return
}
myfunc () {        # 2 вариант
    commands
    return
}
myfunc              -вызов ыункции
myfunc p1 p2 p3     -вызов с параметрами

# ветвление if-else
if условие; then    # if -если возвращаемое значение условия true, т.е. 0
    команды
[elif условие; then
    commands]
[else
    commands]
fi

# команда test, различные проверки и сравнения
test выражение  или  [ выражение ]  или  [[ выражение ]]  -возвращат true/false
# проверка файлов:
      выраж-е       | истино если:
    ----------------+---------------------------------------
    file1 -ef file2 | жесткие ссылки на один и тот же объект
    file1 -nt file2 | 1 новее 2
    file1 -ot file2 | 1 старше 2
            -e file | файл существует
            -b file | файл блочного устр-ва
            -c file | файл символьного устр-ва
            -f file | простой файл
            -d file | каталог
            -L file | символическая ссылка
            -G file | файл пртнадлежит действующей группе
            -O file | файл принадлежит дкйствующему пользователю
            -p file | именованый канал
            -S file | сокет
            -r file | атрибут чтение     \
            -w file | атрибут запись      - для текущего польз-ля
            -x file | атрибут выполнение /
            -u file | атрибут etuid
            -g file | атрибут etgid
            -s file | атрибут ticky bit

test -e "$file"  [ -e "$file" ]  [[ -e "$file" ]] # ковычки обязательны, чтобы
    при проверке гарантировано использовалась пустая строка, при отсут-ии файла

# проверка строк:
    выражение            | истино если:
    ---------------------+-----------
    строка               | строка не пустая
    -n строка            | длина строки больше 0
    -z строка            | длина строки = 0
    строка1 == строка2   | строки равны
    строка1 != строка2   | строки не равны
    строка1 > строка2    | строка1 больше в алфавитном порядке
    строка1 < строка2    | строки1 меньше в алыавитном порядке
    строка =~ ^-?[0-9]+$ | строка соотв-т регвыр, только для [[]]
    строка == *.mp3      | сопоставление с шаблоном wildcards, для [[]]

# test "str1" ">" "str2" # в команде тест знаки в ковычки,
# [ "str1" > "str2" ]  [[ "str" > "str2" ]]
    
# проверка целых чисел:
            выражение            | истино если
    --------------+--------------+
    test и []     | (())         |
    --------------+--------------+------------
    num1 -eq num2 | num1 == num2 | числа равны
    num1 -ne num2 | num1 != num2 | числа не равны
    num1 -le num2 | num1 <= num2 | меньше или равно
    num1 -lt num2 | num1 < num2  | меньше
    num1 -ge num2 | num1 >= num2 | больше или равно
    num1 -gt num2 | num1 > num2  | больше

# test "$num" -eq "$num2"  [ "$num" -eq 10 ] (( "$num" == 10 ))
    
# объединение выражений с помощью логических выражениц
    операция  test []  [[]] (())
       И      -a        &&
      ИЛИ     -o        ||
      НЕ      !         !

[ ((1+2)) -a ((2+3)) ]

# ветвление с помощью операторов управления, подобно && || в [[]]
  команда1 && команда2  # ком1 вып-ся всегда, если true, то вып-ся ком2
  команда1 || команда2  # ком1 вып-ся всегда, если false, то вып-ся ком2
  [ -e myfile ] && cat myfile  # если есть мойфайл то открыть его в кат
  cat myfile || touch myfile   # если есть фацл - открыть, если нет -создать

# case ветвление
case слово in 
    [шаблон[|шаблон]...) команды;;]...
esac

case $REPLY in
    0) echo "program terminsted"
       exit
       ;;
    # используются wildcards, любые шаблоны
    1|2) commands;;
    *.txt) commands;;
    [abs][1-9]) commands;;
    [[:alpha:]]) commands;;
    ???) commands;;
    *) commands;;  # все что не вошло под шаблоны
esac

# read, чтение строки из стдин
read [-параметры] [переменная...] если переменная не указана то сохр в REPLY
  параметры:
    -a массив       - сохр ввод в массив с 0-го индекса
    -d разделмтель  - признак конца ввода, по умолч ентер- \n
    -e              - исп Readline, ввод как в ком строке
    -n число        - читает n-симврлов, а не всю строку
    -p приглашение  - показывать указанное приглашеник к вводу
    -r              - как в питоне строка без поддержки \n\t...
    -s              - sikent режим, не видно что вводишь
    -t секунды      - по истеч времени вернется ненулевое знач
    -u дескриптор   - произвести ввод из файла, а не из стдин
  множество переменных read var1 var2 var3 - пишем через пробел a b c
  REPLY -если не указаны переменные тр сохр сюда
  IFS=":" read var1 var2 var3 <<< /etc/passwd  -временный разделитель ":"
  <<< -оператор встроенная строка, подобно встр документу, но короче-до кон строки

# циклы---------------------------------------------------------------------------
while условие; do команды; done  # пока условие true(0) цикл выполняется
continue # новая итерация
break    # выход из цикла
until    - цикл типа while, только вып-ся условие false
while read distro version release; do  printf "Distro: %s\tVersion: %s\tReleased: %s\n" $distro $version $release; done < distros.txt  
#чтение из файла с пом read, присваивание, вывод
  -либо можно передать по конвейеру: файл|while read var;do ... ; done

# классический for
for переменная [in слова]; do
    команды
done
# без слов обрабатываются по умолчанию позиционные аргументы
for i in a b c d; do...
for i in {a..d}; do...
for i in *.txt; do... # перебор ыацлов тхт

# for в стиле СИ
for ((i=0;i<5;i++)); do
    commands
done

# встроенный метод трассировки, указываем в шебанг +x
#!/bin/bash +x  # будет показано подробное выполнение кода, знак + показывает
  трассировочную информацию, знак + храеится в PS4, ее можно изменить:
  export PS4='$LINENO + '  # поменяли на номер строки +
  set -x  # включение трассировки в коде сценария
  set +x  # выключение трассировки, это можно присеняь прямо в скриптах в коде

# позиционные параметы
# передавая программе аргументы в ком строке их можно использовать так:
    $0    -всегда путь и название программы которая запустилась
    $1-9  -любые аргументы ком строки
    ${10} -если параметров больше 9 - добавляем{}
    $#    -кол-во параметров

    # пример myscript "a" "b" "c d e"
    $*    -все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    $@    -все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    "$*"  -все аргументы в одной строке через пробелы "a b c d e"
    "$@"  -все аргументы, в виде отдельных строк с учетом пробелов "a" "b" "c d e"

shift    -команда которая убирает параметр $1, а все последующие сдвигает на одно
          место к началу, $# становится на 1 меньше, $0 всегда неизменен
basename -команда удаляющая начальную часть пути к файлу
./myscript.sh *  -передать все что есть в тек директории в виде парам-в
# в функциях те же правила, $0 -всегда и везде имя скрипта, $1+ -парам ф-ии
    
# Группы команд и подоболочка ------------------
# группа команд вып-ся в текущей оболочке, а подоболочка - в дочерней(копия),
 после выполнения подоболочки все ее окружение и данные уничтожаются
| -всегда выполняется в подоболочке и все переменные уничтожаются после выхода
{ com1; com2; com3; }   # группа команд, с пробелами рядом со скобками и ; в к-це
(com1; com2; com3)      # подоболочка
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt  # перенап-е
(ls -l; echo "Listing of foo.txt"; cat foo.txt) > output.txt
# подстановка процессов
<(список команд)    # для процессов отправляющих рез-ты на стдаут
>(список команд)    # для процессов принимающих данные на стдин
# подстановка процесов интер-ет вывод подоболочки как обычный файл
  cat <(echo "foo")  -передается как типо это файл, заменяет
  echo <(echo "foo") -выведет /dev/fd/63 -файл где сохр эхо
  read < <(echo "foo")  -сохранит foo в REPLY
# подстановка проц-ов часто исп в циклах с read:
while read myvar1 myvar2; do
    cat <<- EOF
            var1: $myvar1
            var2: $myvar2
    EOF
done < <(ls -l|tail -n +2) -вывод подоб-ки напрвл-ся на стдин цикла(read) 

# Ловушки - сигналы исп-ся процессом
trap команда сигнал [сигнал...]
trap echo "I'm the command!" SIGINT SIGTERM -при попытке прервать сценарий,
                                             выводит эхо
  в кач-ве команды часто используют вызов функции под разные сигналы

# Асинхронное выполнение
wait pid  # приостановка процесса, пока не завершится pid(какой-то фон.проц) 

# Именованные каналы
mkfifo pipe1   - сознание именованного канала
ls -l > pipe1  - перенаправление в им канал
cat < pipe1    - разб-ка канала и принятие данных(можно в другом терминале)

# cron-----------------------------------------------------------+
/etc/crontab       # главный файл который запускает все задачи
/etc/cron.minutely # каждую минуту
/etc/cron.hourly   # каждый час
/etc/cron.daily    # каждый день
/etc/cron.weekly   # каждую неделю
/etc/cron.monthly  # каждый месяц

grep CRON /var/log/syslog # логи

# crontab -l # список задач
# crontab -r # удалить все задачи
# crontab -e # создать задачу
    минута час день месяц день_недели /путь/к/исполняемому/файлу
    все расписано в комментах в crontab -e

# Example of job definition:
     .---------------- minute (0 - 59)
     |  .------------- hour (0 - 23)
     |  |  .---------- day of month (1 - 31)
     |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
     |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) 
     |  |  |  |  |       or sun,mon,tue,wed,thu,fri,sat
     |  |  |  |  |
     *  *  *  *  * user-name command to be executed

    # every minute
     * * * * * /home/ivar/bin/test.txt
    # every Monday at 0:00...
    0 0 * * 1 echo "every monday at 0:00 $(date)" >> /tmp/test.txt
    # every 1st and 15th days of each month at 1:25
    25 1 1,15 * * echo "1, 15 days $(date)" >> /tmp/test.txt
    # every 10 minutes every hour every day...
    */10 * * * * echo "every 10 minutes $(date)" >> /tmp/test.txt
    # every every 3 days...
    0 0 */3 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # every hour(between 0 to 5) at 2:30...
    30 2 0-5 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # 30 Mon-Fri 9am-5pm
    */30 5-9 * * 1-5 echo "every bla-bla-bla $(date)" >> /tmp/test.txt


# ---examples---
# every minutes every hour every day...
#* * * * * echo "every minutes $(date)" >> /tmp/test.txt
# 0:30, 1:30, 2:30, 3:30 ... 
#30 * * * * echo "each 30 min every hours $(date)" >> /tmp/test.txt
# each 5:30 every day, every month...
#30 5 * * * echo "each 5:30 every day $(date)" >> /tmp/test.txt
# every 1st day in month at 5:30 every month...
#30 5 1 * * echo "each 1st day in month at 5:30  $(date)" >> /tmp/test.txt
# every feb 1st day in month at 5:30 every year`...
#30 5 1 2 * echo "each 1st day in Feb at 5:30 every year $(date)" >> /tmp/test. txt

    
# locale----------------------------------------------------------------
locale          # информация о текущем языковом окружении
locale -a       # список всех установленных языков и кодировок -v - подробно
echo $LANG      # посмотреть настройки языка и кодировки
/etc/locale.gen # Список всех поддерживаемых (доступных для установки) локалей
locale-gen      # установить все локали из /etc/locale.gen()
locale-gen de_DE.UTF-8  # установка какой-либо локали
LANG=ru_RU.utf8         # изменить локаль на текущую сессию
export LANG=en_US.utf8  # добавить в .bashrc для изменения на постоянной основе
localectl set-locale LANG=en_US.utf8  # изменить локаль по умолчанию
/etc/default/locale     # локаль по умолчанию

# способы сохранения активности процессов при закрытии терминала--------
./command &       # запуск программы в фоне           \
jobs -l           # посмотреть номер нужного процесса - 1 способ
disown %1         # удаление задачи                   /
nohup ./command & # вывод перенаправлен в 'nonhup.out' -2
screen and tmux   # также используются для этих целей  -3

# GNU/Linux-------------------------------------------------------------
Ядро — основа операционной системы. Оно непосредственно взаимодействует 
  с аппаратурой. С ядром можно взаимодействовать с помощью приложений — 
  с помощью предоставляемого приложениям программного кода.
Linux is kernel (ядро ОС)
Дистрибутив включает ядро и доп компоненты.
GNU — операционная система типа Unix, программы которой свободны (cat, grep, 
  awk, bash унаследованы от Unix)
Этапы загрузки ОС:
Включение
BIOS +MBR:
Плата EEPROM, на которой хранится Биос отправляет код процессору на исполнение.
Биос производит проверку оборудования(тест POST)
Обращается к ЖД к первым 512 байтам - там находится MBR
MBR передает управление GRUB, находящемся сразу за ней.
UEFI +GPT
проверка устройств, обращение к таблице разделов GPT, а именно к разделу EFI, 
  директория BOOT - в ней находится загрузчик, например GRUB
Загрузчик передает ядру параметры и запускает ядро
Загрузка ядра /boot/vmlinuz (vm - ядро будет размещено в опер памяти, 
  z - требует распаковку)
Настройка оборудования
Планировщик задач …
Запуск пользовательских служб - systemd
Экранный менеджер, окружение раб стола



