# git

--- Settings --------------------------------------------------------------
~/.gitconfig                                    # all settings
git config --list								# all settings
git config --list --show-origin					# the same + location of
                                                  config files
git config user.name							# show a value of a key
git config --global user.name "my Name"       	# name
git config --global user.email myemail@ex.hu  	# email
git config --global core.editor vim				# default editor
git config --global init.defaultBranch main		# name of main default new 
												  branch(master is default)
git config --global pull.rebase "true/false"	# true - перебазирование 
												  при получении изменений.
                                                  false - смещение вперёд если 
												  возможно — иначе создание 
												  коммита слияния.
git config --global credential.helper cache  --timeout 3600
                                                # пароли сохраняются 1 час
git config --global credential.helper 'store --file ~/.my-credentials'
                                                # пароли сохр на диске
Пример если есть файл с учётными данными на диске, но, на случай его отсутствия, 
вы хотите дополнительно использовать кеширование в оперативной памяти.                           
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000

--- Help -----------
git help <команда>
git <команда> --help
man git-<команда>

--- What is Git -------------------------------------------------------------
origin  # это название по умолчанию для удалённого сервера, при запуске 
          git clone. Если выполнить git clone -o booyah, то по умолчанию 
          ветка слежения будет иметь вид booyah/master.
master  # это название по умолчанию для ветки при выполнении git init

# Git хранит информацию в виде набора снимков(snapshot).
  Когда вы делаете коммит, Git сохраняет его в виде объекта, который содержит
  указатель на снимок (snapshot) подготовленных данных. Этот объект так же 
  содержит имя автора и email, сообщение и указатель на коммит или коммиты 
  непосредственно предшествующие данному (его родителей): отсутствие родителя
  для первоначального коммита, один родитель для обычного коммита, и несколько
  родителей для результатов слияния двух и более веток.

# Что происходит при индексации.
  Во время индексации Git вычисляет котрольные суммы для всех добавляемых
  файлов, затем каждый файл сохраняется в пепозиторий.
  Blob - большой бинарный объект - это 1 файл.
  Контрольная сумма попадает в индекс.

# Что происходит при коммите.
  Git вычисляет контрольные суммы каждого подкаталога и сохраняет его в
  репозитории как объект дерева каталогов. Затем Git создаёт объект коммита
  с метаданными и указателем на основное дерево проекта для возможности 
  воссоздать этот снимок в случае необходимости.

# Структура снимка
   объект коммита           об дерева каталогов       blob объекты
        98ca9                                            5b1d
  +------------------+           92ec2               +-----------+
  |commit       size |     +-------------------+ --> |blob size  |
  |tree         92ec2| --> |tree size          |     |"Some text"|
  |parent       ca23c|     |blob 5b1d README.md|     +-----------+
  |author       Ivar |     |blob cba0a test.py | 
  |committer    Ivar |     +-------------------+ -+      cba0a
  +------------------+                            |  +-----------+
                                                  +->|blob size  |
                                                     |"some code"|
                                                     +-----------+

# main states of files
tarcked			- отслеж файлы(добавленные в индекс)(те о котор знает git)
    unmodified  - не измененные(после коммита или клонирования)
    modifed     - (измененные)поменялись, но ещё не были закоммичены
    staged      - (индексированный) это изменённый файл в его текущей версии,
                  отмеченный для включения в следующий коммит.
    commited    - (зафиксированный) файл уже сохранён в вашей локальной базе
untracked		- это всё остальное, любые файлы в вашем рабочем каталоге, 
				  которые не входили в ваш последний снимок состояния 
				  и не подготовлены к коммиту.
	Untracked  Unmodified  Modified  Staged
		|           |          |        |
		+------------------------------>| - add the file
		|           +--------->|        | - edit the file
		|           |          +------->| - stage the file
		|<----------+                   | - remove the file
		            |<------------------+ - commit

# main sections of a Git project
Working directory           - снимок одной версии проекта
Index                       - что попадёт в следующий коммит
.git derectory(Repository)  - метаданные и база объектов вашего проекта
	Working dir  Index  .git
		|          |      |
		|<----------------+ - checkout the project
		+--------->|      | - stage fixes
				   +----->|	- commit
    
--- Getting a Git Repository -------------------------------------------------
git init        # создание репозитория в сущ каталоге. Создается дир-я .git
                  содерж все необх файлы репозитория — структуру Git реп-ия.
git clone <url> # с сервера забирается (pulled) каждая версия каждого файла из
                  истории проекта. Извлекается рабочая копия последней версии. 

--- Basics ------------------------------------------------------------
# status
git status                      # посмотреть состояние файлов, ветку,...
git status -s                   # short version.

# diff
git diff						# что изменено но не в индексе.
git diff --staged				# что в индексе и готовится к коммиту.

# add
git add <file> or -A        	# add file to index(подготовка к коммиту)
git reset HEAD <file>          	# отменить add, файл будет не в индексе
git restore --staged			# тоже - отмена индексации файла
 
# commit
git commit -m "Initial commit." # коммит, фиксация изменений, -m - коммент
git commit -a					# add + commit of trackied files
git commit --amend				# переделать/заменить последний коммит
								  можно добавить/удалить то что забыли, 
								  выполнить add, переписать сообщение.
# Отмена/откат
git checkout -- <file>			# для неиндексированного файла отменить все 
git restore <file>				  изменения, вернуть состояние файла до 
								  состояния последнего коммита.
git reset HEAD <file>           # отмена индексации файла, 
git restore --staged <file>       HEAD - the last commit

# delete
git rm <file>					# удаляет из раб каталога и из индекса
git rm --cached                 # удалить из индекса
git restore --staged			# удалить из индекса
rm <file> + git add <file>      # то же самое

# move/rename
git mv file_from file_to        # переименовать
mv f1 f2 + rm f1 + add f2       # то же самое

--- Commit History -------------------------------------------------------------
git log                         # перечисляет коммиты, сделанные в репозитории
                                  в обратном к хрон порядку. HEAD - последний
								  коммит текущей ветки(при переключ - меняется)
git log anotherBranch           # история коммитов ветки 'anotherBranch'
git log --all                    # история коммитов всех веток
git log -p -2                   # показывает разницу(патч/patch) между комм
                                  2 - лимит записей
git log --stat                  # сокращенная статистика
git log --pretty=oneline        # еще аргументы short, full, fuller, format 
                                  меняет формат вывода для удобства.
git log --pretty=format:""      # свой формат вывода, напр "%h - %an, %ar : %s"
git log --pretty=oneline --graph  графы веток, коммитов (также с опцией oneline)
    Опции в форматированном выводе:
    Опция   | Описания вывода
    --------+----------------
    %H      | Хеш коммита
    %h      | Сокращенный хеш коммита
    %T      | Хеш дерева
    %t      | Сокращенный хеш дерева
    %P      | Хеш родителей
    %p      | Сокращенный хеш родителей
    %an     | Имя автора
    %ae     | Электронная почта автора
    %ad     | Дата автора (формат даты можно задать опцией --date=option)
    %ar     | Относительная дата автора
    %cn     | Имя коммитера
    %ce     | Электронная почта коммитера
    %cd     | Дата коммитера
    %cr     | Относительная дата коммитера
    %s      | Содержание

    Наиболее распространенные опции для команды git log:
    Опция	        | Описание
    ----------------+-------------------------------------
    -p              | Показывает патч для каждого коммита.
    --stat          | Показывает статистику измененных файлов для каждого коммита.
    --shortstat     | Отображает только строку с количм изменений/вставок/удалений
                    | для команды --stat.
    --name-only     | Показ список измененных файлов после информации о коммите.
    --name-status   | Показ список файлов, которые добавлены/изменены/удалены.
    --abbrev-commit | Показ только неск символов SHA-1 чек-суммы вместо всех 40.
    --relative-date | Отображает дату в относительном формате (например, 
                    | «2 weeks ago») вместо стандартного формата даты.
    --graph         | Отображает ASCII граф с ветвлениями и историей слияний.
    --pretty        | Показывает коммиты в альтернативном формате. Возможные
                    | варианты опций: oneline, short, full, fuller и format
    --oneline       | Сокращение для одновременного использования 
                    | опций --pretty=oneline --abbrev-commit.

--- Ограничение вывода ---------------------------------------------------------
git log -2                  # два последних коммита
git log 
git log --since=2.weeks     # список коммитов, сделанных за последние две недели
git log --until=2.days      # список коммитов, сделанных до 2-х дней назад
--since=2008-01-15			# точная дата
2 years 1 day 3 minutes ago # относительная дата
--author 					# дает возможность фильтровать по автору коммита
--grep 						# искать по ключевым словам в сообщении коммита.
git log -S some_string		# коммиты, в которых изменение в коде повлекло за
							  собой добавление или удаление этой строки.
git log -- path/to/file		# коммиты, в которых были изменения этих файлов

	Опции для ограничения вывода команды git log:
	Опция	    | Описание
    ------------+----------------------------------------
	-n			| Показывает только последние n коммитов.
	--since,	| Показывает только те коммиты, которые были сделаны 
	--after 	| после указанной даты.
	--until,	| Показывает только те коммиты, которые были сделаны 
	--before	| до указанной даты.
	--author	| Показывает только те коммиты, в которых запись author 
			    | совпадает с указанной строкой.
	--committer	| Показывает только те коммиты, в которых запись committer 
	            | совпадает с указанной строкой.
	--grep		| Показывает только коммиты, сообщение которых содержит 
			    | указанную строку.
	-S			| Показывает только коммиты, в которых изменение в коде 
				| повлекло за собой добавление или удаление указанной строки.
	--no-merges	| Исключить коммиты слияния.

Exammple:
git log --pretty="%h - %s" --author='Hamano' --since="2008-10-01" 
	--before="2008-11-01" --no-merges -- t/

--- Remotes ----------------------------------------------------------
# Удалённые репозитории представляют собой версии вашего проекта
  может быть несколько удалённых репозиториев, каждый из которых может
  быть доступен для чтения или для чтения-записи.
git remote              	# названия доступных удалённых репозиториев.
                              origin - имя сервера по умолчанию с которого
                              производится клонирование.
git remote -v       	    # адреса для чтения и записи, привяз к реп.
git remote add <repn> <url>	# доб реп и дать ему свое короткое имя 'repn',
							  так можно связать новый лок реп с GitHub.
git fetch [remote]			# связаться с реп, получить изменения кот еще нет,
							  после появятся ссылки все ветки, кот можно
							  смотреть или слить. Не модифицирует то, над чем 
							  вы работаете в данный момент, сливается вручную.
git clone <url>				# автоматически добавляет реп с названием 'origin'
							  и настраивает локальную ветку master на 
							  отслеживание удалённой ветки master на сервере.
git pull 					# извлекает (fetch) данные с сервера, с которого вы
                              изначально клонировали, с ветки по умолчанию
							  и автоматически пытается слить (merge) их с кодом
							  в вашей working directory
git push <remote> <branch>  # отправка коммитов локальной ветки 'branch' на 
							  удалённый репозиторий 'remote' (в ту же ветку).
git push origin fix:huix    # отправит локальную ветку fix в ветку huix 
                              удалённого репозитория origin, свяжет их
git remote show <remote>	# больше информации об одном из удалённых реп.
							  показывает куда и откуда будет что вливаться, 
							  какие ветки есть и как все настроено.
git remote rename <o> <n>	# переименовать реп 'o' to 'n'.
git remote remove <remote>	# удалить репозиторий.

--- Tags/тэги -------------------------------------------------------------
git tag						# список тэгов
git tag -l "v1.8.*"			# список тегов соотв шаблону (нач-ся на v1.8.)
# 2 типа тэгов
	1. lightweight(Легковесный тег) — это что-то очень похожее на ветку,
	   которая не изменяется — просто указатель на определённый коммит.
	2. annotated(аннотированные теги) - хранятся в базе данных Git как 
	   полноценные объекты. Они имеют контрольную сумму, содержат имя автора,
	   его e-mail и дату создания, имеют комментарий и могут быть подписаны
	   и проверены с помощью GNU Privacy Guard (GPG).
git tag -a v1.4 -m "msg"	# создать annotated tag, msg - комментарий
git tag v1.0-lw				# создать легковесный тэг
git show v1.4				# показать данные тега вместе с коммитом, для 
							  lightweight покажет только коммит.
git tag -a v1.2 9fceb02		# пометить любой коммит в истории, 9fceb02 - к.сум
git push origin <tagname>	# отправить тэг на удаленный сервер
git push origin --tags		# отправить на сервер все тэги
git tag -d v1.4-lw			# удалить тэг с локального репозитория
git push origin --delete tg	# удалить тэг 'tg' с сервера
git checkout v2.0.0			# получить версии файлов, на которые указывает тег,
							  ряд неприятных побочных эффектов, см доки.
git checkout -b ver2 v2.0.0	# создать ветку по тэгу.

--- Branches/ветки ---------------------------------------------------------
# Ветка в Git — это простой перемещаемый указатель на один из коммитов. 
  master - имя основной ветки в Git по умолчанию(можно другое). 
  Ветка master будет всегда указывать на последний коммит. 
  Каждый раз при создании коммита указатель ветки master будет передвигаться
  на следующий коммит автоматически.

# Структура веток при создании ветки
                             HEAD   указатель на текущую локальную ветку
                              |
                  features  master  ветки
                        \   /
    98ca9 <-- 34ac2 <-- f30ab       коммиты
      |         |         |
  snapshot1 snapshot2 snapshot3     snapshots
# сделав коммит на одной, вторая остается на старом месте,
  переключившись на нее мы восстановим файлы как при том коммите.
                                  HEAD   указатель на тек локальную ветку
                                    |
                  features        master     ветки
                        \           /
    98ca9 <-- 34ac2 <-- f30ab <-- c2e41      коммиты
      |         |         |
  snapshot1 snapshot2 snapshot3     snapshots
# переключились снова на другую и сделали коммит - ветки разошлись.
                               features -- HEAD
                                 |
                              / b12f    
    98ca9 <-- 34ac2 <-- f30ab          
      |         |         |   \ c2e41
  snapshot1 snapshot2 snapshot3    |    
                                 master

git branch features         # создать ветку 'features', точная копия master,
                              новый указатель на текущий коммит.
git checkout features       # переключение на ветку 'features'
git switch features         # переключение на ветку 'features'
git checkout -b new-branch  # создать и сразу переключиться
git switch -c new-branch    # создать и сразу переключиться
git branch                  # показывает ветки и на какой находимся мы
git branch -v               # показывает ветки с последними коммитами
git branch --merged         # уже слитые ветки с текущей
git branch --no-merged      # не слитые ветки
git branch -d hotfix        # delete branch 'hotfix'
git branch -D hotfix        # delete branch 'hotfix', даже если она не слитая
git branch --move old new   # переименовать ветку 'old' to 'new'

--- Merge/Слияние -----------------------------------------------------------
В Git есть два способа внести изменения из одной ветки в другую: 
слияние и перебазирование.

git merge hotfix            # слияние в текущую ветку ветки 'hotfix'

Виды слияния:
fast-forward        в том случае если сливаемая ветка является прямым потомком 
                    текущей ветки - простое перемещение указателя вперед.
                    master  hotfix           master/hotfix
                    --*-------*    merge  --*------*

recursive strategy  коммит, на котором мы находимся, не является прямым
                    родителем ветки, с которой мы выполняем слияние Git
                    выполняет простое трёхстороннее слияние, используя
                    последние коммиты объединяемых веток и общего для них
                    родительского коммита, создаётca новый результирующий
                    снимок трёхстороннего слияния, а затем автоматически делает
                    коммит. Этот особый коммит называют коммитом слияния, так
                    как у него более одного предка. Будет предложено дать
                    имя коммиту через редактор.
                    common ancestor   master                        master
                    ------*-------------*       merge  *---------------*
                           \_________* issue53          \_____________/
                                                                  issue53

CONFLICT (content)  если была изменена одна и ту же часть одного и того же
                    файла по-разному в двух объединяемых ветках.
                    git status - посм какие файлы не объед 'Unmerged paths'
                    Внутри файла будут такие строки, все исправлять вручную.
                    <<<<<<< HEAD:index.html
                    <div id="footer">contact : email.support@github.com</div>
                    =======
                    <div id="footer">
                     please contact us at support@github.com
                    </div>
                    >>>>>>> iss53:index.html
                    После исправлений добавить в инд эти файлы и закоммитить.

--- Rebase/перебазирование --------------------------------------------------
Второй способ внести изменения из одной ветки в другую.
rebase              если в текущей ветке issue53 выполнить rebase master,
                    то вся история текущей ветки перепишется, и создаться 1
                    коммит впереди ветки master с примененными всеми коммитами
                    ветки issue53, а преждняя истоия ветки issue53 исчезнет и 
                    будет недоступна. Rebase подходит если веткой занимается 
                    1 разработчик и для более чистой истории. Merge более
                    безопасен, но история получается не такой эстетичной за
                    счет коммитов слияния.
                    common ancestor   master                 master issue53
                    ------*-------------*       rebase *-------*-------*
                           \_________* issue53          \______x

git checkout issue53    # переключимся на ветку issue53
git rebase master       # перебазировать issue53 относительно ветки master
git checkout master     # переключиться на master            master/issue53
git merge issue53       # выполнить слияние перемоткой *-----------*
                          


--- Работа с ветками --------------------------------------------------------
master  - главная ветка, полностью стабильный код.
next    - предназначенная для работы и тестирования стабильности, она не 
          обязательно должна быть всегда стабильной, но при достижении 
          стабильного состояния ее содержимое можно слить в ветку master.
          Она используется для слияния заверш-ых задач из тематических веток.
iss#53  - тематические ветки iss1 - iss100... временные, сливаются в ветку
          next после выполнения нужной задачи.

____.  master
     \_____.  next
            \___.  issue53

--- Удаленные ветки ----------------------------------------------------------
Удалённые ссылки — это ссылки (указатели) в ваших удалённых репозиториях, 
включая ветки, теги и так далее.
git branch --all                        # все ветки локал + удал на сервере
git ls-remote <remote>                  # полный список удалённых ссылок
git remote show <remote>                # полный список удалённых ссылок
git push --set-upstream origin hofix    # залить ветку в репозиторий на сервер
                                          и сделать текущ ветку - веткой слеж
git push origin --delete hotfix         # удалить ветку из реп-я на сервере

Серверный и локальный репозитории после клонирования: 
    git.ourcompany.com      My computer
                master              origin/master   # remote branch
                  |                       |
    ----*----*----*         ----*----*----*
                                          |
                                        master      # local branch

Если сделать что-то в своей локальной ветке master, а тем временем кто-то 
отправит изменения на сервер git.ourcompany.com и обновит там ветку master, 
то истории продолжатся по-разному. Пока вы не свяжетесь с сервером origin 
ваш указатель origin/master останется на месте.
Локальная и удалённая работа может расходиться:
    git.ourcompany.com      My computer
                master    origin/master             # remote branch
                  |             |
    ----*----*----*         ----*----*----*
                                          |
                                        master      # local branch

git fetch origin    # Эта команда определяет какому серверу соответствует 
                      «origin» (в нашем случае это git.ourcompany.com), 
                      извлекает оттуда данные, которых у вас ещё нет, и 
                      обновляет локальную базу данных, сдвигая указатель 
                      origin/master на новую позицию.
git fetch обновляет ветки слежения:
    git.ourcompany.com      My computer
                master               origin/master  # remote branch
                  |                       |
    ----*----*----*         ----*----*----*
                                 \___*____*
                                          |
                                        master      # local branch

Несколько серверов(git remote add teamone git://git.team1.ourcompany.com).
Добавление ещё одного сервера в качестве удалённой ветки:
git.ourcompany.com      git.team1.ourcompany.com    My computer
           master             master                         origin/master   
             |                  |                                 |
    ----*----*         ----*----*                   ----*----*----*
                                                         \___*____
                                                                  |         
                                                                master

git fetch teamone   # получ всех изменений с сервера teamone, котор нет локально
Еще одна ветка слежения teamone/master:
git.ourcompany.com      git.team1.ourcompany.com    My computer
           master             master               teamone/master  origin/master   
             |                  |                            |     /
    ----*----*         ----*----*                   ----*----*----*
                                                         \___*____
                                                                  |         
                                                                master

Отслеживание веток:
Tracking branch/Ветка слежения  # локальная ветка связанная с удаленной
Upstream branch                 # удал ветка за которой следит лок ветка
git branch -vv                  # посмотреть как настроены ветки слежения,
                                  до этого получить все изм git fetch --all

Отправка и получение изменений:                                                                
git push <remote> <branch>      # отправить лок ветку на сервер
git merge origin/fix            # слить удал ветку в свою текущую рабочую ветку
git pull                        # находясь на ветке слежения получить данные
                                  с ее upstream branch с нужного сервера и
                                  провести merge - иными словами pull это
                                  git fetch + git merge

Создать ветку слежения:
git checkout -b fix origin/fix  # создать локальную ветку на основе удаленной
git checkout -b huix origin/fix # создать лок ветку на основе удал, но с другим
                                  именем, git свяжет их.
git checkout --track origin/fix # создать локальную ветку на основе удаленной
git checkout fix                # попытка извлечь ветку, которая не существует, 
                                  но существует только одна удалённая ветка с 
                                  точно таким же именем, то Git автоматически 
                                  создаст ветку слежения.
git branch -u origin/serverfix  # Если уже есть локальная ветка и нужно настроить 
                                  ее на слежение за удалённой веткой, которую  
                                  только что получили, или хотите изменить 
                                  используемую upstream-ветку.
                                  -u или --set-upstream-to


--- Ignoring Files --------------------------------------------------
# создаем файл .gitignore добавляем в него все что хотим игнорировать
wild cards:
    шаблоны применяются рекурсивно для всего дерева каталогов
    #       - пустые или строки начинающ с '#' игнорируются
    *       - 0 or more symbols
    ?       - 1 symbol
    [qw]    - q or w, matches any character inside the brackets
    [0-9]   - matches any character between range
	каталоги/вложенность:
    /temp   - файлы попадающ под шаблон 'temp' только в корневом каталоге
    temp/   - исключить директорию попадающ под шаблон 'temp'
    !temp   - инвертировать шаблон
    a/**/z  - вложенный каталог (a/z, a/b/z, a/b/c/z, и так далее)


--- GitHub Forks ---------------------------------------------------
Создайте форк проекта.
Создайте тематическую ветку на основании ветки master.
Создайте один или несколько коммитов с изменениями, улучшающих проект.
Отправьте эту ветку в ваш проект на GitHub.
Откройте запрос на слияние на GitHub.
Обсуждайте его, вносите изменения, если нужно.
Владелец проекта принимает решение о принятии изменений, либо об их отклонении.
Получите обновлённую ветку master и отправьте её в свой форк.
