# Spring

--- Spring ---
    Это фреймворк, предназначенный для более быстрого и простого
    построения Java приложений.
    Создан: 2004.
    Последняя версия: Spring 5
    site: www.spring.io

--- Inversion of Control ---
    IoC - аутсорсинг создания и управления объектами. Т.е. передача нами
    прав на создание и управление объектами нами to Spring.

    Spring Container    - создание и хранение объектов
    config file         - описывает объекты кот будет создавать Container
    MyClass             - обращается к Container для получ объекта, а 
                          не создает их самостоятельно.

    MyClass <=====> Spring Container <--- config file
                                         /     |     \
                                       Dog    Cat    ...

    Основные функции Spring Container:
    IoC     - Inversion of Control, инверсия управления.
              Создание и управление объектами.
    DI      - Dependency Injection, внедрение зависимостей.

    Способы конфигурации Spring Container:
    XML file (устаревший способ)
    Annotations + XML file (современный способ)
    Java code (современный способ)

    Spring Bean (или просто bean/бин) - объект, который создается и 
    управляется Spring Container.
   
--- Способ #1 через xml file ---
    // создаем файл в директории resources(root) "applicationContext.xml"
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <bean id = "myPet"  // id используется при создании бина
            class = "io.github.ivan100kg.spring_intro.Dog"> // full classname
        </bean>
    </beans>

    Создать Spring Container:
    ApplicationContext - это и есть Spring Container.
    // для способа 1, с пом xml, Pet - interface for Dog,Cat..
    ClassPathXmlApplicationContext context =        // get context
            new ClassPathXmlApplicationContext("applicationContext.xml");
    Pet pet = context.getBean("myPet", Pet.class);  // get bean (id, Class)
    pet.say();                                      // call Dog method
    context.close();                                // close context
    
    Теперь мы можем получать и управлять объектом Dog через 
    Spring Container, вызывая его по id - это и есть бин, чтобы 
    изменить напр Dog на Cat, нужно просто заменить в applicationContext.xml
    аттрибут class на io.github.ivan100kg.spring_intro.Cat

--- Dependency Injection ---
    DI - аутсорсинг добавления/внедрения зависимостей.
    DI делает объекты нашего приложения слабо зависимыми друг от друга.

    Способы внедрения зависимостей:
    с помощью конструктора
    с помощью сеттеров
    Autowiring
    
    Способ #1 - с помощью конструктора:
    Допустим есть класс Person, который has an another class inside(Pet):
        public Person(Pet pet) {    // конструктор принимает об другого класса
            this.pet = pet;
        }
    Допишем зависимость в наш applicationContext.xml:
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog">
        </bean>

        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <constructor-arg ref="myPet"/>  // constructor-arg - арг костр
        </bean>                             // ref - ссылка bean id
    Далее можно не создавая класс Dog/Cat создать Person:
        Person person = context.getBean("myPerson", Person.class);
        person.callYourPet();   // some method of Person
        context.close();

    Способ #2 - с помощью setter:
    Добавим метод setPet to Person:
        public void setPet(Pet pet) {
            this.pet = pet;
        }
    Изменим applicationContext.xml:
        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <property name="pet" ref="myPet"/>  // свойство pet -> метод setPet
        </bean>                                 // перв буква стан заглав -> Pet
                                                // внач добав set + Pet = setPet()
    Работает все также, код менять не надо - просто др способ.

    Внедрение других значений через методы(сеттеры):
    Например в классе есть 2 поля не иниц через конструктор, но нужно вызвать
    их сеттеры:
        // поля
        private String surname;
        private int age;
        // сеттеры
        public void setSurname(String surname) { this.surname = surname; }
        public void setSurname(int age) { this.age = age; }
    // как вызвать с пом applicationContext.xml 
    // способ #1 прямо в файле applicationContext.xml 
    <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
        <property name="pet" ref="myPet"/>
        <property name="surname" value="Bond"/> // value - передать значение
        <property name="age" value="39"/>       // name - св-во age->setAge()
    </bean>
    // способ #2 с пом др файла myFile.properties:
        person.surname = Bond   // создадим файл resources/myFile.properties
        person.age = 39         // добавим эти строки в myFile.properties
    // добавим эту строку перед всеми бинами
        <context:property-placeholder location="classpath:myApp.properties"/>
        classpath - местонахождение пользовательских классов(resources там же)
    // изменим applicationContext.xml 
        <property name="surname" value="${person.surname}"/>    // подставим
        <property name="age" value="${person.age}"/>
    Вызов значений из др файла ${name}, name может быть любым, но
    парвильнее и более понятно уточнять типа person.age
        

    }

--- Bean scope ---
    Scope - область видимости, определяет:
        жизненный цикл бина
        возможное кол-во создаваемых бинов
    Разновидности bean scope:
        singletone      // default, если не указан scope, 1 общий бин
        prototype       // бины создаются каждый раз при обращении getBean()
        request
        session
        global-session
    
    Singletone
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="singleton">    // можно не указывать
        </bean>
    Этот бин создается сразу после прочтния контейнером конфиг файла.
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext2.xml"
        );
        bean сдесь уже создан один и для всех.
    Является общим для всех, кто запросит его у контейнера.
        // получаем ссылки на бин
        Dog dog1 = context.getBean("myPet", Dog.class);
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // true
    Подходит для stateless объектов.(не хранящих состояния)

    Prototype
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="prototype">    // scope
        </bean>
    Такой бин создается только после обращения к контейнеру с пом getBean()
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        Dog dog1 = context.getBean("myPet", Dog.class); // создание
    При каждом обращении создается новый бин.
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // false
    Подходеит для stateful объектов.(хранящих состояние, например поле имя)

--- Life Cycle of bean ---
    Запуск      -->  Начало работы     -->  Создание  -->  DI - внедряются
    приложения       Spring Container       бина           зависимости
                                                                  |
    Конец работы  <--  Использование  <--  Бин готов для  <--  init-method
    Spring Container  нами этого бина     использования
          |
    destroy-method  -->  Остановка
                         приложения

    init-method используется для открытия или настройки каких-либо
    ресурсов(базы данных, стримы ...). Вызывается автоматически, можно
    использовать для запуска нашего кода при создании бина.
    
    destroy-method используется для закрытия этих ресурсов. Тут пишется
    логика после окончания работы с бином, перед его уничтожением. Также 
    вызывается автоматически. Если scope=prototype то destroy НЕ вызывается.

    Использование своего кода при init-method destroy-method:
    // добавим методы в наш класс Dog(такие названия не обязательно),
    модификаторы могут быть любыми
    return-type может быть любым, но так как не исп-ся - используют void
    параметров быть не должно.
        private void init() {
            System.out.println("class Dog: init method");
        }
        private void destroy() {
            System.out.println("class Dog: destroy method");
        }
    // свяжем их в applicationContext.xml
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog"
            init-method="init"          // методы можно называть как угодно
            destroy-method="destroy">
        </bean>
    // теперь при создании и закрытии бина
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        // тут авто вызовется init() если scope НЕ prototype
        Dog dog = context.getBean("myPet", Dog.class);
        // тут авто вызовется init() для кажд бина если scope=prototype
        dog.say();
        context.close();
        // тут авто вызовется destroy() если scope НЕ prototype

--- Способ #2 - с помощью аннотаций ---
    Это более короткий и быстрый способ.
    Процесс в 2 этапа:
        сканирование классов и поиск аннотаций @Component
        создание(регистрация) бина в Spring Container
    
    // Для сканирования необходимо указать в applicationContext.xml где сканировать:
        <context:component-scan base-package="io.github.ivan100kg"/>
        Указываем эту строку и наш главный пакет с классами.

    // Теперь пометим наш класс аннотацией @Component
    @Component("catBean")   // сдесь задаем люб имя бина, либо по дефолту будет cat
    public class Cat implements Pet{
        @Override
        public void say() {
            System.out.println("Meow-Meow");
        }
    }

    // Создадим ApplicationContext и бин
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
    );
    Cat cat = context.getBean("catBean", Cat.class);
    cat.say();
    context.close();



