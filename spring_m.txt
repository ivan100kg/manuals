# Spring

--- Spring ---
    Это фреймворк, предназначенный для более быстрого и простого
    построения Java приложений.
    Создан: 2004.
    Последняя версия: Spring 5
    site: www.spring.io

--- Inversion of Control ---
    IoC - аутсорсинг создания и управления объектами. Т.е. передача нами
    прав на создание и управление объектами нами to Spring.

    Spring Container    - создание и хранение объектов
    config file         - описывает объекты кот будет создавать Container
    MyClass             - обращается к Container для получ объекта, а 
                          не создает их самостоятельно.

    MyClass <=====> Spring Container <--- config file
                                         /     |     \
                                       Dog    Cat    ...

    Основные функции Spring Container:
    IoC     - Inversion of Control, инверсия управления.
              Создание и управление объектами.
    DI      - Dependency Injection, внедрение зависимостей.

    Способы конфигурации Spring Container:
    XML file (устаревший способ)
    Annotations + XML file (современный способ)
    Java code (современный способ)

    Spring Bean (или просто bean/бин) - объект, который создается и 
    управляется Spring Container.
   
--- ApplicationContext config with .xml file ---
    // создаем файл в директории resources(root) "applicationContext.xml"
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <bean id = "myPet"  // id используется при создании бина
            class = "io.github.ivan100kg.spring_intro.Dog"> // full classname
        </bean>
    </beans>

    Создать Spring Container:
    ApplicationContext - это и есть Spring Container.
    // для способа 1, с пом xml, Pet - interface for Dog,Cat..
    ClassPathXmlApplicationContext context =        // get context
            new ClassPathXmlApplicationContext("applicationContext.xml");
    Pet pet = context.getBean("myPet", Pet.class);  // get bean (id, Class)
    pet.say();                                      // call Dog method
    context.close();                                // close context
    
    Теперь мы можем получать и управлять объектом Dog через 
    Spring Container, вызывая его по id - это и есть бин, чтобы 
    изменить напр Dog на Cat, нужно просто заменить в applicationContext.xml
    аттрибут class на io.github.ivan100kg.spring_intro.Cat

--- Dependency Injection xml ---
    DI - аутсорсинг добавления/внедрения зависимостей.
    DI делает объекты нашего приложения слабо зависимыми друг от друга.

    Способы внедрения зависимостей:
    с помощью конструктора
    с помощью сеттеров
    Autowiring
    
    Способ #1 - с помощью конструктора:
    Допустим есть класс Person, который has an another class inside(Pet):
        public Person(Pet pet) {    // конструктор принимает об другого класса
            this.pet = pet;
        }
    Допишем зависимость в наш applicationContext.xml:
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog">
        </bean>

        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <constructor-arg ref="myPet"/>  // constructor-arg - арг костр
        </bean>                             // ref - ссылка bean id
    Далее можно не создавая класс Dog/Cat создать Person:
        Person person = context.getBean("myPerson", Person.class);
        person.callYourPet();   // some method of Person
        context.close();

    Способ #2 - с помощью setter:
    Добавим метод setPet to Person:
        public void setPet(Pet pet) {
            this.pet = pet;
        }
    Изменим applicationContext.xml:
        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <property name="pet" ref="myPet"/>  // свойство pet -> метод setPet
        </bean>                                 // перв буква стан заглав -> Pet
                                                // внач добав set + Pet = setPet()
    Работает все также, код менять не надо - просто др способ.

    Внедрение других значений через методы(сеттеры):
    Например в классе есть 2 поля не иниц через конструктор, но нужно вызвать
    их сеттеры:
        // поля
        private String surname;
        private int age;
        // сеттеры
        public void setSurname(String surname) { this.surname = surname; }
        public void setSurname(int age) { this.age = age; }
    // как вызвать с пом applicationContext.xml 
    // способ #1 прямо в файле applicationContext.xml 
    <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
        <property name="pet" ref="myPet"/>
        <property name="surname" value="Bond"/> // value - передать значение
        <property name="age" value="39"/>       // name - св-во age->setAge()
    </bean>
    // способ #2 с пом др файла myFile.properties:
        person.surname = Bond   // создадим файл resources/myFile.properties
        person.age = 39         // добавим эти строки в myFile.properties
    // добавим эту строку перед всеми бинами
        <context:property-placeholder location="classpath:myApp.properties"/>
        classpath - местонахождение пользовательских классов(resources там же)
    // изменим applicationContext.xml 
        <property name="surname" value="${person.surname}"/>    // подставим
        <property name="age" value="${person.age}"/>
    Вызов значений из др файла ${name}, name может быть любым, но
    парвильнее и более понятно уточнять типа person.age
        

    }

--- Bean scope xml ---
    Scope - область видимости, определяет:
        жизненный цикл бина
        возможное кол-во создаваемых бинов
    Разновидности bean scope:
        singletone      // default, если не указан scope, 1 общий бин
        prototype       // бины создаются каждый раз при обращении getBean()
        request
        session
        global-session
    
    Singletone
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="singleton">    // можно не указывать
        </bean>
    Этот бин создается сразу после прочтния контейнером конфиг файла.
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext2.xml"
        );
        bean сдесь уже создан один и для всех.
    Является общим для всех, кто запросит его у контейнера.
        // получаем ссылки на бин
        Dog dog1 = context.getBean("myPet", Dog.class);
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // true
    Подходит для stateless объектов.(не хранящих состояния)

    Prototype
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="prototype">    // scope
        </bean>
    Такой бин создается только после обращения к контейнеру с пом getBean()
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        Dog dog1 = context.getBean("myPet", Dog.class); // создание
    При каждом обращении создается новый бин.
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // false
    Подходеит для stateful объектов.(хранящих состояние, например поле имя)

--- Life Cycle of bean xml ---
    Запуск      -->  Начало работы     -->  Создание  -->  DI - внедряются
    приложения       Spring Container       бина           зависимости
                                                                  |
    Конец работы  <--  Использование  <--  Бин готов для  <--  init-method
    Spring Container  нами этого бина     использования
          |
    destroy-method  -->  Остановка
                         приложения

    init-method используется для открытия или настройки каких-либо
    ресурсов(базы данных, стримы ...). Вызывается автоматически, можно
    использовать для запуска нашего кода при создании бина. Для scope = 
    prototype - init будет вызываться для кажд создания бина.
    
    destroy-method используется для закрытия этих ресурсов. Тут пишется
    логика после окончания работы с бином, перед его уничтожением. Также 
    вызывается автоматически. Если scope=prototype то destroy НЕ вызывается.

    Использование своего кода при init-method destroy-method:
    // добавим методы в наш класс Dog(такие названия не обязательно),
    модификаторы могут быть любыми
    return-type может быть любым, но так как не исп-ся - используют void
    параметров быть не должно.
        private void init() {
            System.out.println("class Dog: init method");
        }
        private void destroy() {
            System.out.println("class Dog: destroy method");
        }
    // свяжем их в applicationContext.xml
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog"
            init-method="init"          // методы можно называть как угодно
            destroy-method="destroy">
        </bean>
    // теперь при создании и закрытии бина
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        // тут авто вызовется init() если scope НЕ prototype
        Dog dog = context.getBean("myPet", Dog.class);
        // тут авто вызовется init() для кажд бина если scope=prototype
        dog.say();
        context.close();
        // тут авто вызовется destroy() если scope НЕ prototype

--- ApplicationContext config with annotations ---
    Это более короткий и быстрый способ.
    Процесс в 2 этапа:
        сканирование классов и поиск аннотаций @Component
        создание(регистрация) бина в Spring Container
    
    // Для сканирования необходимо указать в applicationContext.xml где сканировать:
        <context:component-scan base-package="io.github.ivan100kg"/>
        Указываем эту строку и наш главный пакет с классами.

    // Теперь пометим наш класс аннотацией @Component
    @Component("catBean")   // сдесь задаем люб имя бина, либо по дефолту будет cat
    public class Cat implements Pet{
        @Override
        public void say() {
            System.out.println("Meow-Meow");
        }
    }

    // Создадим ApplicationContext и вытянем бин
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
    );
    Cat cat = context.getBean("catBean", Cat.class);    // получим бин 
    cat.say();
    context.close();

--- Dependency Injection with annotations ---
    -- DI @Autowired
    Для внедрения зависимостей с помощью аннотаций исп @Autowired.
    Может использоваться:
        конструктор
        method
        поле
    Использовать можно любой тип, но желательно придерж одного стиля.
    
    Использование с конструктором:
    // добустим есть class Person, конструктор приним об др класса Pet,
    пометим аннотацией 2 класса, тем самым создадим бины(если scope не prototype).
    @Component("personBean")
    class Person {
        @Autowired      // пометим конструктор аннотацией @Autowired
        public Person(Pet pet) {
            System.out.println("Person bean is created");
            this.pet = pet;
        }

    // use
    Person person = context.getBean("personBean", Person.class);    // correct
    person.callYourPet();
    Как произошло внедрение:
        После сканирования нашлось 2 бина (personBean, catBean)
        далее нашлась аннотация @Autowired (На конструкторе Person)
        начался поиск бина с типом Pet(тот что в параметрах конструктора)
        нашелся подходящий бин - catBean
        внедрение зависимости

        если не найдется подходящий бин - exception
        если найдется более 1 подходящего бина(например dogBean) - exception

    Использование с методом:
    @Component("personBean")
    class Person {
        @Autowired      // пометим метод аннотацией
        public void setPet(Pet pet) {
            this.pet = pet;
            System.out.println("Pet was set in Person");
        }
    
    // use
    Person person = context.getBean("personBean", Person.class);    // correct
    person.callYourPet();
    Как произошло внедрение:
        все также как и при конструкторе происходит внедрение

    Использование с полем:
    @Component("personBean")
    public class Person {
        @Autowired
        private Pet pet;
    
    // use
    Person person = context.getBean("personBean", Person.class);
    person.callYourPet();
    Как произошло внедрение:
        все также находятся бины, @Autowired, идет подстановка,
        сдесь под капотом исп-ся Reflecnion. 

    -- DI @Qualifier
    Когда находится более чем 1 бин при @Autowired происходит exception.
    Можно предотвратить указав какой бин должен быть внедрен с пом @Qualifier
                        @Autowired
                        @Qualifier("dogBean")   // выбор бина
                        private Pet pet;
                       /                \
    @Component("catBean")                @Component("dogBean")
    public Cat implements Pet {          public Dog implements Pet {   
    
    С полем и методом работает как и @Autowired.
    С конструктором:
        @Autowired
        public Person(@Qualifier("catBean") Pet pet) {  // указываем в параметре

    -- DI @Value
    Для внедрения строк и других значений мож исп аннотацию @Value
    Нет необходимости в сеттерах как при конфиге с пом xml.
    Значения устанавливаются не с пом сеттеров, а с пом Reflection.

    способ #1 -на месте
    @Component("personBean")
    public class Person {
        private Pet pet;
        @Value("Bond")  // устанавливаем значения пямо в классе
        private String surname;
        @Value("39")    // int тоже пишется в ковычках
        private int age;
    // use 
    System.out.println(person.getSurname() + " " + person.getAge());    // correct

    способ #2 -с пом .config файла
    <context:component-scan base-package="io.github.ivan100kg"/>
    <context:property-placeholder location="myApp.properties"/> // допишем
    // в классе исправим
    @Component("personBean")
    public class Person {
        private Pet pet;
        @Value("${person.surname}") // подстановка знач из файла
        private String surname;
        @Value("${person.age}")
        private int age;
    
--- Bean scope with annotations ---
    Те же правила, но создаются так:

    @Component              @Component  
    @Scope("singleton")     @Scope("prototype")
    public class Dog        public class Cat 

--- Life Cycle of bean with annotations ---
    Правила теже, создаются с пом аннотаций.
    @PostConstruct
    @PreDestroy

    Эти методы были выведены в Java 9, поэтому добавим зависимость в pom.xml
    <dependency>
      <groupId>javax.annotation</groupId>
      <artifactId>javax.annotation-api</artifactId>
      <version>1.3.2</version>
    </dependency>

    // применение
    @PostConstruct
    private void init() {   // после создания бина
        System.out.println("class Dog: init method");
    }

    @PreDestroy
    private void destroy() {    // перед уничтожением(НЕ для prototype)
        System.out.println("class Dog: destroy method");
    }

--- ApplicationContext config without xml ---
    способ #1
    @Configuration                  // класс является конфигурацией
    @ComponentScan("spring_intro")  // пакет для скана бинов и разл аннотаций
    public class MyConfig {}        // имя класса любое

    // создать ApplicationContext, отличается от xml способа, указываем
       наш @Configuration класс. 
    AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(MyConfig.class);
    Person person = context.getBean("personBean", Person.class);
    // Dependency Injection выполняется примерно так-же
    person.callYourPet();
    context.close();

    способ #2
    Сканирование не идет, поэтому убираем в конфиг-классе @ComponentScan
    Убираем все аннотации @Component @Autowired @Qualifier в классах
    
    @Configuration
    public class MyConfig {
        @Bean                   // @Bean регулирует создание и обращ к бину
        @Scope("singleton")     // можно указ scope - только 1 объект(как обычн)
        public Cat catBean() {  // id будет как наз-е метода "catBean"
            return new Cat();   
        }
        
        @Bean
        public Person personBean() {
            return new Person(catBean());   // DI прописываем зависимость
        }
    }
    // все работает также
    AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(MyConfig.class);
    Person person = context.getBean("personBean", Person.class);
    person.callYourPet();
    context.close();

    Использование @Value из конфиг файла (для 2-ух способов):
    Для того чтобы исп аннотацию @Value и подставлять наши значения из 
    конфиг файла нужно исп аннотацию @PropertySource

    // в классе Person
    @Value("${person.surname}") // значения берутся из кофиг файла
    private String surname;

    @Configuration
    //@ComponentScan("io.github.ivan100kg.spring_intro")
    @PropertySource("classpath:myApp.properties")   // наш конфиг файл
    public class MyConfig {

--- AOP Aspect Oriented Programming ---
    Это парадигма программирования, основанная на идее разделения основного
    и служебного функционала. Служебный ф-л записывается в Aspect-классы.
    В основе Aspect заключена сквозная логика(cross-cutting logic).
    Сквозная логика - это не бизнес функционал, это:
        логирование
        проверка прав(security check)
        обработка транзакций
        обработка исключений
        кэширование
    
    // пример Aspect класса в методах которого - сквозная логика
        // aspect class             // основной функционал
        class Aspect {              class Book {
            logMethod()                 addBook()
            secureCheckMethod()         
    Итак при вызове addBook() класса Book из основной логики программы, перед
    вызовом - вызовется logMethod() и secureCheckMethod() из сквозной логики.

    AOP - это посредник/proxy между Main class программы и др основными классами.
        Main class       AOP             Library class
        вызов       -->  Proxy      -->  addBook()
        addBook()        логи/права      выполнение

    Сквозной ф-л сосредоточен в 1-м или неск классах - легко менять.
    Благодаря конфигурации аспектов легко добавлять новый сквозные работы.
    Бизнес-код(основной) избавляется от сквозного кода - чистый код.
    Spring берет на себя сам обязанности по AOP, все легко настраивается.

    AOP frameworks:
        Spring AOP  - прост в использовании, самая распространенная функ-ть
        AspectJ     - сложный, вся фукциональность AOP

