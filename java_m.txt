// Java 

--- Java editions---
    Java Standart Edition(SE)   // стандартная редакция, для станд прил-ий
    Java Enterprise Edition(EE) // редакция для прил масштаба предприятия
    Java Micro Edition(ME)      // редакция для прил микрокомп-в (напр смартфон)

--- Java versions (LTS) ---
    version     release     support until 
    --------------------------------
    Java SE 8   Mar 2014    Dec 2030
    Java SE 11 	Sep 2018    Sep 2026
    Java SE 17  Sep 2021    Sep 2029
    Java SE 21  Sep 2023    Sep 2031

--- How it works ---
    "Write Once, Run Anywhere"
    human.java  // сохраненный файл с исх кодом с расширением .java
      |
    javac       // компилятор javaс
      |
    human.class // на выходе byte code в файле .class
      |
    JVM         // виртуальная машина Java(интерпретатор) - вып машинный код
    Запускается независимо от ОС.

--- Jshell ---
    The Java Shell tool (JShell) is an interactive tool for learning 
    the Java programming language and prototyping Java code.
    jshell      // запуск Java9+
    exit        // выход, Ctrl+D

--- Comments ---
    // comment
    /*
        multiline comment
    */
    /**
       JavaDoc comments
    */

--- Literals ---
    10          // int
    100L        // long
    3.14f       // float
    2.72        // double
    'a'         // char
    "hi"        // String
    NaN         // not a Number 0.0/0
    Infinity    // 10.0/0
    -Infinity   // -10.0/0

--- Primitive data types ---
    types       size        range
    ------------------------------------------------------------------
    byte        8 bit       [-128;127] 
    short       16 bit      [-32768;32767]
    int         32 bit      [-2147483648;2147483647]
    long        64 bit      [-9223372036854775808;9223372036854775807]
    float       32 bit      [3.4e-38;3.4e+38]
    double      64 bit      [1.7e-308;1.7e+308]
    char        16 bit      [0;65535]
    bool        strictly    {true, false}
                undefined

--- Reference data types ---
    Ссылочных типов данных бесконечное множество.
    Test tObj = new Test(); // объект класса, создаются с new
    Объекты хранятся в куче(heap).
    
--- Default values ---
    byte/short/int/long     // 0
    float/double            // 0.0
    char                    // 0 or '\u0000'
    boolean                 // false
    reference               // null

--- Variables ---
    long l1 = 10000000000L; // на конце ставим L/l для long, иначе получ-cя int
    float f1 = 47.23F;      // для float на конце ставим F/f, иначе double.
    char c3 = 300;          // помимо символов - номер символа Юникода
    char c4 = '\u0500';     // 16-рич система
    int a7 = 1_000_000;     // использование для удобства _

    int a, b=10,c;          // обьявить 3 перем типа int и 1 иниц-ть.

--- Системы исчисления ---
    int a = 0b1000;         // двоичная система - число 8
    int a = 074;            // восьмеричная си
    int a = 0x3C;           // 16-ричная

--- Operators ---
    + - * / % ++ --         // arithmetic
    = += -= *= /= %=        // assignment
    > < >= <= == !=         // relational(compare)
    && || ! & |             // locical
                               & и | - проверяет все части условия
                               && || - не проверяют вторую чатсть когда и так ясно
    & | ^                   // bit ^ - true, если одна пременная true, остальные false

--- Приоритеты операций ---
    1   ++ -- !
    2   * / %
    3   + - 
    4   < <= > >=
    5   == !=
    6   && ||
    7   = += -= *= /= %=

--- Structure of files .java ---
    package mypackage;      // пакет
    import java.util.*;     // импорт
    public class Lesson3 {} // наш класс(fields, methods, constructors)
                               public название_класса == название файла
                               только 1 public class может быть в файле или
                               не быть вообще, тогда имя файла должно == хоть
                               какому-ниб классу в файле
    class Test {            // еще 1 класс в файле
        int id=0;           // аттрибуты класса, изменить знач по умолчанию
        String name;        // объекты этого класса можно создавать в других
        double balance;        классах, в функции main
    {

    public static void main(String[] args)  // точка входа в программу
                                               должна присутствовать для запуска
                                               программы. Может находится в люб
                                               классе.
        
--- Methods ---
    public static void main(String[] args) {// code;}
    public  // access modifier
    static  // non-access modifier(s)
    void    // retun type
    main    // name
    ()      // params
    {}      // body

--- Constructor ---
    Car car1 = new Car();   // Car() - constructor, the same name as class
                               car1 - Car object
    Car(){}                 // default constructor
    Car(vars){code;}        // custom constructor(перегруженный)
                            // конструктор ничего не возвращает

--- Overloading ---
    Методы с одинак названиями, но разные параметры(типы/количество/порядок)
    return type может быть одинаковым или различным
    access modifier может быть одинаковым или различным(public/private/prot.)
    void show(int i1){
        System.out.println(i1);
    }
    void show(boolean b1){
        System.out.println(b1);
    }

--- Constructor overloading ---
    // все то же самое что и для методов
    Employee(String surname, int age){
        this(surname);  // делегирование -+ чтобы не писать больше кода
        this.age = age; //                | всегда на первой строке
    }                   //                |
                        //                |
    Employee(String surname){   // <------+
        this.surname = surname;
    }
    // более лучший способ, все конструкторы вызывают главный конструктор
    Employee(String surname, int age){  // главный конструктор с большим кол
        this.age = age;                    параметров, в этом конструкторе
        this.surname = surname;            объявляем все поля
    }              
    Employee(String surname){
        this(surname, 0);   // вызов главного конструктора, передаем на неиз-
    }                          вестные переменные дефолтные значения

--- Package/Пакет ---
    Пакет/Папка/Директория - место где хранятся классы .java(файлы)

    Основные цели пакета
    Защита доступа:
    В пакетах можно ограничить/открыть доступ к своим элементам из других
    пакетов с пом модификаторов доступа.

    Управление набором возможных имен(namespace management):
    Разделение пакетов по пространству имен. Допустим классы с одинаковыми
    названиями не могут быть в одном пакете, зато в разных пакетах это норм.
    Пакеты могут вкладываться в др пакеты.

    pack1       pack2
    class A     class C
    class B
    К классам в др пакетах обращаться так: пакет.класс, доступ должен быть
    открыт(public).
    К вложенным пакетам pack1.pack2.pack3...packn.MyClacc
    Всегда пишем полный путь, относительный не катит!
    
    pakage pack1; 
    public class A {
    public static void main(String[] args) {
        B obj1 = new B();    // обращение к классу который в том же пакете
        pack2.C obj2 = new pack2.C();   // в другом пакете
    
    Хранение связанных классов в одном месте:
    для удобства раскидываем связ классы по пакетам

--- Access modifier/Контроллер доступа ---
    От строгого:
    private -> default -> protected -> public
    
    Видимость: 
                класс файл пакет др.пакет наследники
    public      +     +    +     +        +
    private     +     -    -     -        -
    default     +     +    +     -        -
    protected   +     +    +     -        +
    
    protected видна также в классах-наследниках в любых пакетах.
    default class не виден в других пакетахб собственно и все его элементы.
    default constructor of class has the same access modifier as class.

    Для каких структур какие есть модификаторы:
                public private default protected
    class       +      -       +       -
    constructor +      +       +       +
    field       +      +       +       +
    method      +      +       +       +

--- Non-access modifiers ---
    final   // может относится к переменной/методу/классу
               vars:
               readonly(const) не изменяется, должна быть объявлена сразу
               или в каждом конструкторе.
               reference vars:
               final Car car = new Car(); - адрес не может быть изменен
    static  // может относится к переменной/методу
               принадл классу, можно вызвать через класс Class.var или
               через объект obj.var. В статик методах нельзя использовать
               не статические переменные. Но в не статик методах - можно 
               использовать статик переменные. Если final static - 
               определяется только сразу.
    abstract// 

--- Scope of variables ---
    local       // локальные, видны только в одном блоке, после объявления
    param       // параметр функции виден во всем теле ф-ии
    instance    // переменная объекта, видна в классе и его не статик методах
    static      // видна везде в классе + в статик методах.

--- this ---
    указывает на текущий экземпляр(объект) класса, используется в классе
    в non-static методах/конструкторах для обращения к переменным и методам.

--- Идентификаторы ---
    Начинается с буквы _ $
    int __$__;
    int $kjbcks;
    int _ljncds;

--- Зарезервированные слова ---
    abstract assert boolean break byte case catch class const continue
    default do double else enum extends false final float for goto if
    implements import instanceof int interface long native new null package
    private protected public return short static strictfp super switch 
    synchronized this throw throws transient true try void volatile while

--- Соглашения ---
    классы      - с большой буквы, сущ, Car
    переменные  - с маленькой буквы, сущ, color
    методы      - camel case глагол, что делать, goAhead
    final       - константы, все большие буквы, WHEIGHT

--- garbage collector ---
    объекты существуют в памяти пока на них есть ссылки
    obj = null; // оборвать связь вручную
    После того как память осталась без ссылки ее убирает Garbage Collector
    Управление GC находится под управлением JVM.
    Можно знать какие объекты могут быть удалены, но когда это будет сделано
    gc решает самостоятельно.
    System.gc() // совет коллектору удалить obj
    finalize()  // вызывается колектором для удаления obj

--- import ---
    импорт по полн имени        с исп import    comment
    ----------------------------------------------------------------------
    pack p1;                    pack p2;        current package
                                import p1.A;    import
    class A{                    class B{        class definition
    p2.B b = new p2.B();        A a = new A();  создание экз из друг пак
    }                           } 

    import examples:
    import Lessons.Lesson1.Car; // импорт класса кар из пакета Lesson1,
                                   вложенного в пакет Lessons
    import Lessons.Lesson1.*;   // импорт всех public классов из пакета
                                   при конфликтах имен - нужно указать 
                                   полный путь к классу пакет.класс.
                                   Не импортирует классы из влож пакетов.
    import java.lang.*;         // дефолтный пакет, импортируемый по умолч.
                                   включает имена System, String...
    import static pak.Klas.var; // импорт статик переменной/метода отдельно
    import static pak.Klas.*;   // all статик перем/методы отдельно

    Example
        // 3 способа задать String
        java.lang.String s1 = new java.lang.String("a");    
        String s2 = new String("b");
        String s3 = "c";

--- Arguments/аргументы методов ---
    Примитивные типы данных - передаются по значению(копируются).
    Ссылочные типы данных - передаются копии ссылок на объекты.

--- if-else ---
    // внутри if (boolean)
    if (true && !false){
        code;
    }
    else if(!false || true){
        code;
    }
    else {
        code;
    }

--- Copmarsion/Сравнения ---
    int a = 5;
    double b = 5.0;
    a == b          // true, у примитивных сравнивается значение
    obj1 == obj2    // false у ссылочных сравниваются адреса(String - искючение)

--- equals ---
    все классы по умолч имеют метод equals()
    переопределяется самостоятельно в классах для сравнения объектов
    String s1 = "Hello";
    String s2 = "Hello";
    s1 == s2;       // так не стоит, перегруж опрератор для String
    s1.equals(s2);  // правильное сравнение объектов

--- Ternary operator ---
    (boolean expression) ? (if true) : (if false);

    int a = 4;
    int b = 5;
    System.out.println(a < 4 ? "true" : "false");   // sout -> false
    int c = a < 4 ? a++ : a--;                      // c=4, a=3

    nested:
    exp1 ? exp2 ? 10 : 5 : 0
        exp1 true  -> выполняем то что между крайне левым '?'
                      и крайне правым ':' -> (exp2 ? 10 : 5)
             false -> выполняем то что справа от крайнего : -> 0
    
--- switch ---
    switch (expression) {   // типы используемые в выражении
        case val1:             int byte short char String
            code; 
            break;
        case val2: 
            code;   
            break;
        case val2: 
            code; 
            break;
        case default:   // выполняется в посл очередь, может быть вставлен выше
            code; 
    }

--- loops ---
    Unreachable statement
    действует на циклы
    недостижимое состояние - условие всегда должно быть достижимым по 
    правилам Java
    while (false)   // недостижимое состояние - компилятор не пропустит

    Loop statements
    break;      // выход из цикла/тела/блока
    continue;   // след итерация

--- for ---
    for(initialization;condition;update){   // (;;) могут не заполняться
        code;
        break;      // выход из цикла
        continue;   // след итерация
    }
    initialization  // (int i = 10, j = 20, ... , n = 100;) либо пустое
    condition       // (;i<0 && j>8 || !false;) либо пустое
    update          // (;j++, i++, square(i,j),...) либо пустое

    Nested loops:
    for (int hour=0; hour<24;hour++){
         for(int min=0; min<60;min++){
              for(int sec=0;sec<60;sec++){
                 System.out.println(hour+":"+min+":"+sec);
              }
         }
    }

    Labels of loops:
    Циклы можно именовать, чтобы управлять внешними из внутренних циклов
    OUTER: for(int min=0; min<60;min++){
        INNER: for(int sec=0;sec<60;sec++){
            System.out.println(hour+":"+min+":"+sec);
            if (sec == 20) {
                break OUTER;    // выход из цикла по имени
            }
        }
    }

--- while/do while ---
    while (condition){  // condition - boolean
        code;
    }
    
    do while заходит в цикл минимум 1 раз
    do{
        code;
    } while(condition);

    Labels for loops
    the same as "for" loop
    OUTER:while(true){}

--- String ---
    Package:
    java.lang.*

    Creation:
    String s1 = new String("Hi");   // всегда нов объект с unique address
    String s2 = "Hi";               // помещ в String pool(если его еще не было)
    System.out.print("Hi");         // также берется или помещается в StringPool
                                       если уже есть такой объект - то получим
                                       еще 1 ссылку на него.

    String pool:
    Место в памяти в котором содерж разные объекты класса String.
    Новый объект класса String создается в String Pool только,
    если там еще нет подобного объекта.

    Difference:
    Объекты созданные с пом new всегда будут с разными адресами
    Объекты созданные по другому - могут ссылаться на один и тот же адрес.

    Comparsion:
    == !=   // сравнивает адреса у объектов
    equals  // перезапис метод, у строк сравнивает именно содержимое строки

    Char massive:
    private final char {'h','e','l','l','o'};   // так String хранит значение

    String is immutable:
    String хранит свое значение в private final char массиве, с фиксированной 
    длиной. Ни один из методов класса String не изменяет индивидуальные
    элем массива char.

    String methods:
    lenght()        // -> int, symbols' count
    charAt(i)       // -> char, what char at index 'i'
    indexOf(c)      // -> int, position of char 'c'
    indexOf(s)      // -> int, position of String 's'
    indexOf(c,i)    // -> int, position of char 'c' after index 'i'
    indexOf(s,i)    // -> int, position of String 's' after index 'i'
                       -> -1, if not match
    startsWith(s)   // -> boolean, start with String 's' or no
    startsWith(s,i) // -> boolean, start with String 's' from ind 'i' or no
    endsWith(s)     // -> boolean, end with String 's' or no
    subString(i)    // -> String, what string from index 'i' to end
    subString(i,j)  // -> String, slice i:j from i(included) to j(not included)
    trim()          // -> String, delete all whitespaces from end and beginning
                          result - new String.
    replace(c1,c2)  // -> char, replace old char 'c1' to new 'c2'
    replace(s1,s2)  // -> String, replace old String 's1' to new 's2'
    concat(s)       // -> String, concatenation, the same as  s1 + s2
    toLowerCase()   // -> String, all letters convert to lower case
    toUpperCase()   // -> String, all letters convert to Upper case
    contains(s)     // -> boolean, does our String contains 's'?
    equalsIgnoreCase// -> boolean?, comparsion with ignore case

    Конкатенация, неявное приведение типов
    i1, i2  - int
    s       - String
    String + int = String
    System.out.println(i1 + i2 + s);        // 11ok
    System.out.println("" + i1 + i2 + s);   // 56ok
    Если первым операндом стоит стринг, то все типы дальнейшие типы приводятся
    к стрингу.
    даже так:
        System.out.println("" + null + false);  // nullfalse
        String s1 = null;
        System.out.println(s1 += "ok");         // nullok

    Chaining methods:
    много методов идут один за одним, выполняются слева направо
    s1.concat(s2).trim().replace("Yah", "Wow").substring(6, 10);

--- StringBuilder ---
    В отличие от String может менять свое значение, нет необходимости создавать
    много объектов, меньше работы для garbage collector.

    package:
    java.lang

    Creation:
    capacity - вместилище для символов объекта StringBuilder всегда может
    увеличиваться, по дефолту 16 символов. 
    Конструкторы:
    StringBuilder sb1 = new StringBuilder();            // пустой(16 симв по ум)
    StringBuilder sb2 = new StringBuilder("Good day");  // кол-во символов: 8(
                                                           Good day) + 16 = 24
    StringBuilder sb3 = new StringBuilder(50);          // вместимость 50 симв
    StringBuilder sb4 = new StringBuilder(sb2);         // из другого объекта
                                                           копия, др адрес
    StringBuilder sb5 = sb2;                            // тот же obj
    String s = new String(sb1);                         // String можно делать
                                                           из StringBuilder
    String s = new String(new char[]{'h','i'})          // из массива char

    Methods:
    length()        // -> int, длина(кол-во) симв
    charAt(i)       // -> char, char at index 'i'
    indexOf(s)      // -> int, index of String 's', -1 if not match
    indexOf(s,i)    // -> int, index of String 's', from index 'i', -1 if not m
    substring(i)    // -> String, from index 'i' to end
    substring(i1,i2)// -> String, from index 'i1' to 'i2'

    subsequence(i,j)// -> CharSequence, from 'i' to 'j', the same as above
    append(type)    // -> StringBuilder, добавляет в конец люб тип данных,
                          меняет сам объект, также при вызове еще и возвращ себя
    insert(i,type)  // -> StringBuilder, также как выше, но в любую позицию
    delete(i,j)     // -> StringBuilder, удаляет символы от [i до j)
    deleteCharAt(i) // -> StringBuilder, удаляет символ в индексе 'i'
    reverse()       // -> StringBuilder, переворачивает текст
    replace(i,j,s)  // -> StringBuilder, вместо строки от i до j встав строку s
    capcity()       // -> int, количество места в массиве

    Comparsion:
    StringBuilder sb3 = new StringBuilder("123");
    StringBuilder sb4 = new StringBuilder("123");
    System.out.println(sb3==sb4);           // false
    System.out.println(sb3.equals(sb4));    // false, метод сравнивает адреса,
                                               не перезаписан как в String

    StringBuffer:
    очень поохож но используется в многопоточных программах
    String s = new String(sb1); // String можно делать из StringBuffer

--- Array/Массив ---
    Массив - ссылочный тип данных, которых хранит коллекции элементов одинакового
    типа, которые пронумерованы от 0.
    Массив содержит заголовок, длину массива.
    Двумерный массив - массив ссылок на одномерные массивы.

    Creation:
    // declaration
    int[] arr;                          // declaration/объявление, этот массив
    int arr[];                             ссылается на null.

    // declaration(допустимые)
    int[] arr[];                        // 2-ый массив - скобки можно ставить
                                           где угодно
    int[] arr, arr2;                    // 2 одномерных массива
    int arr[], var;                     // arr - массив, var - переменная int
    int[] arr, arr2[]                   // arr - 1-мер, arr2 - 2-мерный

    // allocation
    arr = new int[5];                   // allocation/выделение, выделить память
                                           для 5-ти объектов типа int. Массив
                                           уже должен быть объявлен! Элементы
                                           массива заполн знач-ми типа по умолч

    // initialization(static, dynamic)
    // static
    arr[0] = 1;
    arr[1] = 5;
    arr[2] = -80;
    // dynamic
    for (int i = 0; i < arr1.length; i++) { // дин иниц 2-мерного массива
        for (int j = 0; j < arr1[i].length; j++) {
            arr1[i][j] = i + j;
        }
    }

    // declaration+allocation
    double[][] arr = new double[10][12];// 10 массивов, в кот массивы из 12 элем
    double[][] arr = new double[3][];   // 3 мaссива в которых содерж массивы
                                           разн длины, должны быть позже alloc
                                           arr[0] = new double[5];
                                           arr[1] = new double[2];
                                           arr[2] = new double[7];

    // allocation+initialization
    arr = new int[]{1,2,3};             // если int[] arr; был уже объявлен.

    // declaration+allocation+initialization
    // длина массива вычисляется автоматически
    int[] arr0 = new int[]{5,0};        // new int[] - не обязательно.
    int[] arr1 = {1,5,0,-3,5};          // массив из 5 элементов типа int
    String[] arr2 = {"hi","1","\n"};    // массив ссылок на адр String объектов
    int[][] arr3 = {{0,1,2},{3,4,5}};   // двумерный int массив
    char[][]...[] = {{{{{...}}}}};      // n-мерный массив

    Indices/индексы:
    arr1[0]         // 1-ый эл
    arr3[1][0]      // 1-ый эл, второго массива
    arr[1+1] = 2    // в [] можно производить арифм опреации
    a[a.length-1]   // the last element

    Methods:
    arr.toString()  // выводит в консоль инфо(можно переопределить)

    Attributes:
    arr.length;     // это аттр класса - длина(кол-во эл) массива

    Виды массивов:
    с примитивными типами данных    // хранит собственно данные
    с ссылочными типами данных      // хранит ссылки на адреса объектов

    Comparsion:
    ==, equals()    // сравнивают адреса массивов

    class java.utils.Arrays
    sort(arr)               // -> sorted arr, сортирует массив
    binarySearch(arr,val)   // -> int, приним сорт массив и нужное значение,
                               возвращ индекс найденного эл, иначе отриц число

--- Компиляция и запуск из консоли ---
    javac MyClass.java  // compile
    java MyClass args   // execute with arguments args to main String[] args
    java MyClass.java   // for java 10+

--- varargs ---
    variable arguments
    varargs == *args python, принимает от 0 до бесконечночти
    static void sum(int ... a)  // функция принимает любое кол-во эл
                                   sum(1, 9, -3);
    static void sum2(int[] a)   // аналогичная функция, но менее удобная при
                                   вызове sum2(new int[]{1, 9,- 3});
    varaargs может быть только 1, но параметров может быть сколько угодно
    varargs должен распологаться в самом конце списка параметров
    (String s, int ... a)
    public void abc (int[]...a) // при вызове метода можно либо ничего не
                                   передавать, либо передавать 1+ массивов инт

--- Enhanced for/foreach ---
    Используется для обхода массивов и коллекций
    
    for (int i : array) {                       // enhanced for, i - перемен-я 
        System.out.print(i + " ");                 принимающая поочер знач
    }                                              массива. В случ примитивных
                                                   типов и строк - это копия.
                                                   Остальные ссылочные -
                                                   можно поменять значение. 
    Метки, влож циклы также можно использовать.

    for (int i = 0; i < array.length; i++) {    // the same traditional for
        System.out.print(array[i] + " ");
    }

--- Object ---
    Cамый главный класс в Java. От которого унаследованы все классы.

--- ArrayList ---

    package java.util, произошел от List
    Может менять длину.

    Creation
    ArrayList по умолчанию включает в себя массив объектов класса Object.
    Т.е. элементами массва могут быть любые ссылочные типы данных, так как 
    все они произошли от Object.
    Примитивные типы данных не могут содержаться в ArrayList.
    ArrayList list = new ArrayList();                   // ListArray Object
    ArrayList<Object> list = new ArrayList<>();         // the same as above
    ArrayList<Object> list = new ArrayList<Object>();   // the same as above
    ArrayList<String> l1 = new ArrayList<>();   // только String objects
    ArrayList<String> l2 = new ArrayList<>(8);  // capacity = 8, может увелич-ся
    ArrayList<String> l3 = new ArrayList<>(l1); // из другого листа(разн адреса)

    Methods
    size()                  // -> int, размер списка(кол-во эл-ов)
    add(DataType el)        // -> boolean, добавить в конец списка
    add(nt i, DataType el)  // -> boolean, добавить в индекс 'i', остальные сдвиг
    addAll(ArrayList a)     // -> boolean, добавить в конец элементы
    addAll(int, ArrayList a)// -> boolean, добавить элементы в индекс 'i'
    get(int index)          // -> DataType, элемент под индексом 'i'
    indexOf(Object el)      // -> int, 1-ый индекс запрашиваемого элелента, else -1
    lastIndexOf(Object el)  // -> int, посл индекс запрашиваемого элелента, else -1
    set(int i, DataType el) // -> DataType, заменяет элемент под индексом 'i'
    remove(Object el)       // -> boolean, удаляет элемент ссылка на кот в параметре
    remove(int index)       // -> DataType, удалить элем по индексу 'index'
    clear()                 // -> void, удалить все элементы
    isEmpty()               // -> boolean, пустой?
    contains(Object el)     // -> boolean, есть ли объект в листе?
    toString()              // -> String, возвращ строковое предст об
    clone()                 // -> Object, сам массив получ нов адрес, но эл-ты те же
    toArray()               // -> Object, в Object массив
    toArray(DataType[] arr) // -> DataType, массив выбранного типа.
    equals(ArrayList l)     // -> boolean, равны если элементы и их порядок одинак
    Arrays.asList(DataType[])               // -> List<DataType>, List объект
    Collections.sort(ArrayList<DataType>    // -> void, сортировка

    Iterator
    Iterator<String> it = list.iterator();
    while(it.hasNext()){        // приимущество перед foreach, можно удалять эл
        System.out.println(it.next());
    }
    for (String s : list) {     // the same
        System.out.println(s);
    }

    wrapper class
    У каждого примитивного типа данных есть есть wrapper class 
    int - Integer

--- Encapsulation/Инкапсуляция ---
    Getters-Setters
    Скрыть реализацию данных при необходимости можно с помощью private
    переменных и геттеров-сеттеров.
    Геттеры и сеттеры имеют доступ к закрытым переменным, проверяют какие-либо
    условия.
    private boolean clever;
    public boolean isClever() {
        return clever;
    }
    public void setClever(boolean clever) {
        this.clever = clever;
    }
    private StringBuilder name;
    public StringBuilder getName() {
        StringBuilder sb = new StringBuilder(name); // чтобы не было возможности
        return name;                                   изменить знач через get
    }
        public void setName(StringBuilder name) {
        this.name = name;
    }
    Если return type метода get это mutable тип данных(напр StringBuilder),
    то лучше возвращать его копию.

--- Inheritance/Наследование ---
    Родитель(Super/Parent/Base) может иметь множество детей.
    Дите(Child/extended/subclass/derived) может иметь только одного родителя!
    class Parent {}                 // родитель
    class Child extends Parent {}   // ребенок, extends - расширяет родителя

    Зачем нужно наследование.
    Короткое написание классов
    Легкость в изменении/добавлении новых классов.
    Exensibility (исп-е дочерних классов в функциях где ожидается родитель).
    Более легкое тестирование классов.
    Группировка классов под общим типом.

    Самый страрший родитель - Object
    class Parent extends java.lang.Object {}    // все наследуются по умолчанию

    Отношения между классами:
    "Is-a" relationship
        class Animal{}
        class Mouse extends Animal{}
        // Mouse is Animal
    "Has-a" relationship
        class Window{}
        class House{
        Window w = new Window();}
        // House has Window

    Что наследуется классом:
    public
    default(без указания modif), если подкласс в том же пакете
    private не наследуются, но можно работать через getter-setter
    protected в том же пакете и во всех сабклассах
    Конструкторы не наследуются
    Если в другом пакете сабкласс унаследовал protected метод, то он конечно
    может его использовать, но если в этом пакете будет создан объект суперкласса
    то этот объект не сможет обращаться к protected методам своего класса из
    другого пакета.

    Кострукторы:
    При создании объекта сабкласса, вызывается его конструктор, в конструкторе
    выз-ся метод super() который вызывает конструктор родителя ... так до
    класса Object, далее обратный ход, последним заканчивает работу констуктор
	сабкласса.
    super() - компилятор по дефолту добавляет в конструкторы.
    super(a,b) - можно вызывать определенные конструкторы родителя из 
    конструкторов наследников, для передачи параметров.
	Первая строка конструктора это:
		this()	// обращение к др конструктору своего класса
		super()	// обращение к конструктору родителя
	Вызываем сначала конструкторы своего класса, затем из базового конструктора
	(того в котором больше всех параметров и который все остальные конструкторы
	с нехваткой параметров вызывают с помощью this()) вызываем родительский
	конструктор(тот который подходит) с помощью super(). После констр-ра Object
	все вызовы возвращаются назад.

--- Polymorphysm/Полимофизм ---
        Employee        # base class
    |      |
    Doctor Teacher  # extendent classes

    Doctor d = new Doctor();    # переменная определенного типа может ссылаться на
                                объект того же типа
    Employee e = new Doctor();  # переменная базового класса может сссылаться на
                                любой объект сабкласса и саб сабклассов и т.д...
                                Другими словами Doctor это Employee(Рабочий).
    Object obj = new Doctor();  # переменная супер класса может ссылаться на люб obj
    Doctor d != new Employee(); # Нельзя. Рабочий - не обязательно водитель.

    Переменные суперклассов хоть и ссылаются на объекты сабклассов, но все же могут
    обращаться только к унаследованным аттрибутам супер(своего же) класса!
    Если метод был overriden - произойдет вызов overriden метода сабкласса, несмотря
    на то что это переменная типа суперкласса.

    Функция возвращающая любой объект
    public Object abc() {
        return new StringBuilder("hey");
    }

--- Overriding ---
    Это изменение non-static, non-final метода в sub классе, который он 
    унаследовал от parent класса.
    Private методы не наследуются, поэтому их нельзя перезаписать.
    Final методы не могут быть перезаписаны
    @Override   # аннотация для пересзаписываемого метода
    Overriden methods:
    Имя в сабклассе такое же как в суперклассе.
    Список аргументов совпадает, иначе будет overloaded.
    Return types совпадают или return тип у overriden метода это подкласс
        return типа у метода супер класса (ковариантные return types)
    Access modifier в сабклассе тако же или менее строгий, чем в parent классе.
        private > default > protected > public (от строгого к менее строгому).
    Метод в сабклассе должен быть non-static.

--- Binding ---
    Определение вызываемого метода, основываясь на объекте, который производит 
    вызов или типе данных reference variable.
    2 типа binding:
    Compile time binding    // осуществляется во время компиляции
        private methods        эти методы не могут быть перезаписаны
        static methods         поэтому компилятор знает из какого класса их выз.
        final methods          Все типы переменных также опред здесь.
        variables
    Run time binding        // во время выполнения
        other methods          в остальных случаях определение из какого
                               класса вызвать метод происх во время выполнения.

--- Hiding ---
    Перекрытие static метода суперкласса static методом сабкласса.
    Private методы и переменные не наследуются, поэтому их нельзя скрыть.
    Final static нельзя скрыть.
    Hidden methods:
        Имя методов одинаковое.
        Список аргументов одинаковый.
        Return type одинаковый, либо ковариантные return types(см. выше).
        Access modifier такой же или менее строгий чем в parent классе.
        Если в супер классе это static - то и в сабклассе static.
    hidden variables:
        Переменная с таким же именем скрывает переменную в супер классе,
        модификаторы и типы могут быть любые, все равно скроет.

--- Final ---
    Final class - класс не может иметь потомков.
    методы нельзя перезаписать или скрыть
    переменные также нельзя скрыть
    конструкторы final несуществует

--- super ---
    super.var   # обращение из подкласса к атрибутам суперкласса
                  super - как бы объект суперкласса
    Правила схожи с this
    Нельзя исп в статических методах и переменных(присваивание через объект).
    super может обращаться только к видимым из сабкласса атрибутам суперкласса.
    super в отличие от super не обязателен на 1-ой строке тела метода.
    
--- Abstract method ---
    abstract void per();    // нет тела
    Недопустимо:
        final abstract      // так как дол быть перезаписан
        private abstract    // так как дол быть унаследован
        static abstract     // так как дол быть перезаписан

--- Abstract class ---
    Нельзя создать объект класса.
    Если в классе присутствует абстрактный метод - то класс дол быть abstract.
    Abstract class может содержать, а может и не содержать абстрактные методы.
    Сабкласс должен перезаписать все абс методы либо тоже быть абстрактным.
    Можно исп ref vars типа abstract класса чтобы ссылаться на объект сабкласса
    который не является абстрактным.
    Не может быть final (можно сказать противоположные понятия).
    Переменные не могут быть абстрактными.
    Может иметь конструкторы.
    Любой перезаписываемый метод может быть как абстракт так и не абстракт.
    Конкретный класс - сабкласс кот перезаписал все абс методы.
	AbsParent p = new Child();	// такое разрешено

--- Interface ---
    Java 7
	Интерфейс это не класс это как бы протокол который можно имплементировать
	классом.
	Интерфейс может быть public(1 в файле с таким же именем) либо default.
	abstract interface Help{}	// создать интерфейс, abstract можно опустить
	Интерфейс не может быть final.
    Все методы в интерфейсах - public abstract, словa public abstract можно
    опустить - компилятор их поставит авто.
	Методы интерфейса не могут быть final.
    class Teacher extends Employee implements Help  // осуществить интерфейс
    class Teacher implements Help   // (без extends) осуществить интерфейс
    class T extends E implements Help, Swim, ...    // many interfaces
    Внутри класса осуществляюго интерфейс необходимо перезаписать абс методы
    или сделать класс абстрактным(все как с абстрактными классами)
	Интерфейсы могут содержать константы - public final static int A = 10;
	Если класс имплементирует интнрфейс то он гарантированно будет иметь
	все методы интерфейса.
	Интерфейсы описывают что должно быть сделано, но как это будет сделано
	определяется в классах имплементирующих этот интерфейс.
	InterParent p = new Child();	// такое разрешено, но опять же переменная
	                     			   интерфейса может обращаться к перезап-м
									   методам интерфейса классом Child.
	Нельзя создать объект.
	Не имеют конструкторов.
	interface i2 extends i1{}		// Интерфейсы могут наследовать другие 
									   интерфейсы
    abstract class implements i1	// абстрактный класс может имп интерфейс
									   может оверрайдить все или часть или ни
									   одного метода, по желанию.
	
--- class vs interface ---
	Class can extends 0 or 1 class.
	Class can implements 0 or more interfaces.
	Interface can't implements or extends class.
	Interface can extends 0 or more interfaces.
	
--- new in Java 8 ---
	Методы в интерфейсах возможно объявить default(это не access modifier),
	а дефолтная реализация public метода.
	Такие методы могут быть исп только в интерфейсах.
	Не может быть final, static, abstract.
	interface I1{
    public default void def(){	// всегда имеет реализацию, можно не override
        System.out.println("def method");
    }	// перезаписывается с acess modifier public void def(){}
	Можно использовать public static методы.
	Они не наследуются и обращаться к ним можно только через имя интерфейса,
	даже если не имплементировать сам интерфейс.
	I1 Ret(){return new Zz(I1 i1);}	// можно использовать в return types,
									   в параметрах метода, подставлять классы
									   импл этот интерфейс.

--- Polymorphism ---
    Способность объекта принимать несколько форм.
    Полиморфный объект имеет несколько форм IS-A.
    Полиморфизм - способность метода вести себя по разному в зависимости от
    вызывающего объекта.
    Самый частый случай это создание Parent переменной ссылающейся на 
    объект сабкласса.
    Перезаписанный методы - это полиморфные методы.

--- instanceof ---
    Проверяет есть ли между объектом и классом/интерфейсом связь IS-A.
    Car c = new Car();
    System.out.println(c instanceof Car);       // true
    System.out.println(c instanceof Object);    // true

--- Casting(приведение типов) ---
    Reference types:
    Процесс когда вы заставляете ппеременную одного типа вести себя как 
    переменную другого типа данных.
    Кастинг возможен только когда между классами/интерфейсами есть связь IS-A.
    Делаая кастинг тип данных объекта не меняется, вы заставляете его
    чувствовать как объект другого типа.
    В двух словах, исп-ся в случае необходимости использовать методы или
    переменные сабклассов с пом переменной суперкласса.

    Upcasting:
        когда переменную сабкласса заст себя вести как перем суперкласса.
        Employee e = new Driver();  // автокастинг
    Downcasting:
        когда переменную суперкласса заставляют себя вести как перем сабкласса
        Driver d = (Driver) e;      // не автоматический кастинг

    ((Doctor) emp).attr;    // emp - переменная суперкласса Employee, компил-ру
                               явно указ-ся вести себя как пер сабкласса Doctor.
    Doctor d = (Doctor)emp; // пример Employee IS-A Doctor (что не должно 
                               работать но с пом кастинга работает).
    Перебор объектов Employee в цикле
    Employee[] arr = {emp1,emp2,emp3,emp};  // объекты разных сабклассов
    for (Employee e : arr){
        if (e instanceof Driver) {          // проверяем на innstanceof и
            ((Driver) e).drive();              применяем кастинг.
        }
    }
    Example2:
    String[] arr1 = {"Hello", "Bye"};
    Object[] arr2 = arr1;                   // upcasting
    String[] arr3 = (String[]) arr2;        // downcasting

    Primitive types:
    Widening/расширение - переход из меньшего типа данных в больший
                         char
                          |
                          v
        byte -> short -> int -> long -> float -> double
    Example:
        double d = 'a'; // char to double
        long l = b;     // byte var b to long        
    
    Narrowing/сужение - переход в меньшие типы данных.
    Без кастинга 3 условия:
        - int приводится к byte,short,char:             byte b = 10;
        - знач int это константа(final или литерал):    short s = 2;
        - значение int помещается в соотв тип данных:   byte b = 127;
    В остальных случаях:
    Любой более большой тип данных можно преобразовать к меньшему с помощью
    кастинга/приведения (type).
    b = (byte) 12.45;   // приведение к целочисленным типам данных дробная часть
                           усекается
    byte b = (byte)999; // если больше вместимости то будет переполнение        

    Numeric promotion:
    Конвертация меньшего численного типа в больший.
    Условия когда происходит:
        - если есть 2 значения разных типов - ковертируется в больший
        - если одно дробное а второе целое получ дробное(т.к. оно числ больше)
        - если byte, short, char участв в арифм операц - то они перед этим
          конвертируются в int. Исключение -  унарные операторы ++ --
        - результирующее значение принимает тип операнды.

--- equals ---
    Метод класса Object.
    Перезаписать метод equals() у своего класса.
    @Override
    public boolean equals(Object obj) { // используем параметр Object
        if (obj instanceof Car) {
            Car c2 = (Car) obj;         // приводим тип/casting
            return color.equals(c2.color) && engine.equals(c2.engine);
        }
        else {
            return false;
        }
    }
    Правильно перезаписанный метод должен обладать след св-вами:
        -Симметричность для non-null ссылочных переменных a и b
         a.equals(b) возвращ true тогда и только тогда когда 
         b.equals(a) тоже возвращ true.
        -Рефлективность - for non-null ссылочной переменной a.equals(a)
         всегда должно возвращать true.
        -Транзитивность - для non-null ссылочных переменных a,b,c - если
         (a.equals(b) and b.equals(c)) == true --> то a.equals(c) дол быть true.
        -Постоянство - для non-null ссыл перем a, b неоднократный вызов
         a.equals(b) должно возвращ или только true или только false.
        -Для non-null ссыл перем a, a.equals(null) дол возвр всегда false

--- toString ---
    Метод класса Object.
    Возвращает строковое представление объекта. 
    По дефолту --> class_name@hashcode  // имя класса + @ + рез-т метода
                                           hashcode().
    System.out.print(obj) по умолчанию приводят obj к стоковому
    представлению с помощью toString()
    Перезапись:
    @Override
    public String toString(){
        return color + " car with " + engine;
    }

--- Wrapper classes ---
    Классы оборачивающие какие-то данные.
    Позволяют примитивные типы данных использовать как классы.
        primitive   wrapper
        -----------------
        byte        Byte
        short       Short
        int         Integer
        long        Long
        float       Float
        double      Double
        char        Char
        boolean     Boolean
    Autoboxing  - конвертирование соотв прим типа в класс.
                  Integer i = 50;
    Unboxing    - конвертирование объекта типа wrapper class to primitive.
                  int a = i; (тот что выше)
    class Number    // предок всех wrapper классов.
    Methods:
        parse(s)    // --> type, конвертация подходящего значения типа данных
                       String(s) в соответствующий примитивный тип данных.
                       int i1 = Integer.parseInt("50");
        valueOf(x)  // --> wrapper, создать об wrapper класса того типа,
                       на котором данный метод был вызван.
                       Integer i3 = Integer.valueOf(10);    // в итоге 10
                       Integer i4 = Integer.valueOf("10");

--- Overloading, приоритетность методов ---
    Если при вызове метода его параметр лист соотв-т нескольким парам-листам
    овер методов, то приоритет таков:
        1. точное совпадение типов.
        2. большие типы данных для примитивных и super классы для ссылочных.
        3. autoboxed types (wrapper классы).
        4. varargs
    Конвертация типов данных для соответствия списку параметров не может
    происходить в 2 этапа, максимум 1 конвертация.

--- Non-static and static initializers ---
    Блок кода внутри класса, но не внутри метода. Может иметь любую реализацию
    не имеет return type и не приним параметры.

    Initializer block срабатывает при создании нового об соотв класса,
    выполняется перед выполнением конструктора этого класса, но после конс-в
    суперклассов и static initializers.
    Может быть 0 или больше таких блоков.
    {           // initializer block 
        System.out.println("Hello");    
    }
    Зачем нужеж:
        срабатывает независимо от конструктора
        их исользуют анонимные классы

    Static initializer block срабатывает 1 раз при загрузки класса в память,
    еще до вызова метода main.
    Может инициализировать final static переменные.
    Не может обращаться к не статическим переменным.
    static {    // static initializer block 
        System.out.println("Static block 1");
    }

--- Порядок выполнения ---
    1. static blocks и static переменные родительского класса.
    2. static blocks и static переменные дочернего класса.
    3. non-static blocks и non-static переменные родительского класса.
    4. constructor родительского класса.
    5. non-static blocks и non-static переменные дочернего класса.
    6. constructor дочернего класса.
    
    Инициализация пунктов 3-6 происходит только и при каждом создании объекта.
    Равнозначные init блоки выполняются в той последовательности в которой
    они описаны в классе.

--- Non-access modifiers ---
    transient       // такие переменные класса не сериализуются
    native          // методы реализованы не на Java а на C. Не имеют тела;
    synchonized     // методы могут быть исп в одно время только 1-м потоком.
    volatile        // переменный могут быть изменены разными потоками и 
                       данные изменения будут видны во всех потоках.
    strictfp        // в методах и классах огранич точность вычислений float
                       и double по стандарту IEEE.

--- java.io ---
    Пакет с классами и итнтерфейсами ввода/вывода.
    File("path")            // абстрактная репрезентация пути к файлу.
    FileInputStream         // создать поток, для чтения из источника
    FileOutputStream        // создать поток, для записи в источник.
    FileNotFoundException   // исключение, файл не найден, может выбрасываться
                               двумя классами выше.
    IOExeption              // могут выбрасываться методами write и read,
                               классами выше, не читается/записывается.
                               
--- Исключения ---
    Иерархия классов:
    Object <--+ 
              |
              +- Throwable  // главный класс для 'выбрасываемых' объектов
                 ^   ^
                 |   Error  // класс Ошибок со своими подклассами
                Exception   // класс Исключений со своими подклассами
                 ^
           RuntimeException // один из основных, имеет множество подклассов
    
    Сабклассы RuntimeException:
    Unchecked exceptions, Java не заставляет их проверять.
    Ткие исключения возникают по вине программиста.
    Можно не объявлять(throws) и не обрабатывать(try-catch).
    Компилятор не в состоянии проверить возможность выброса этих исключений.
    Например NullPointerException - невозможно предугадать, ловить эти
    исключения можно, но не обязательно.

    Сабклассы Exception
    Cheked исключения указ на часть кода, который находится за пределами
    непосредственного контроля программой и который может явл причиной 
    выброса исключений, как правило это работа с внешними источниками - 
    файлы, бд, сеть. Компилятор всегда проверяет возможность выброса искл.
    Эти искл должны быть обязат или объявлены(throws) и/или обработаны(try).

    Если метод 'a' использует внутри себя метод 'b', который может внутри себя
    выбросить checked exception то метод должен:
        1. Или заключить вызов метода b в try/catch блоки
        2. Или/и объявить, что он может выбросить это checked исключение
           или super класс этого исключения - например Exception.
    
    Examples:
    IllegalArgumentException    // можно выбрасывать в своем коде где идет
                                   проверка аргументов
    NumberFormatException       // наследник того что выше
    IllegalStateException       // метод вызывается в неподходящее время.

    Overriding and overloading
    Если класс перезаписывает метод суперкласса или имплементирует метод из
    интерфейса - нельзя добавлять в его сигнатуру (+throws) новые checked exc.
    В сигнатуре метода можно исп только искл из перезаписанного метода
    суперкласса или дочерние классы данных исключений - это для checked, а
    uncheked(Runtime) можно выбр любые.
    Перегруженные методы могут использовать любые выбросы исключений.

    Constructor
    Конструктор может выбрасывать исключения. В своей сигнатуре он должен 
    описвать все checked исключения(или суперклассы этих искюч) конструктора
    суперкласса, а также добав новые исключ. Runtime можно не описывать.

    Если указать исключение в сигнатуре метода, но оно не будет выбрасываться -
    не считается ошибкой.
    Ловить метод на checked исключения, если они не указ в сигнатуре - нельзя.

--- try/catch/finnaly ---
    Обработка исключений:
    try {                   // try - 1 block
        code;
    } catch (Exception e) { // перехват исключения, может быть many catch
        code;
    } finally {             // выполняется всегда - 1 block
        code;
    }
    e - показывает тип исключения и сообщение/разъяснение.
    e.getMessage()          // сообщение исключения
    e.printStackTrace(      // вывод стэка ошибки
    
    Порядок перехвата исключений от наследников к базовым, если поставить
    базовый класс Throwable на первый catch - остальные никогда не обработ. 
    catch (FileNotFoundException e) {
        System.out.println("Caught exc 1");
    } catch (Exception e) {
        System.out.println("Caught exc 2");
    } catch (Throwable e) {
        System.out.println("Caught exc 3");
    }
    После возникновения исключения что в блоке try, что в другом блоке - 
    оставшаяся часть кода блока уже не обрабатывается.
    После выброса исключения виден стек трейс для всех задействованных 
    в этом методах.
    Конструктор объекта исключения может принимать строку или ничего не прин.
    Если в блоках try и catch присутствует return, то блок finally срабатывает
    до return. И если организ return в finally то сработает он в люб исходе.
    Если при return из try/catch возвращается примитивный тип данных то он
    как бы копируется в return и уже после в finally значение переменной 
    изменить нельзя, ссылочный объект(mu) конечно можно.
    Finally не срабатывает только если в блоках try catch организ System.exit
    или при крушении JVM/OS.
    Исключение может быть перевыброшено. Т.е. в блоке catch можно снова
    перевыбросить (throw) исключение, его обраб занимается вызывающая ф-ия.
    Поддерживаются вложенные(nested) try-catch.
    Если исключения выбрасываются в catch блоке оно дол быть обработано
    во вложенном блоке, т.к. в этом же блоке поймать нельзя.

--- throws ---
    Выброс исключений
    void abc() throws Exception {}  // говорит компилятору что может 
                                       выбрасываться исключение и что можно
                                       не обрабытывать его обязательно в коде
                                       (для Checked). Через запятую можно
                                       указать несколько исключений.
    throw e;    // выбросить исключение e(объект класса исключения).
                   если исключение checked - не забудь в методе throws.
    Example:
    static void def(){
        throw new NullPointerException("Bla-bla");  // выброс RuntimeException
    }
    static void foo() throws IOException {          // выброс checked, указываем
        throw new FileNotFoundException("Bla");        в throws исключение, либо
    }                                                  его суперкласс как тут.

--- Error ---
    Не стоит обрабатывать или объявлять - считается глупой затеей.
    Как и runtime exceptions считаются unchecked.
    ExceptionInInitializerError // выбрасывается в статич элементах, когда при
                                   их использовании выбрас runtime exception.
    
--- Date/Time ---
    java.time       // package
    LocalDate       // date: год, месяц, день
    LocalTime       // time: час, минута, секунда, наносекунда
    LocalDateTime   // date + time
    now()           // метод этих классов - показыывает дату/время сейчас
    Period          // класс период можно передавать в метод plus()/minus()
                       может принимать любые периоды в годах...днях
                       используется с LocalDate, LocalDateTime.
    Duration        // класс длительность, используется с LocalTime и 
                       LocalDateTime, как Period но меньше - дни..наносек.
    Эти классы имеют private конструкторы, мы не можем создать объекты с 
    помощью конструкторов. Но есть статический метод of, который возвращает
    объект соотв-го класса.
    Объекты данных классов - immutable.(неизменяемые)
    Все их методы возвращают нов объекты.
        
    of: // создание объектов с пом статич метода of()
    LocalDate ld = LocalDate.of(1983,1,23);             // date 1 вариант
    LocalDate ld = LocalDate.of(1983,Month.JAN,23);     // date 2 вариант
    LocalTime lt = LocalTime.of(hour,min[,сек,msec])    // time
    LocalDateTime.of(year,mon,day,hour,min,sec,nanosec) // datetime
    LocalDateTime ldt = LocalDateTime.of(ld,lt)         // из date и time
    Period p = Period.ofWeeks(2);                       // период=2 недели
                                                           year - days
    Duration d = Duration.ofHours(1);                   // длительность = 1 час
                                                           days - nanosec

    Exceptions:
    DateTimeExceptions  // исключение если неправильная дата/время

    LocalDate methods:
    plusDays(long t)                // --> LocalDate, добавить дни
    minusDays(long t)               // --> LocalDate, отбавить дни
    plus/minus                      // the same: Months, Weeks, Years
    plus(Period p)                  // --> LocalDate прибавляет на период
    minus(Period p)                 // --> LocalDate убавляет на период
    getDayOfWeek()                  // --> DayOfWeek
    getDayOfMonth()                 // --> int
    getDayOfYear()                  // --> int, сначала года
    getMonth()                      // --> Month
    getYear()                       // --> int
    
    LocalTme methods:
    plusHours(long hours)           // --> LocalTime, добавить часы
    ...                             // Minutes, Seconds, Nanos
    minusNanos(long nsec)           // --> LocalTime, отбавить наносекунды
    plus(Duration d)                // --> LocalTime прибавляет на длительность
    minus(Duration d)               // --> LocalTime убавляет на дрительность
    getHour()                       // --> int... 
    minute second
    getNano()                       // --> int 
    
    LocalDateTime methods:           
    ...                             // охватывает все методы выше

    До и после(сравнивать только одинак классы):
    isAfter(t)                      // --> boolean, после этого?
    isBefore(t)                     // --> boolean, до этого?

    DateTimeFormatter
    Класс работающий с временными классами - удобный формат вывода.
    Нужно брать только ту инфу, которую включают классы.
     
    java.time.format.               // package 
    // create with const vars
    DateTimeFormatter d1 = DateTimeFormatter.ISO_LOCAL_DATE;    // стд вывод
    DateTimeFormatter d2 = DateTimeFormatter.ISO_WEEK_DATE;     // 2022-W09-4
    DateTimeFormatter t1 = DateTimeFormatter.ISO_LOCAL_TIME;
    DateTimeFormatter dt1 = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    // create with methods
    DateTimeFormatter sht = 
        DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);   // 03.03.22 
                                         (FormatStyle.FULL);    // full
                                         (FormatStyle.MEDIUM);  // 03.03.2022
        DateTimeFormatter.ofLocalizedTime()                     // similar
        DateTimeFormatter.ofLocalizedDateTime()                 // similar
    // use
    System.out.println(d.format(d1));   // форматирование вывода для LocalDate
    System.out.println(d1.format(d));   // the same,в Formatter тоже есть format
    // свой формат
    DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
        // марта 03, 2022, 07:29
           y    2014    year
           yy   14
           yyyy 2014
           M    3       month
           MM   03      
           MMM  мар
           MMMM марта
           w    1       week
           ww   01      
           d    9       day
           dd   09
           h    7       hour
           hh   07
           m    8       minute
           mm   08      
           s    30      second
           ss   30
           n    5555    nanoseconds
           nnnnn    0555

    parse()
    Переводит дату/время из строки в объект времени, строка должна
    соответствовать формату.
    DateTimeFormatter f1 = DateTimeFormatter.ofPattern("yyyy.MM.dd");
    LocalDate ld = LocalDate.parse("1983.01.23", f1);
    System.out.println(ld); // 1983-01-23 - default format.
    LocalDate ld = LocalDate.parse("1983-01-23");   // если строка в таком виде,
                                                       то можно без форматтера.

--- Lambda exspressions ---
    Анонимный метод(без имени).
    Переопред метода инт-йса без создания класса имплементирующуго этот инт-йс.
    ->  // оператор в лямда выр - разделяет список параметров и тело метода.
    interface I { void foo(); } // функциональный интерефейс(1 метод)
    bar(() -> {code;})          // переопределение метода
    public class A { // класс в методе которого используется интерфейс
        // метод, один из параметров которого интерфейс I
        static void foo(double b, I i, int a) {
            // в методе класса идет вызов метода интерфейса i.bar(param)
            // для наглядности используются доп параметры
            System.out.println(a + " Hi " + i.bar(" bla-bla ") + b);
        }
        public static void main(String[] args) {
            // вызываем метод класса и переопределяем метод интерфейса на месте.
            foo(2.72, (String s) -> {   // здесь идет переопределение метода
                return "everyone" + s;  // интерфейса, без создания доп класса.
            }, 12);                     // (String s) мож просто (s) - параметр
        }                               // {return "everyone" + s;} - тело
                                        // 2.72 и 12 - доп параметры для нагляд
    }
    // чтобы использовать lambda выражения в интерфейсе дол быть только 1 метод
    // Функциональный интерфейс - интерфейс с 1 абстрактным методом
    interface I {               // Функциональный интерфейс 
        String bar(String s);   // метод который должен быть переопределен
    }    
    Способы написания lambda:
    (int i, int j) -> {  // указ тип папаметра, несколько инструкций.
        i += 10;
        return i;
    }
    (i,y) -> i+y        // неск параметров, 1 инструкция, возвращ int
    i -> {return i+10;} // если 1 парам - без указания типа параметра
    i -> i+10           // самый сокращенный, если 1 инструкция.
    () -> 5             // нет параметров, возврат int
    () -> {}            // без аргументов и без тела

--- interface Predicate<T> ---
    Функциональный интерфейс под любой тип данных, уже есть, не нужно объявлять
    package: java.util.function.    
    public interface Predicate<T> {
        boolean test(T t);
    }
    Просто в параметре медода принимающего интерфейс написать Predicate<MyCl> t,
    класс выбрать тот какой нужен.
    arr.removeIf(x -> x.name.endsWith("a"));    // пример с ArrayList

--- of ---
    // создание объектов класса с пом статич метода of()
    // конструкторы как правило делают недоступными
    Example:
    LocalDate ld = LocalDate.of(1983,1,23);

