# Linux

# общее понимание ------------------------------------------------------------+
Kernel/ядро — основа операционной системы. Оно непосредственно взаимодействует 
  с аппаратурой. С ядром можно взаимодействовать с помощью приложений — 
  с помощью предоставляемого приложениям программного кода.
Linux is kernel (ядро ОС).
Дистрибутив включает ядро и доп компоненты.
GNU — операционная система типа Unix, программы которой свободны (cat, grep, 
  awk, bash унаследованы от Unix)

командная оболочка # программа принимающая команды от пользователей, 
                     передает системе, it's bash или shell.
терминал           # файл устройства реализующий команды чтения-записи.
консоль            # терминал в физическом смысле. Терминалы TTY, переключ
                     между ними ctrl+alt+F(n)
эмулятор терминала # программы обеспеч доступ к терминалу. (Xterm, tmux…)
командная строка   # интерфейс, где пользователь вводит команды

# загрузка системы -----------------------------------------------------------+
процессы загрузки:
1.  включить
        блок питания самотестируется и при + тесте подает RESET на CPU
2.  загрузить BIOS/UEFI из NVRAM
        процессор выполняет код стартового блока хранящ-ся в NVRAM
3.  собрать сведения об аппаратуре
        проверка CPU, напряжение, температура, частота шины ...
        проверка ПЗУ(NVRAM)
4.  выбрать устройство для запуска(диск, сеть..)
        вкладка boot
5.  идентифицировать системный раздел EFI
        BIOS предполаг что загрузочное устройсто начинается с записи
        называемой MBR, эта запись содержит первичный загрузчик bootblock и
        простую таблицу разделов диска. Далее он загр 2-ой загрузчик.
        UEFI включ в себя GPT, микропрограмма обращ к GPT и идентиф ESP
        далее загружает из раздела второй загр. UEFI может обойтись без
        второго загручика и запускать ОС.
        efibootmgr  # утилита позволяет изиенить порядок загрузки(выбор устр)
6.  Загрузить загрузчик (например GRUB)
        GRUB - GRand Unified Boot.
7.  Определить какое ядро загрузить
8.  Загрузить ядро
9.  Создать структуры данных ядра
10. Запустиь init/systemd как PID 1
11. Выполнить сценарии запуска
12. Запустить систему

efibootmgr  #   UEFI утилита позволяет изменить порядок загрузки(выбор устр)

# GRUB --
позволяет указать параметры: загрузочное ядро, режим работы для загрузки
/boot/grub/grub.cfg # config file, не редактировать
/etc/default/grub   # общие пар-ры конфигурации, редактируем тут
/etc/grub.d         # различные конфигурации
grub-mkconfig       # генерировать конф файл после изменений в grub настр-х
update-gruЬ         # то же что и выше
командная строка GRUB - нажать "c" на экране загрузки
команды GRUB:
    boot    Загружает систему из указанного образа ядра
    help    Получает интерактивную помощь для команды
    linux   Загружает ядро Linux
    reЬoot  Перезагружает систему
    search  Поиск устройств по файлу, метке файловой системы или UUID
    usb     Проверка поддержки USB
параметры загрузки ядра Linux: (до перезагрузки)
    debug           Включает отладку ядра
    init=/Ьin/bash  Запускает только оболочку bash
    root=/dev/foo   Инструктирует ядро исп /dev/foo в кач корневого устройства
    single          Загрузка в однопольэовательском режиме
постоянные изменения загрузки ядра:
    /etc/grub.d/40-custom или /etc/default/grub # ищем тут ->
    GRUB_CMDLINE_LINUX  # нужная переменная

# Демоны управления системой -------------------------------------------------+
init - основной главный демон управления системой
основная задача - запуск комлектов служб и демонов в нужный момент режимы, в 
которых может работать система:
    однопользовательский режим: минимальный набор, ком строка
    многопользовательский режим: обычный режим с граф интерфейсом
    режим сервера: как многопол только без граф интерфейса
Реализации демона init:
    классический init
    FreeBSD init
    systemd

# systemd
это не отдельный демон, а набор программ, демонов, библиотек, технологий
и компонентов ядра
unit    - модули(юниты), сущность которой управляет менеджер systemd
          модулем может быть служба, сокет, устройство, точка монтирования,
          точка автоматического монтирования, файл или раздел подкачки, 
          цель запуска, просматриваемый файловый путь, таймер, управляемый
          systemd, часть ресурса управления, группа созданных извне процессов
          Поведение модулей настраивается с пом модульных файлов
Расположение модульных файлов:
    /usr/lib/systemd/system # основное место
    /lib/systemd/system     # исп в нек системах
    /etc/systemd/system     # файлы локальных файлов и настройки(высш приоритет)
    /run/systemd/system     # есть каталог мод, кот явл раб обл для перех мод
Разновидности модульных файлов:
    .automount  - автоматически присоединяемое устройство.
    .device     - устройство, которое распознало ядро ОС.
    .path       - путь.
    .scope      - процесс, созданный извне.
    .service    - собственно сервис (служба).
    .slice      - группа иерархически орг-х юнитов, упр системными процессами.
    .snapshot   - сохраненное состояние менеджера systemd.
    .socket     - сокет.
    .swap       - файл подкачки.
    .target     - цель запуска (она же - уровень). Предназначены для групп-ки
                  вместе других юнитов systemd через цепочку зависимостей.
    .timer      - таймер systemd.
    .mount      - присоединяемое устройство.
Состояния модульных файлов:
    bad         - проблема с модульным файлом.
    disabled    - модульный файл присутствует в системе, но не настроен для
                  автономного запуска. Применяется только к модульным файлам,
                  которые находятся в одном из системных каталогов systemd.
    enabled     - модульный файл инсталлирован и запущен. Стартует автономно.
                  Применяется только к модульным файлам, которые находятся в
                  одном из системных каталогов systemd.
    indirect    - модульный файл отключен, но имеет одинаковые значения в
                  разделах Also, которые могут быть включены.
    linked      - модульный файл доступен через символическую ссылку.
                  Создавался командой systemctl link. Такие модульные файлы
                  могут обрабатываться командами или указываться в качестве
                  зависимостей, но они не являются полноправными элементами
                  системы и имеют некоторые заметные отклонения. Например,
                  применение команды systemctl. disable к модульному файлу в
                  состоянии linked приводит к удалению связи и всех
                  ссылок на него.
    masked      - нежелательный статус с логической точки зрения. Означает
                  "заблокирован администратором". Менеджер systemd знает о
                  модуле, но ему запрещено активировать его или действовать
                  по любой из ero конфигурационных директив с помощью команды
                  systemctl mask. В этом случае следует отключить модули,
                  находящиеся в состоянии enabled или linked, с помощью команды
                  systemctl disable и зарезервировать команду systemctl mask
                  для модулей в состоянии static.
    static      - зависит от другого устройства. Не требует установки. Это
                  состояние характерно для тех модулей, у которых нет процедуры
                  инсталляции. Запускаются они вручную, либо указываются в
                  качестве зависимостей от других активных модулей.

Пример модульного файла rsync.service
    [Unit]
    Description=fast remote file copy program daemon
    Documentation=man:rsync(1) man:rsyncd.conf(5)
    ConditionPathExists=/etc/rsyncd.conf
    After=network.target

    [Service]
    ExecStart=/usr/bin/rsync --daemon --no-detach

    [Install]
    WantedBy=multi-user.target

# systemctl
это универсальная команда для изучения состояния менеджера systemd и внесения
изменений в его конфигурацию
Команды systemctl:
    list-units      - все загруж и активные службы, сокеты, цели, смонт диски
                      и устр-ва. Флаг --type=service - только службы
    list-unit-files - все инсталлированные модульные файлы
    enable          - вкл модуль для активации при загрузке
    disable         - выкл запуск модуля при загрузке
    isolate         - изм режим работы на целевой
    start           - немедленно активирует модуль
    stop            - немедленно деактивирует модуль
    restart         - перезапукает/запускает модуль
    status          - состояние модуля, посл записи журнала
    kill            - отправ сигнал модулю, соотв шаблону
    reboot          - перезап компа
    daeman-reload   - перезагр файлы модулей и конфигурацию systemd
	
# логи
/var/log/           - расположение логов
syslog/messages     - системные журналы ОС linux(события загрузки, ядра ...)
auth.log            - лог авторизации и аутентификации в системе
dmesg               - информация о загрузке ядра и драйверов оборудования
alternatives.log    - лог файл программы update-alternatives
kern.log            - лог сообщений ядра ubuntu, и любой другой linux системы
maillog             - сообщения почтовой системы. Обычно postfix или exim
dpkg.log            - логирование работы пакетных менеджеров ubuntu
lastlog и wtmp      - информация о прошлых авторизациях пользователей

# journalctl - журналы логов
journalctl          - вывести все логи (с последней загрузки системы по умолч)
опции, можно конкатенировать -exu
    -r              - сначала последние логи
    -e              - последние сообщения из журнала - 1000 строк
    -x              - пояснения к ошибкам
    -u apache       - логи определенного сервиса
    -f              - логи в реальном времени tail -f
    --list-boots    - список всех сохраненных загрузок
    -b num          - логи определенной загрузки(номер/id) - все загрузки
    -k              - логи ядра - аналог dmesg
    -o json-pretty  - вывод в формате JSON
    --since "2019-01-20 15:10:10"
    --until "2019-01-20 15:05:50"
                    - можно выбрать срез по дате/времени с - по
очистка логов
    journalctl --disk-usage         - занимаемое место логов
    journalctl --vacuum-size=2G     - очистить до определенного размера
    journalctl --vacuum-time=1years - очистить до определенного возраста

# WSL
	sudo service postgresql start

# навигация ------------------------------------------------------------------+
cd    # смена директории cd - -пред.каталог, cd .. -вверх на каталог
ls    # список содержимого, . -тек каталог, .. -каталог на ур выше, ~ -дом кат.
        -lah l-список a-скрытые h-человеч размер ...
tree  # структура/дерево/иерархия директорий и файлов 
        -L level глубина отображения дерева
        -d только директории
pwd   # print work directory тек раб каталог                                --+

# время дата-------------------------------------------------------+
date # системное время, настройка вывод... date +%A - день недели...
     # date "+%d %m %y %H %M %S" - дата и время
cal  # календарь, ncal -M - наш кал-рь...                       ---+

# инфо о системе---------------------------------+
uname -a                        # информация о ядре операционной системы, включая версию
/proc/version                   # более подробная информация о ядре Linux
/etc/*-release                  # информацию о выпуске операционной системы, включая номер версии

lscpu                           # инфо о процессоре
sysbench cpu run                # тест производительности процессора(apt install sysbench)
sensors                         # температура в системнике (sudo apt install lm-sensors
watch -n 1 sensors                                          sudo sensors-detect)

lsblk -f                        # диски/место
df                              # место на дисках, df -h..
du                              # показывает сколько занято места определенными файлами рекурсивно
                                  du -sh ./* # текущий дир без рекурсии
                                  -s -показывает только общий размер каталогов

free                            # опер память занято/свободно/всего free -h..
lshw -short -C memory           # RAM инфо
/proc/meminfo                   # вся информация о памяти

lspci -v | grep -i vga -A 10    # информацию о графическом ускорителе (GPU) и драйвере
sudo lshw -C display            # выведет информацию о графическом ускорителе и драйвере
nvidia-smi                      # информация о видеокарте Nvidia, включая версию драйвера
glxinfo | grep "OpenGL renderer"# информация о графическом ускорителе и его драйвере OpenGL
hostnamectl set-hostname name   # переименовать хост

--- Шаблон соответствия ---------------------------------------------------
Шаблоны сопоставляются с файлами в файловой системе.
Набор файлов соответствующий шаблонам. ./* - все файлы в тек директории
# wildcards групповые символы ----+
* # любые символы                 |
? # любой 1 символ                |
[abc]  # символ из множества      |
[!abc] # символ не из множества   |
[^abc] # символ не из множества   |
[0-9]  # любой от 0-9             |
[[:класс:]]  # символ из класса   |
[![:класс:]] # люб симв не из кл  |
[123[:класс:]] # или 123 или кл   |
[[:alnum:]]* # любое кол-во цифр  |
\* "*" '*'   # экранирование      |
# классы  | Описание
----------+-------------------
[:alnum:] | Алфавитно-цифровой
[:alpha:] | Буквенный
[:ascii:] | ASCII (американский стандартный код для обмена информацией)
[:blank:] | Пробел и символ табуляции
[:ctrl:]  | Управляющий символ
[:digit:] | Число
[:graph:] | Все что угодно, кроме управляющих символов и пробела
[:lower:] | Символы в нижнем регистре
[:print:] | Все, кроме управляющих символов
[:punct:] | Символы пунктуации
[:space:] | Пробелы, включая разрывы строк
[:upper:] | Символы в верхнем регистре
[:word:]  | Буквы, цифры и символ подчеркивания
[:xdigit:]| Шестнадцатеричный символ

# опрации с файлами/каталогами--------------------------------------------------+
file    # тип файла
stat    # подробная инфо о файле
cp      # copy -rfuv.. копирование -u --update только тех каких нет либо свежие
          -p same as --preserve=mode,ownership,timestamps сохр инфу файла
mv      # move перемещение --force --recursivity
rm      # remove -rf(удалит каталоги и все внутри без предупреждения)
mkdir   # make directory -p - можно создать каталог в каталоге...
ln      # ссылка жесткая(до файл), если нужен ярлык - используй символич ссылку
ln -s   # символическая ссылка ln -s /dir/source link; создать ссылку link на source
{}      # до{10..12}после или {1..31}{1..12}{2004..2020} форм-т всякие послед-ти.

touch my_file                       # создать файл
touch f1 f2 f3                      # создать множество файлов
touch -a my_file                    # Access time - изменить на текущее
touch -m my_file                    # Modification time - изменить на текущее
touch -m -t 202210231030 my_file    # [[CC]YY]MMDDhhmm[.ss] - изменить на время
                                      СС - century(20/19) век 

# так можно изменить время создания файла
touch -t YYYYMMDDHHMM.SS newfile    
cp originalfile newfile
rm originalfile
mv newfile originalfile

# справка------------------------------------+
man     # справочное рук-во программ(комманд)
info    # справочное рук-во
help    # справка встроенных комманд(ls,cd,...)
--help  # инструкция по исп-ию             ---+

# man--------------------------------------------------------------------------+
manpath         # путь поиска man страниц
mandb           # обновить бд man
man -f sed      # ищет точное совпадение в коммандах
man -k sed      # ищет слово в описаниях комманд, выводит все рез-ты
man -L ru man   # полная инструкция по man на русском                        --+

# команды----------------------------------------------------------------------+
compgen - # -c доступные команды - исполняемые файлы. (ls, zip, tar ...)
            -b встроенные функции - это часть оболочки. Они выглядят как 
               исполняемые файлы, но файла не существует (bg, fg, trap ...)
            -k ключевые слова - выглядят как команды, но на самом деле
               являются частью языка оболочки (if, then, else ...)
type      # чем является конкретное слово — ключевым словом, встроенной функцией
            , командой или ничем из перечисленного 
type -t   # результат в 1 слово
which     # адрес файла команды(программы), если установлена
apropos   # man -k 
whatis    # man -f 
alias     # псевдоним для комманды          
source    # или . file -выполняет file в этой же самой оболочке и все переменные
            остаются после выполнения (вирт окружение на этом основаны)
shutdown  #             
sleep n   # приостановка программы на n секунд
basename  # команда удаляющая начальную часть пути к файлу
exit      # CTRL-D(на пустом вводе) завершить работу с терминалом            --+

# перенаправление ввода-вывода, конвейеры--------------------------------------+
1>  # или > перенаправление стандартного вывода в файл, stdout
2>  # перен-е вывода ошибок в файл, stderr, 2> /dev/null - подавление вывода
&>  # весь вывод, перенаправление в файл, аналогично:   > file.txt 2>&1

>>  # дозапись в конец файла
1>> # дозапись std в конец файла
2>> # дозапись err в конец файла
&>> # дозапись both в конец файла

0<  # или < стандартный ввод, stdin
|   # конвейер - ком1 | ком2 - стд вывод ком1 подается на стандартный ввод ком2
<<  # команда << 'индикатор' - обычно индикатор _EOF_
     команде передается на вход данные с стдин, при достижении _EOF_ -Ctrl+D
     _EOF_ должен находится в начале строки и больше ничего.
    # Example: ищем результат в подаваемом тексте с помощью grep
    grep 100 <<EOF  # \EOF если хотим экранировать символы в тексте (типа $1)
    # name amt      
    pete $100       # $1 тут прочит-ся как арг ком строки если EOF а не \EOF
    joe  $200
    sam  $25
    bill $9
    EOF

<<- # тоже самое только игнор символы табуляции перед _EOF_(в скрипте удобно)
<<< # чтение из 1 строки: <<< "Hello world"

# в скриптах:
exec 0< myfile	# позволяет сделать источником данных файл
exec 1>outfile	# перенаправит весь stdout в скрипте в файл
exec 2>myerror	# перенаправит stderr в скрипте в файл
>&1 			# вывод отдельной строки(в скрипте) в стдаут: echo "hi" >&1
>&2 			# вывод отдельной строки(в скрипте) в стдерр

# Создание собственного перенаправления вывода
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"

# Создание дескрипторов файлов для ввода данных
  Перенаправить ввод в скрипте можно точно так же, как и вывод. 
  Сохраните STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных
exec 6<&0
exec 0< myfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
y) echo "Goodbye";;
n) echo "Sorry, this is the end.";;
esac

# Закрытие дескрипторов файлов
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3

# Получение сведений об открытых дескрипторах
lsof            # список всех открытых в Linux дескрипторов
lsof -p <PID>   # указать ID процесса
lsof -d <num>   # указать номер дескриптора
echo $$         # узнать PID текущего процесса
lsof -a -p $$ -d 0,1,2  # объединение вывода

# Подавление вывода
2> /dev/null            # подавить вывод сообщений об ошибках
cat /dev/null > myfile  # очистить файл, не удаляя его

# работа с текстом------------------------------------------------------------+
cat  # объединение строк, cat file или cat < file или cat 0< file - чтение файла
     # cat > file "text" ctrl+D(EOF) чтение с клав-ры и запись в файл
     # cat >> file "text" ctrl+D чтение с клав-ры и дозапись в файл
     # cat << mystr пишем все, как напишем mystr(на отд строке) - вывод
     # cat -A -показывает табы ^I и конец строки $
     # -s - подавление пустых строк если больше 1
     # -n - нумерация строк
      
sort # сортировка строк текстовых файлов
     # sort [парам] файл(ы)
     # -b -сортировка пропускакт начальные пробелы
     # -f -игнор регистра
     # -n -сортировка по целым числам а не строкам
     # -g -сортировка по числам в математическом выр-ии т.е. с точкой дроби ...
     # -h -сортировка по числам если вывод в --human
     # -u -уникальные строки
     # -r -реверс
     # -k поле[,поле] -сортировка по опредкленным полям
     # -k2 - сортировка со второго поля
     # -k2.3 - сортировка со второго поля с 3 символа
     # -k2,2 - сортировка со второго поля по второе
     # -k2,3 -k4.4nr - со 2 по 3 поле и по 4-му с 4-го симв по ном рев
     # -k2.2,3.1br -k4.4nrb
     # -k4M -сортировка по месяцам если столбец из January-December
     # -t -определить символ-разделитель полей sort -t ':' -k3n /etc/passwd
           
uniq # принимает сортированный текст и выводит уникальные или повторяющиеся
     # sort text.txt | uniq -не выводит повтопяющиеся строки
     # -u - только уникальные 
     # -c - вывод количества повтгров строк
     # -d - только повторяющиеся
     # -f n - пропустить n полей
     # -s n - пропустить n символов
     # -i - игнор регистра

cut  # извлекае фрагменты текста из строк файлов и вывод в стд поток
     # cut -f3 -c1-3 file.txt -выводит 3 поле 3 символа, по умолч TAB раз-ль
     # -c символы 1-9[,11-12] -диапазон(ы) символов -c6,7-9,13- 
     # -f поля, диапазоны полей -f1,2,3-5,7-
     # -d символ разделитель, по умолчанию ТАБ

paste # обратная cut - добавляет колонки в файл -d - разделитель
      # paste file1.txt file2.txt - добавляет столбцы(поля)(колонки) 1 --> 2

join # объединяет поля из файлов по общему ключу поля(типа реляц. базы)
     # одно поле должно быть одинаковое и отсортированное, добавляет поля,
     # разделитель ТАБ -1 поле -2 поле  -указываются номера одинак поля в фай-х

wc   # вывод кол-ва: строки, слова, байты
head # первые 10 строк -n 5 5строк..
tail # последние 10 строк, tail -f -следит и выводит добавленные строки ctrlC
tee  # |tee file| копир со стд вывода в file и [передает дальше по конвейеру]
less # содержимое файла с возм-ю прокрутки/поиска
echo # выводит строку в стд поток
     # поддерживает wildcards echo *?[[:digit:]] ..
     # echo до{1,2,3}после - до1после до2после до3после - до{1..3}после..{Z..A}
     # подстановка переменных/комманд echo $(ls) $((2+2))
     # -e "Первая строка\nВторая строка" >> имя_файла.txt (обраб спец символов)

# проверка орфографии
aspell check myfile

# изменение текста
tr   # перекодирование или удаление текста, посимвольная операция поиска/замены
     # echo "some stdout"|tr [парам] 'что преобразовать' 'во чтг преобразовать'
     # tr a A < file.txt > new.txt -замена а на А в файле 1 и запимь в ыайл 2
     # tr -d '\r' < file.dos > file.unix -удаление символов
     # tr a-zA-Z A-Za-z - дипазоны
     # tr abc 123 -наборы символов или tr abcd # -абцд будут решетками
     # tr [:lower:] [:upper:] -posix классы

sed  # потоковый редактор, фильтрует и преобразовывает текст
     # прога исп рег выражения как в grep, они пишутся /так/
     # p - печать sed '1p' - печать 1 строки, '!p' - все кроме 1-ой
     # q - выходит при нахождении чего-либо
     # sed -i ... - сразу применить к файлу, иначе просто принт в стдаут
     
     #---замена---
     # sed [params] [file]... или echo "sometext" | sed [params]
     # команды применяются к каждой строке в файле/стдауте
     # -i -сразу поменять в исходном файле
     # sed 's/было/стало/' ./myfile  -замена первого вхождения в кажд строке
     # sed 's_old_new_' # можно применять любой разделитель после s, например
        для замены адресов удобнее так sed 's_/bin/bash_/bin/sh_' или экран ,\/
     # sed -e 's/old/new/'; 's/old2/new2/' ./file  # нескольк команд:
       -e com1; com2; com3; ...
     $ sed -e '  # вводим -е ковычка и многосточная команда :
     > s/This/That/
     > s/test/another test/' ./myfile
     # sed -f cfile ./myfile  # -f файл с командами, а не из стдин
        cfile: пример файла с командами
        # комменты через решетку
        s/This/That/
        s/test/another test/
     # sed 's/old/new/flags' # флаги:
        1  -цифра, каждое 1-е вхождение или какое указано цифрой в строке замещ
        g  -глобально все нахождения в строке замещаются
        p  -print строки в кот-х найд вхождения(исп с ключом -n -подав обыч выв)
        w file  -запись результатов обработки в файл 
     # sed '2s/было/стало/' ./myfile  -замена только во 2-й строке
     # sed '2,3s/было/стало/' ./myfile  -замена в дипазоне с 3-4 строки включ
     # sed '2,$s/было/стало/' ./myfile  -замена со второй до конца
     # sed '/шаблон/s/было/стало/' ./myfile  -поиск строк по регв и применение
     
     #---удаление---
     # sed '1d' ./myfile -удалить 1 строку
     # sed '1$' ./myfile -удалить последнюю строку
     # sed '2,3' ./myfile -удалить диапазон
     # sed '2,$' ./myfile -от и до конца
     # sed '/reg/d' ./myfile - поиск и удаление по шаблону
     # sed '/reg1/,/reg2/d' ./myfile - удал по шаблону плюс строки между ними
     # sed 's/^.//'  -удалить первый символ    ^.. ^...  -первые 2,3...
     # sed 's/.$//'  -удалить последний символ ..$ ...$  -послед 2,3...
     # sed ':a;N;$!ba;s/\n//g' myfile -удаление всех символов новой строки
     
     #---вставка---
     # 1 - первая строка, $ - последеяя строка
     # sed '1a\some string' myfile -вставляет строку после зад-ой а\ строки
     # sed '1i\some string' myfile -вставляет строку перед зад-ой i\ строкой
     # sed '3r textfile myfile -вставляет текст из файла после 3-й строки
     # sed '/reg/r textfile myfile -вставляет текст из файла после cтрок с шабл
     
     #---замена целой строки и отдельных символов---
     # sed '3c\modif string' myfile -замена 3-ей строки
     # sed '/reg/c New changed line' .myfile  -амена строк с исп шаблона
     # y/множество1/множество2  -замена как в tr y/123a/456A - пример
     
     #---номера строк
     # sed '=' myfile Выводит номера строк
     # sed -n '/reg/=' myfile  -выведет строки по шаблону с номерами 

# awk - обработка и фильтрация текста ---
# поля по умолчанию разделены пробелом, -F "*" - указать другой разделитель
echo "one two three"| awk '{print $1}' -выборка 1-го поля $NF -последнее
# awk использует переменные, операторы, циклы, условия, целый ЯП...------------

# Форматирование вывода--------------------------------------------------------
nl      # нумерация строк, в простейшем исп как cat -n
        # логическая страница в nl: заголовок: \:\:\:
                                   тело:      \:\:
                                   низ:       \:
        # эти эл-ты стоят отдельно в своих строках, удаляются после фильт-ии nl
        # каждая лог страница нумеруется заново
        # -w6  -по умолчанию поле 6 символов
        # -v1  -начать нумерацию с 1
        # -s'. ' - добавить после номера в кажд строке 
        # -ln -rn -rz  -выравнять по левому,правому,правому+00000
        # также можно нумеровать заголовки и низ, смотреть --help

fold    # перенос строк после указанной длины
        # принимает текст из файла или стд, по умолчанию 80 символов
        # -w12 -s  -перенос с 12 символов, по словам(ближайший пробел)

fmt     # простое форматирование текста, переносы, абзацы
        # -w 39 -ширина текста
        # -c -обработка края. 
        # -p # -обработать строки нач-ся с # или люб др символы

pr      # форматирование текста для печати, разбивка по страницам, длина, шир..

printf  # форматирование и выаод данных, не применяется в стд, только в сцен-ях
        # printf "формат" аргументы
        # printf "строка для форматиро%s\n" "вания" -пример подстановки
        # спецификаторы %s %d %f %o %x(%X) %% -строка, десятич, с точкой,8,16,%
        # %[флаги][ширина][.точность]спецификатор
        # флаги: # -альтернативный формат вывода, для 8-х и 16-х чисел
                0 -нули в начало поля, 00045 к примеру
                - -выравнивание по лев краю, по умолч по правому
                  -пробел добавляет пробел перед положительными числами
                + -выводит знак плюс перед положительными числами
        # ширина: минимальная ширина поля вывода
        # .точность: сколько символов после запятоц, для строк -кол-во символов
        # printf "Line: %05d %15.3f Result: %+15d\n" 1071 3.14156295 32589
        # 
        # 
        # 
groff   # система форматирования докум-в, отдельеая большая тема

# печать ---------------------------------------------------------------------+
pr      # преобразует текстовые файлы для печати 
lpr     # печатает файлы 
lp      # печатает файлы (System V) 
a2ps    # форматирует файлы для печати на принтере с поддержкой PostScript 
lpstat  # выводит информацию о состоянии принтера 
lpq     # выводит информацию о состоянии очереди печати 
lprm    # отменяет задания печати 
cancel  # отменяет задания печати (System V) 

# сравнение-------------------------------------------------------------------+
comm # построчное сравнение 2-х сортированных файлов
     # comm file1 file2  # два сортированных файла, выводятся в 3 колонки
     # 1- уник в 1 файле, 2- во втором, 3- в обоих
     # -123 # цифра параметра соответствует колонке вывод кот-ой подавляется

diff # сравнение построчно. 
     # -c контекстный формат -u унифицированный формат - -строка только в 1ф
                                                       + -строка только во 2ф
patch # изменения в файле 2 относительно файла 1
      # diff -Naur oldfile newfile > patchh.txt
      # patch < patchh.txt - применит изменения и oldfile будет равен newfile

cmp  # сравнения файлов побайтно -s -подавление вывода ----------------------+

# экранирование-------------------------------------------+
"" # экранируют все кроме $ \ `
'' # экранируют все
\  # экранирует спецсимволы в строке в "" $&\` также \n\t\a

# окружение-----------------------------------------------------+
printenv # (/usr/bin/env) - переменные окружения $USER, $PATH ... 
set      # выводит переменные и окружения и оболочки 
alias    # шаблоны
$PATH    # /etc/environment -тут все пути
export   # export PATH делает доступной переменную в дочерних процессах
# файлы запуска для сеансов ком оболочки входа(перед началом сеанса)
/etc/profile    # общисистемный конф сценарий для всех пользователей
~/.bash_profile # собственный файл запуска для определения/переопред сист настроек
~/.bash_login   # либо этот
~/.profile      # либо этот в ubuntu обычно
# файлы запуска для обычной сессии ком оболочки(работа в оболочке)
/etc/bash.bashrc # общесистемный
~/.bashrc        # личный, export PATH=~/bin:$PATH -добавление bin в пути
MYVAR=lalala    # моя переменная
export MYVAR    # добавить в окружение мою переменную
unset MYVAR     # убрать из окружения

# перемещение курсора--------------+
CTRL+A # в начало
CTRL+E # в конец
CTRL+F # символ вперед
CTRL+B # символ назад
ALT+F  # слово вперед
ALT+B  # слово назад
CTRL+D # удалить символ
CTRL+K # удалить до конца строки
CTRL+U # удалить до начала строки
ALT+D  # удалить до конца слова
ALT+BS # удалить до начала слова
CTRL+Y # вставить из буфера
CTRL+T # меняет символ с предыдущим
ALT+T  # меняет слово с предыдущим
CTRL+S # стоп-кадр терминала
CTRL+Q # выход из стоп-кадра терминала

# история--------------------------------------------------------------------+
clear # Ctrl+L очистка экрана
history # история команд !№ком в истории - вып-ся команда
        # поиск в ист CTRL+R ком-да ENTER(вып-ть) или CTRL+J(скопир в ком стр)
        # CTRL+R еще раз - след совпад в поиске.
        # CTRL+G CTRL+C - отмена/выход
!!      # last command
!:0     # номер слова строки(последней команды)
!xyz    # последняя команда нач-ся на 'xyz'
script  # запись сеанса оболочки в файл                                  ----+

# привилегии-----------------------------------------------------------------+
/etc/passwd # уч записи
/etc/group  # группы
/etc.shadow # пароли

groups      # вывод групп текущего пользователя
groups user # вывод групп пользователя

-rwxrw-r-- 
|\|/\|/\|/
| u  g  o  ugo = a  u-user, g-group, o-other, a-all
|  
+--+ #тип файла
   | - файл
   | d каталог 
   | l симлинк(симв ссылка)
   | с симв.устр(терминал, модем)
   | b блочное устр(hdd, cd-rom)
 
    #файл______________| #каталог______________________
r   читать/открывать   | читать(если +x)
w   запись/усекать     | создавать, удалять, перемещать(если +x)
x   выполнение         | разрешен вход(cd)
-   никаких действий   | никаких действий
s   вып-ся от влад-ца  | совместный каталог группы
t   нет действий       | нельзя удалять и переименовывать (sticky)

bin  oct    +-     umask
0    000    ---    6
1    001    --x       
2    010    -w-    0
3    011    -wx
4    100    r--    2
5    101    r-x
6    110    rw-    0
7    111    rwx

chmod  # изменить режим доступа к файлу
       # chmod u+x, g=rw, o-wx # изменение прав в буквенном знач
       # chmod 600 = (u=rwx, go-rwx) -rwx------ # цифровое изменение
       # chmod u+s, go=rx   = 4755 -rwsr-xr-x, вып-ся от имени владедьца
       # chmod g+s, = 2772 = drwxrwsr-- , совместная директория группы
       # chmod +t dir = 1777 = drwxrwxrwt , нельзя удалять преим
umask  # показать доступ к файлам по умолчанию, например 0002
         файлы 666-0002=664, директории 777-0002=775
         можно поменять маску по умолчанию: umask 0066

+-актуальные маски имеющие смысл---------+------+
|umask | bin           |права            | маска|
|0000  |000 110 110 110| --- rw- rw- rw- | 666  |
|0002  |000 110 110 100| --- rw- rw- r-- | 664  |
|0022  |000 110 100 100| --- rw- r-- r-- | 644  |
|0006  |000 110 110 000| --- rw- rw- --- | 660  |
|0026  |000 110 100 000| --- rw- r-- --- | 640  |
|0066  |000 110 000 000| --- rw- --- --- | 600  |
|0000  |000 111 111 111| --- rwx rwx rwx | 777  |
|0022  |000 111 101 101| --- rwx r-x r-x | 755  |

adduser name        # по умолчанию создаются параметры дистрибутива
useradd name        # низкоуровневая утилита, все в ручную
userdel -r name     # -r удалить юзера(-r - рекурсивно группу и все остальное)
usermod -l newuser olduser      # переименовать пользователя
groupmod -n newgroup oldgroup   # переименовать группу
usermod -aG group user          # добавить в группу|группы пользователя через,
newgrp group                    # применить группу сразу без логаута
deluser user group              # убрать пользователя из группы

id      # идентичность пользователя uid-номер юзера gid-номер группы юзера..
su      # смена пользователя su user
sudo    # root привилегии (суперпользователь - сп)
sudo su # войти в режим сп в этой же директории с .bashrc .profile пользователя
sudo -i # режим суперпользователя в его директории с его bashrc and profile
chown   # смена владельца chown user
        # смена группы файла chown :user
        # смена влад+группа user:user
        # -R рекурсивно все файлы и директории
sudo visudo # настройка разрешенных sudo комманд без ввода пароля
passwd  # passwd user - смена пароля пользователя   -----------------------+

# процессы------------------------------------------------------------------+
ps       # список процессов, вып-ся в данный момент
         # ps -el(unix режим) aux(bsd режим) все процессы
         # R - выполняется/готов к выполнению
         # S - приостановлен, в ожидании события   
         # D - приостановлен без возможности прерывания
         # T - остановлен принудительно, либо режим трассировки
         # Z - зомби, завершенный но не удален
         # < - выс приоритет
         # N - низк приоритет
         # niceness - уступчивость от -19 до 20
         # очень много параметров, смотреть man
!        # pid последнего фонового процесса -  echo $!
top      # вып-ся процессы в динамике, показывает загрузку cpu ram
CTRL+C   # прерывание вып-ия прог-мы
CTRL+Z   # приостановить процесс переднего плана(fg)
comm* &  # программа(процесс) запустится в фоновом режиме(на заднем плане bg)
jobs     # список заданий запущенных в терминале, '+' приоритетное задание 
jobs -l  # список заданий запущенных в терминале с PID
ps -l    # приостановленные задания
bg       # bg №задания - переведет процесс из приост-х на задний план
fg       # fg №задания - переведет процесс(приос-ый или bg) на передний план 
kill     # завершение процесса kill [-сигнал] PID 
kill -l  # список сиг-в  
killall  # послать сигнал на завершение сразу несколь№им пр-ссам
pstree   # дерево процессов
vmstat   # Выводит мгн снимок с информацией об использовании системных рес-в
pidof
pgrep    # grep ищет сразу в процессах по клю слову, -a -доп инфо по файлу
nice     # добавить уступчивочти -20 - 19
renice   # установить уступчивость -20 - 19
xload    # нагрузка на систему с теч времени (gui)
tload    # тоже самое но без граф инт

# найти и убить процесс
pgrep [-a] idea или ps aux | grep idea
kill <pid> или kill -9 <pid>

# сигналы
Код сигнала Название    Описание
1           SIGHUP      Закрытие терминала
2           SIGINT      Сигнал остановки процесса пользователем с терминала
                        (CTRL + C)
3           SIGQUIT     Сигнал остановки процесса пользователем с терминала 
                        (CTRL + \) с дампом памяти
9           SIGKILL     Безусловное завершение процесса
15          SIGTERM     (По умолчанию) Сигнал запроса завершения процесса
17          SIGSTOP     Принудительная приостановка выполнения процесса, 
                        но не завершение его работы
18          SIGTSTP     Приостановка процесса с терминала (CTRL + Z), 
                        но не завершение работы
19          SIGCONT     Продолжение выполнения ранее остановленного процесса


# репозитории - коллекции пакетов ----------------------------------
/etc/apt/sources.list       стандартные репозитории дистрибутива
/etc/apt/sources.list.d/    дополнительные репозитории - файлы .list

добавить репозиторий:
apt-add-repository 'deb http://rep_addr version branch'             # обыч реп
apt-add-repository 'ppa:repository/ppa'                             # ppa реп
echo "deb http://rep_addr version branch" >> /etc/apt/sources.list  # ввести напрямую
vim /etc/apt/sources.list.d/<имя_файла>.list                        # нов файл

добавить ключи безопасности(3 способа):
curl -L http://addr/repo_key | sudo apt-key add
wget -q -O - http://addr/repo_key | sudo apt-key add -
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys <http://addr/repo_key>

удалить репозиторий:
apt-add-repository --remove 'deb http://rep_addr version branch'    # обыч реп
/etc/apt/sources.list или в одном из /etc/apt/sources.list.d/*.list # закоментить строки
sudo add-apt-repository --remove ppa:repository/ppa                 # ppa реп
rm /etc/apt/sources.list.d/<имя_файла>.list                         # удалить файл

apt-cache policy                # проверка состояния репозиториев
apt-cache policy <имя_пакета>   # проверка конкретного пакета из репа


# apt (Advanced Package Tool) --------------------------------------------
Инструмент для управления пакетами, который обеспечивает удобный интерфейс 
для установки, обновления и удаления программного обеспечения

apt update                  # загружает информацию о доступных пакетах из 
                              всех настроенных репозиториев и обновляет кэш
apt upgrade                 # обновить все установл пакеты до послед версий
apt autoremove              # очистка неиспользуемых пакетов
apt full-upgrade            # upgrade + autoremove
apt install <имя_пакета>    # установить пакет 
apt install -f              # исправить проблемы с зависимостями
apt remove <имя_пакета>     # удалить пакет
apt purge <имя_пакета>      # удалить пакет и конфиг файлы
apt search <ключевое_слово> # поиск пакета
apt show <имя_пакета>       # инфо о пакете
apt list --installed        # список установленных пакетов


# dpkg -----------------------------------
Пакетный менеджер для Debian (.deb пакеты)

dpkg -i <имя_пакета>.deb    # установка пакета
dpkg -r <имя_пакета>        # удалить пакет
dpkg --purge <имя_пакета>   # удалить пакет и конфиг файлы
dpkg -l                     # список установленных пакетов
dpkg -s <имя_пакета>        # инфо о пакете
dpkg --configure -a         # исправить проблемы с зависимостями
dpkg --get-selections       # список файлов .deb в системе


# snap ---------------------------------------------
Система управления пакетами(разработчик - Canonical)
- Изоляция:             Snap-приложения работают в контейнерах
- Обновления:           Snap автоматически обновляет приложения
- Кроссплатформенность: Snap-пакеты могут работать на различ дистр Linux
- Зависимости:          Snap пакеты включают все необходимые зависимости

# установка
sudo apt install snapd
sudo systemctl enable --now snapd.socket

# комманды
sudo snap install <имя_пакета>  # установка пакета
sudo snap remove <имя_пакета>   # удалить пакет
snap list                       # список установленных
sudo snap refresh <имя_пакета>  # обновиьт пакет
snap info <имя_пакета>          # инфо


# flatpak ------------------------------------------
Система управления пакетами (разработан сообществом)
- Изоляция:             Flatpak-приложения работают в контейнерах
- Кроссплатформенность: работают на различ дистр Linux
- Расширяемость:        есть возможность создания "ретропакетов"

# установка
sudo apt install flatpak
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# комманды
flatpak install flathub <имя_пакета>    # установка пакета
flatpak uninstall <имя_пакета>          # удалить пакет
flatpak list                            # список установленных
flatpak update <имя_пакета>             # обновиьт пакет
flatpak info <имя_пакета>               # инфо


# устройства хранения----------------------------------------------------------+
/etc/fstab      # устройства монтируемые на этапе загрузки
/dev            # директория со всеми устройствами
/dev/sd*        # подключенные через SATA уст-ва
/dev/nvme*      # подключенные через NVME уст-ва
df -h           # показывает свободное простанство на дисках
lsblk -f        # список всех блочных устройств
fdisk -l        # таблица разделов на всех блочных устройствах
blkid           # выводит UUID ид-ры всех подкл устройств, а также файловую систему
lsusb           # информация о всех портах, подробности в man
parted -l       # таблица разделов MBR/GPT
badblocks -v /dev/sda1                  # проверка диска
hdparm -t --direct /dev/nvme0n1p3(sda3) # проверка скорости чтения диска(из lsblk)

mount  # список монтируемых устр-в
       # mount -t iso9660 /dev/sd? "folder" # монтирование cd-rom
       # mount /dev/sd?1(2,3..) "folder"    # монт флешки
       # mount -t iso9660 -o loop image.iso "folder" # монтирование образа диска
umount # umount /dev/sd? # размонтировать устр-во
fdisk  # проверка диска
fsck   # создание и редактирование разделов на диске/носителе
mkfs   # создание файловой системы на разделе
dd     # копирование устройств
       # dd if=/dev/sdb of=/dev/sdc # копипование диска1 в диск2
       # dd if=/dev/sdb of=disk.img # копипование диска1 в файл
       # dd if=/media/sdrom of=disk.iso # создание образа из cd
       # dd if=disk.iso of=/dev/sdc # загрузочная флешка с образа
md5sum # контрольная сумма md5sum image.iso - проверка после записи
genisoimage # genisoimage -o cd-rom.iso ~/mydir - образ из дир-ии
wodim  # wodim dev=/dev/cdrw blank=fast - очистка cd-rw
       # wodim dev=/dev/cdrw image.iso - запись образа

# форматирование размонтированной флешки
mkfs -t vfat -n NAME /dev/diskname # t - тип ф.системы L или n(для fat32) - имя
# либо использовать сразу без указания фс
mkfs.bfs     mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.vfat
mkfs.btrfs   mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.ntfs    mkfs.xfs

# network --------------------------------------------------------------------+
ip          # может выводить сведения о сетевых адресах, позволяет управлять 
              маршрутизацией трафика и, кроме того, способна давать данные о 
              различных сетевых устройствах, интерфейсах и туннелях.
ifconfig    # устаревшее средство, используй ip
mtr         # инструмент для диагностики сетей и устранения сетевых неполадок. 
              Эта команда совмещает в себе возможности ping и traceroute.
tcpdump     # предназначена для захвата и анализа пакетов
netstat     # используется для вывода сведений о сетевых соединениях и таблицах 
              маршрутизации, данных о работе сетевых интерфейсов, о 
              masquerade-соединениях, об элементах групп многоадресной рассылки.
ss          # пришел на замену netstat (тот же пакет net-tools)
nslookup    # применяется для выполнения DNS-запросов и получения сведений о 
              доменных именах или IP-адресах, а так же — для получения любых 
              других специальных DNS-записей.
ping        # проверка, на уровне IP, возможности связи одной TCP/IP-системы с 
              другой. Делается это с использованием эхо-запросов протокола ICMP
traceroute  # маршрут, по которому движутся сетевые пакеты
dig         # более крутая чем nslookup
vnstat      # A Network Traffic Monitor   
iftop       # Displays Bandwidth Usage
nload       # Displays Network Usage
nethogs     # Monitor Network Traffic Bandwidth
bmon        # Bandwidth Monitor and Rate Estimator
iperf3      # Network Bandwidth Measurement Tool
nmap        # показывает открытые порты, аудит сетевой инф-ры
wget        # узел/file загрузка файлов из сети
ssh         # -p port user@ip - подключение к удаленному компу
scp         # -P port user@ip:/file ./ передача файлов сюда
scp         # -P port ./ user@ip:/file передача файлов туда
ftp/sftp    # передача файлов get put вход как по ssh
/etc/hosts  # настройка своих доменов 'IP - домен'  192.168.0.222 my.alias.ru          


# ssh настройка сервера --------------------------------------------------------+
sudo apt install openssh-server  # установка сервера
sudo systemctl enable sshd       # автозагрузка
/etc/ssh/sshd_config             # фвйл настройки
Port 22                    # изменить на другой
PermitRootLogin - no       # root доступ запрет
PubkeyAuthentication yes 
PasswordAuthentication  - yes # авторизация по паролю
sudo systemctl restart ssh # рестарт юнита
 
подключение к серверу по ssh
ssh-keygen # запустить на клиенте генератор ключа
ssh-copy-id -i ~/.ssh/id_rsa.pub user@77.134.54.101 -p 22 # разместить public key на сервере
либо
id_rsa.pub # скопировать на сервер в .ssh/authorized_keys
id_rsa     # остается на клиентской машине
cat ~/.ssh/id_rsa.pub | ssh username@remote_host "cat >> ~/.ssh/authorized_keys"

sshpass подключение к серверу с паролем из скрипта
копирование файла с сервера себе:
sshpass -p "$password" scp "$username"@"$server":"$file_path" "$file_dest"
чтение файла с сервера:
sshpass -p "$password" ssh "$username"@"$server" "cat $file_path"


# vpn server ---------------------------------------------------+
Разворачиваем vps сервер
wget https://git.io/vpn -O openvpn-install.sh
sudo bash ./openvpn-install.sh
далее следуем командам, создаем/удаляем конфиги для пользователей


# Поиск файлов ----------------------------------------------------------------+
locate # поиск в базе данных имен locate zip, locatedb - обновить бд. 
find   # сложный способ поиска find "путь" "проверки" "операции" "параметры"
       # проверки: -type [fdbsl] тип файла(файл, каталог, устр-ва, ссылки)
                   -name "*.jpg" имя
                   -size +1M файлы более 1Мб (ckMG) байты кило мега гига
                   -perm 777 ищет файлы rwxrwxrwx 
                   -user -group -cmin ...
                   -mtime +90 старше 3-х месяцев(90 дней)
                   -mtime -2 за последние 2 дня
                   -daystart -ctime 0 за текущий день
                   -regex рег выражение 
       # операторы -or -and -not () (файл с одними perm) -or (каталог с др.)
                   -and идет по умолчанию между параметрами
       # операции: -print(по умолч) - выводит полный путь к файлу в стд 
				   -prinf "%f\n" - выводит filename без пути
                   -print0| xargs -0 -во избежании проблем с пробелами в файлах
                   -delete - удаляет найденный файл
                   -ls  - ком-да ls -dils в отношении найд файла
                   -quit - завершает ком после нахождения
                   -exec команда '{}' ';' -вып-ся команда для найд файла
                   -ok команда '{}' ';' -запрос y/n перед выполнением ком
                   # меняем ';' на + -все нахождения предадутся команде в виде
                     аргументов и команда вып-ся один раз, тоже самое xargs
                   -exec comm '{}' +  эквивал | xargs comm
                   # find . -name "*.jpg" -exec cp '{}' ./mydir ';' -копирова-
                    ние файлов .jpg в свою дир-ию
                   -print0| xargs -0 -во избежании проблем с пробелами в файлах
       # параметры: 
                   -noleaf - поиск не в Unix системах
                   -depth снач файлы потом каталоги в кот эти файлы, с del поум
                   -mount не вып обход кат-гов в кот смортир др сист
                   -maxdepth -midepth -глубина --------------------------------+
       # примеры:
                    find ./ -type f -mtime +30 -delete                -удалить файлы старше месяца
                    find ./ -name *.csv -exec grep -H "5295352" {} \; -найти в csv файлах подстроку
                                                                       и вывести название файла
# поиск текста grep------------------------------------------------------------+
grep # поиск в тексте по шаблонам(рег выражениям)
grep [парам] рег.выр [файл...]
     # параметры:
     -E # применять метасимволы из расширенного режима - egrep
     -i # игнор регистр
     -H # вывести название файла в котором найдено совпадение
     -v # инверсия поиска, сочетается с др пар-ми
     -c # счетчик совпадений
     -l # вывод только имен файлов где найдено совпад
     -L # вывод имен файлов где нет совпадений
     -n # плюс выводятся нумера строк с совпадениями
     -h # вывод без имен файлов, если не одие файл выбран для поиска
     -f # читать шаблон поиска, находящийся в предоставленном файле
     -P # включить механизм регулярных выражений Perl
     -R # -r - выполнить рекурсивный поиск подкаталогов.
     +------------------------------------------------------------------------+
     | базовые регулярные выражения и расширенные grep -E
     |grep  egrep   discribe
     | .            любой символ обязательный
     | \?   ?       совпадение с предыдущим элементом 0 или 1 раз
     | *            совпадение с предыдущим элементом 0 или более раз
     | \+   +       совпадение с предыдущим элементом 1 или более раз
     | ^            якорь начало строки
     | $            якорь конец строки
     | \(\) ()      объединение(захват) выраж (10|20){1,2}
     | \|   |       (или|или) одно из обязательное
     | []           любой символ в скобках, обязательный
     | [^]          любой симво не из скобок, обязательный
     | [0-9]        любой из диапазона, обязательныЙ [A-Z]
     | \{\} {}      повтор пред символа(группы символов){1,2}   
     | {n}          предыдущий элемент встречается n раз
     | {n,m}        предыдущий элемент встречается не менее n не бoлее m
     | {n,}         предыдущий элемент встречается n или более раз
     | {,m}         предыдущий элемент встречается не более m раз 
     | [:class:]    классы POSIX(стандарт)
     +------------------------------------------------------------------------+ 
zgrep # поиск в сжатых файлах -------------------------------------------------

# Архивация и резервное копирование
gzip/gunzip  # упаковать/распаковать gzip -d == gunzip, gunzip -t - просм архива  
bzip2        # поблочная упаковка bunzip2 - распаковка
tar          # помещает файлы и каталоги в архив
             # tar c(создать архив) x(извлеч из архива) t(просмотр) f(имя)
             # tar cf 'имя нового архива.tar' dir - новый архив
             # tar rf dir.tar 'ваши файлы' - добавить в конец архива
             # tar xf dir.tar - извлеч из архива все
             # find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
               добавит в архив только определенные найденные файлы
             # tar cf new.tar --wildcards *.txt - созд архив из .txttar
             # tar czf|cxf new.tgz|new.tbz - создаст сжатый архив gzip|bzip2
             # find . -name "*.txt"|tar cf tar.tar -T -  # дефис - это стд вывод
                                                           -T == --files-from=
             # ssh 192.168.0.106 'tar cf - ~/Music'|tar xf -  # создаем архив
               в стд вывод(cf -) из каталога на удаленном узле и со стд вывода
               извлекам к себе (xf -)
zip          # zip -r dir.zip dir | unzip dir.zip
             # ls -l /etc/ | zip ls-etc.zip -   # исп стд выв для записи в архив
             # unzip -p ls-etc.zip | less   # просмотр (-p - pipe конвейер)
rsync        # синх-я файлов и кат-ов с уд-ой сист-ой: rsync парам ист-к при-к
             # rsync -a dir1 dir2 # -a -рекурсив+права
             # sudo rsync -av --delete --rsh=ssh /etc /usr/local remsys:/backup
                -rsh=ssh -по сети, --delete -удалит на приемнике лишние ф-лы
             # такжe можно настроить синх с серверами rsync в интернете

# ==========================================================================
# Сценарии-------------------------------------------------------------------
--- Директории с программами и сценариями ---
/bin            # бинарные файлы исп системой
/sbin           # бинарные файлы исп системой с правами суперпользователя
/usr/bin        # общисистемные бинарные файлы
/usr/sbin       # общисистемные бинарные файлы с правами суперпользователя
/usr/local/bin  # для ваших сценариев и программ
/usr/local/sbin # для установленных с помощью пакет менеджера
~/bin			# для ваших сценариев и программ(создают самостоятельно)

--- Правила писания в баш скриптах ---
#!/bin/bash     # shebang/шебанг which bash(какой bash используется)
# comment       # строки начинающиеся с # или пустые строки - игнорируются
pwd				# the shell commands are entered one per line.
pwd; ls			# two commands have to be separated with semicolon.
echo "pri\		# \ исп в сценариях для переноса длинных строк
vet"
\n \$ \\ \( \) 	# экранирование спецсимволов
""  			# экранирование текста, можно использовать подстановку $
''  			# полное экранирование, что напишешь то и выведет
;   			# разделитель более 1-ой инструкций в одной строке

--- Код возврата ---
# любой сценарий, ф-я или команда возвращает код завершения
0               # успешное завершение/true
1-255           # ошибка/false
echo $?	        # выводит последний код завершения

--- Пользовательские переменные ---
a="hi"          # Присвоит переменной a строку "hi".
$a              # обращение к переменной a
$USER			# обращение к переменной окружения
b="a string"    # Внутренние пробелы должны находиться в кавычках.
c="$b"          # При присваивании допускается выполнять подстановку
d=$(pwd)  		# Результат выполнения команды.
d=`pwd`			# Тоже - результат выполнения команды.
e=$((5 * 7))    # Подстановка результата арифметического выражения.
f="\t\ta str\n" # Экранированные последовательности, такие как \t \n
a=5 b="hui"     # сразу несколько переменных
${myvar}        # {} -можно огораживать, избегать путанницы где-то
                  например a="foo"; echo "${a}bar"
					  
--- Операторы ---
# в Bash можно использовать только целые числа, для дробных - bc.
# 9223372036854775807 максимальное число.
+ -                     # унарные 
+ - * / % ** ++ --      # арифметические
= += -= *= /= %= **=    # присваивание
>> << & | ^ ~           # битовые
== > < != >= <=         # сравнение
$$ || !                 # логические
выражение1?выр2:выр3    # тренарный оператор, если 1 истино то 2, иначе 3

--- Числа ---
23                  # число в 10-чной системе
023                 # 19 восьмеричная система
0xFF                # 255 шеснадцатиричная система
основание#число     # система по основанию # $((2#101)) - 5

--- Строки ---
foo="" foo= foo=''	# пустые строки
echo ${foo:-"hui"}  # при попытке обращения к пустой переменной выведет хуй
echo ${foo:="bar"}  # если переменная пустая, то присвоить bar
echo ${foo:?"ext"}  # если пустая, то выведет ext в стдерр и выйдет с кодом 1
echo ${foo:+"pls"}  # если пустая, то ничего не выведет, 
                      есди не пустая выведет pls, а значение не изменится
${!префикс*}        # выводят все имена переменных начинаю-ся с префикса
${!префикс@}          ${!BASH*} или ${!BASH@} -выведет кучу переменных
$(#var)             # если параметр строкa - вернет длину строки,
                      если * или @ - вернет число позиционных параметров
${var:смещ:длин}    # срез строки от смещ до длин
${var#шаблон}       # вырезание шаблона если он найден вначале строки
${var#*шаблон}      # вырезание шаблона и всего предыдущего текста строки
${var##*шаблон}     # вырезание последнего совпадения с шаблоном и всего до
${var%шаблон}       # вырезание шаблона если он найден вконце строки
${var%шаблон*}      # вырезание шаблона и все что после, поиск с конца строки 
${var%%шаблон*}     # вырезание послед шаб и все что после, поиск с кон строки
${var/шаб/"str"}    # замена в var найденного шаблона на str
${var//шаб/"str"}   # то же, но во всей строке
${var/#шаб/"str"}   # то жe но начало
${var/%шаб/"str"}   # то же но конец

# examples:
$ prefix="hell"
$ suffix="ld"
$ string="hello-world"
$ foo=${string#"$prefix"}
$ foo=${foo%"$suffix"}
$ echo "${foo}"     # o-wor

--- Команда test ---
test expression     # любое выражение из таблицы ниже,
                      test возвращ результат выражения 0(true) или 1(false)
                      /usr/bin/test - расположение test.
выражение           | истино если:
--------------------+---------------------------------------
<path1> -ef <path2> | жесткие ссылки на один и тот же объект
<path1> -nt <path2> | 1 новее 2
<path1> -ot <path2> | 1 старше 2
          -e <path> | файл существует
          -b <path> | файл блочного устр-ва
          -c <path> | файл символьного устр-ва
          -f <path> | простой файл
          -d <path> | каталог
          -L <path> | символическая ссылка
          -G <path> | файл пртнадлежит действующей группе
          -O <path> | файл принадлежит дкйствующему пользователю
          -p <path> | именованый канал
          -S <path> | сокет
          -r <path> | атрибут чтение     \
          -w <path> | атрибут запись      - для текущего польз-ля
          -x <path> | атрибут выполнение /
          -u <path> | атрибут setuid
          -g <path> | атрибут setgid
          -s <path> | атрибут sticky bit

--- Скобки ---
()      Командная группа. Команды будут вып по порядку, в новых подоболочках.
        $(cmd) эквивалентна `cmd`.
        Используется для инициализации массива. 
        Example: $(pwd)             # вызвать команду pwd
                 array=(a b c d)    # иниц массив
(())    ((aexp)) Вычисл результат арифм выр: если 0 - false -> код возврата 1,
        если не 0 - true -> код возврата 0.
        Example: ((12)) - true --> 0.
                 ((0)) - false --> 1.
        ((lexp)) Вычисл результат логич выр: если false -> код возврата 1,
        если true -> код возврата 0.
        Example: ((x>12)) - false --> 1, переменные можно исп без $
                 ((x<12)) - true --> 0
        $((exp)) Можно использовать любое выражение и операторы, которое
        соответствуют правилам работы языка C, включая тернарный оператор.
        При использовании чисел отличных от 10-чной сист исч они автоматически
        будут преобразованы к десятичной системе исч. 
        Также не обязательно использовать знак '$' в переменных, но нумеров
        аргументы ком строки исп-ть с $1 $2 ...
        Example: $((x % 3))     команда --> return остаток от деления
                 ((x+=3))       переопределить значение переменной 'x'.
                 ((x < 120))    сравниваем, пододит для условий
[]      Внутренние команды bash, эквивалентные командам test, сравнения,
        тест файла, test -e ./file эквивалентен [ -e ./file ].
        '[' - команда /usr/bin/[ 
        ']' - это аргумент команды '[', который означает конец аргументов.
        Используется как часть рег выр для описания диапазона совпадающих симв.
        Также используется для указания индексов в массивах.
        Example: [ "$1" -eq "Ivan" ]
                 arr[1]=12
[[]]    Является расширением Bash. 
        '[[' - ключевое слово
        Позволяет использовать круглые скобки и логические операторы 
        !, && и || в скобках для объединения подвыражений.
        Имеет оператор соответствия =~ регулярных выражений.
        Строковые переменные можно исп без ковычек $mystr.
        Можно для сравнения вместо '==' использовать '='.
        Example: [[ -f $file1 && ( -d $dir1 || -d $dir2 ) ]]        # [[]]
                 [ -f "$file1" -a \( -d "$dir1" -o -d "$dir2" \) ]  # []
Diff    test -e "$file"  [ -e "$file" ]  [[ -e $file ]] # ковычки переменных
        [ "$str1" \> "$str2" ]  [[ $str > $str2 ]]      # экранирование < > 
        test $x -eq $y  [[ $x == $y ]]

--- Сравнение чисел ---
        выражение             
--------+--------+-----
test [] | (())   | true
--------+--------+------------
x -eq y | x == y | числа равны
x -ne y | x != y | числа не равны
x -le y | x <= y | меньше или равно
x -lt y | x < y  | меньше
x -ge y | x >= y | больше или равно
x -gt y | x > y  | больше
--------+--------+-------

--- Сравнение строк ---
[ выражение ]        | истино если:
---------------------+-----------------
"string"             | строка не пустая
-n "string"          | длина строки больше 0
-z "string"          | длина строки = 0
"str1" = "str2"      | строки равны '=' или '==' без разницы для [] [[]]
"str1" != "str2"     | строки не равны
string1 > string2    | строка1 больше в алфавитном порядке, для [[]]
string1 < string2    | строки1 меньше в алфавитном порядке, для [[]]
"str1" \> "str2"     | строка1 больше в алфавитном порядке, для test, []
"str1 "<" "str2"     | строки1 меньше в алфавитном порядке, для test, []
string =~ ^-?[0-9]+$ | строка соотв-т регвыр, только для [[]]
string == *.mp3      | сопоставление с шаблоном wildcards, для [[]]
---------------------+---------------------------------------------
    
--- Логические объединения выражений ---
операция | test, [] | [[]] (())
---------+----------+----------
   И     | -a       | &&
  ИЛИ    | -o       | ||
  НЕ     | !        | !
  -------+----------+--

--- Ветвление ------------------------------------------------------------------
--- if-else ---
if condition; then		    # условие 
    code
elif condition2; then       # доп проверки
    code
else                        # иначе
    code
fi                          # end if
Examples:
if grep 'ivar' /etc/passwd  # true если grep вернет какие либо строки
if [ -d /etc ] && [ -n $1 ] # combine tests using AND (&&) or OR (||)
if [ $x -lt 1024 ]          # numbers comparsion
if ((x < 1024))             # the same numbers comparsion

--- case ---
case str in 
    [шаблон[|шаблон]...) команды;;]...
esac
Example:
case $REPLY in
    0) echo "program terminsted"
       exit
       ;;
    # используются wildcards, любые шаблоны
    1|2) commands;;
    *.txt) commands;;
    [abs][1-9]) commands;;
    [[:alpha:]]) commands;;
    ???) commands;;
    *) commands;;  # все что не вошло под шаблоны
esac

--- Ветвление, операторы управления --------------------------------------
command1 && command2  # если com1 вернет true, то пробовать выполнить com2
command1 || command2  # если com1 не вернет true, то пробовать вып com2
Examples:
[ -e myfile ] && cat myfile  # если есть мойфайл то открыть его в кат
cat myfile || touch myfile   # если есть файл - открыть, если нет -создать

# можно объединять неск комманд {com1; com2} || com3
[[ -d $DIR ]] || { echo "error: no such directory: $DIR" ; exit ; }

# массивы ----------------------------------------------------------------
a[0]=foo        # создать массив а и присвоить 1-му л значение фуу
                # массивы нумеруются с нуля
declare -a a    # также создать массив а
a=(1 2 3 4)     # присвоитб сразу много щначений
a=([0]=a [1]=3) # множеств-е присваивание по индексу
echo ${a[0]}    # показат 1-ый эл, скобки {  }оoбязательны
for i in ${a[*]}; do echo $i; done  # вывод всех эл массива

a=("a" "b" "c d e")
${a[*]}    # "a" "b" "c" "d" "e"
${a[@]}    # "a" "b" "c" "d" "e"
"${a[*]}"  # "a b c d e"
"${a[@]}"  # # "a" "b" "c d e"

${#a[@]}   # кол-во эл-в в массиве
${#a[100]} # длина элемента
"${!a[@]}" # индексы массива которы присвоины переменные
a+=(9)     # добавление нового значения в конец массива

a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort)) # сортировка мас-ва
unset a    # удалить массив а
unset a[0] # удалить 0-й индекс

--- функции -----------------------------------------
glob=10             # глобальная переменная, можно исп/измен в функции
myfunc () {         # функцию объявляем до ее вызова
    local temp=5    # локальная пременная - видна только в ф-ии
    commands
    return 0        # вернуть код возврата 0-255, обрабатывать в парам $?
}
myfunc              # вызов функции(в подоболочке)
myfunc p1 p2 p3     # вызов с аргументами
myfunc $1 $2        # пересылка парам ком строки в ф-ю
echo $?             # используем код возврата функции 0-255

# в функциях те же правила 
  $0    -всегда и везде имя скрипта
  $1    -парам ф-ии
  $#    -кол-во параметров

# in loop
while [ $count -le 3 ]; do
    myfunc          # функция будет выполняться в подоболочке
    count=$((count + 1))
done

# передача массива
function myfunc {
    local newarray=("$@")
    echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}    # передаем массив

# рекурсивная Функция
function factorial {
    if [ $1 -eq 1 ]; then
        echo 1
    else
        local temp=$(( $1 - 1 ))
        local result=$(factorial $temp)
        echo $(( $result * $1 ))
    fi
}

# вызов функции из другого скрипта
# script1
    function addnum {
        echo $(( $1 + $2 ))
    }
# script2
    #!/bin/bash
    . ./script1                     # . или sourse 
    result=$(addnum 10 20)          # вызов ф-ии из др скипта
    echo "The result is: $result"

# Вызов bash-функций из командной строки
. ./script1     # или source ./script1
addnum 10 20    # использование прямо в ком строке


basename -команда удаляющая начальную часть пути к файлу

--- IFS -----------------------------------------------------------
Internal Field Separator, переменная окружения - разделитель полей.
Разделители по умолчанию - ' ', '\t', '\n' (любой из этих).
Bash встречая эти символы, считает, что перед ним следующий элемент списка.
IFS=$'\n'	- оптимально для чтения файлов.
IFS=":" 	- удобно для /etc/passwd.

--- read, чтение строки из стдин -------------------------------------------
read [-параметры] [переменная...] если переменная не указана то сохр в REPLY
параметры:
    -a массив       - сохр ввод в массив с 0-го индекса
    -d разделитель  - признак конца ввода, по умолч ентер- \n
    -e              - исп Readline, ввод как в ком строке
    -n число        - читает n-симврлов, а не всю строку
    -p приглашение  - показывать указанное приглашеник к вводу
    -r              - как в питоне строка без поддержки \n\t...
    -s              - silent режим, не видно что вводишь
    -t секунды      - по истеч времени вернется ненулевое знач
    -u дескриптор   - произвести ввод из файла, а не из стдин
переменная:
	read var1		- сохранит ввод в эту переменную
	read var1 var2  - неск перем, 
	$REPLY 			- если не указаны переменные то сохр сюда

Examples:	
read -p "Enter your name: " name		-аналогична двум командам ниже
echo -n "Enter your name: "
read name
read -p "Enter your name: " first last	-несколько переменных (исп пробел)
read -s -p "Enter your password: " pass	-скрытый ввод пароля  
<<< -оператор встроенная строка, подобно встр документу, но короче-до кон стр
Example: чтение файла
cat myfile | while read line; do
	echo $line
done
echo "Finished"

--- while -------------------------------------------------
while condition; do # пока условие true(0) цикл выполняется
    commands
done                # end loop
continue 			# новая итерация
break    			# выход из цикла
until    			# цикл типа while, только вып-ся условие false
Examples:
while [ $repeat -gt 0 ]; do {
    printf "$string"
    repeat=$((repeat - 1))
}
done
# чтение из файла с пом read, присваивание, вывод
while read distro version release; do 
	printf "Distro: %s\tVersion: %s\tReleased: %s\n" $distro $version $release
done < distros.txt  
# либо можно передать по конвейеру: файл|while read var;do ... ; done

--- for -----------------------------------------------------------
for i in <list>; do         # <list> список аргументов через пробел
    commands    
done
Examples:
file="/home/ivar/myfile"
for i in $(cat $file);do    # перебор строк в файле
    echo $i
done > myfile.txt			# перенаправление вывода в файл(для примера)
for i; do                   # обрабатываются по умолч позиц аргументы ком строки
for i in a b c d; do        # перебор строк разделенных пробелом
for i in {a..d}; do         # перебор символов из диапазона a-d включительно
for i in *; do          	# перебор файлов в тек дир можно с полным путем
for i in ~/dir/*.sh; do		# перебор файлов .sh с полными путями

--- for в стиле СИ ---
for ((i=0;i<5;i++)); do
    commands
done

--- trap/перехват сигналов --------------------------------------------------
# Команда trap позволяет скрипту реагировать на сигналы, в противном случае 
  их обработка выполняется оболочкой без его участия.
  В кач-ве команды часто используют вызов функции под разные сигналы.
trap "echo my msg" SIGINT SIGQUIT   #  код, который надо выполнить, и сигнал
                                       или сигналы, кот перехватываются.
trap "echo Goodbye..." EXIT         # перехватить сигнал выхода из скрипта
trap -- SIGINT                      # отмена перехвата сигнала

--- способы сохранения активности процессов при закрытии терминала -----
# Выполнение скриптов, не завершающих работу при закрытии терминала
./command &       # запуск программы в фоне           \
jobs -l           # посмотреть номер нужного процесса  -1 способ
disown %1         # удаление задачи                   /

nohup ./command & # вывод перенаправлен в 'nonhup.out' -2 способ(best)

screen and tmux   # также используются для этих целей  -3 способ

--- Параметы ком строки------------------------------------------------
# передавая программе аргументы в ком строке их можно использовать так:
    $0    	-всегда путь и название программы которая запустилась
    $1-9  	-любые аргументы ком строки
    ${10} 	-если параметров больше 9 - добавляем{}
    $#    	-кол-во параметров
	${!#}	-последний параметр
# пример myscript "a" "b" "c d e"
    $*    	-все аргументы, в виде одной строки  "a b c d e"
    $@    	-все аргументы, в виде отдельных строк  "a" "b" "c" "d" "e"
    "$*"  	-все аргументы в одной строке через пробелы "a b c d e"
    "$@"  	-все аргументы, в виде отдельных строк с уч пробелов "a" "b" "c d e"

shift    -команда которая убирает параметр $1, а все послед сдвигает на одно
          место к началу, $# становится на 1 меньше, $0 всегда неизменен.
		  
Example: перебор и вывод параметров
while [ -n "$1" ]; do
	echo "$1"
	shift
done
Example: как различать ключи и параметры
while [ -n "$1" ]; do
	case "$1" in
		-a) echo "Found the -a option" ;;
		-b) echo "Found the -b option";;
		-c) echo "Found the -c option" ;;
		--) shift	# ключи и параметры можно разделить с помощью "--"
		break ;;
		*) echo "$1 is not an option";;
	esac
	shift	# сдвиг, по идее дальше могут идти параметры
done
count=1
for param in $@; do	# вывод нумерованных параметров
	echo "Parameter #$count: $param"
	count=$(( $count + 1 ))
done

--- Ключи, договоренности ---
-a Вывести все объекты.
-c Произвести подсчёт.
-d Указать директорию.
-e Развернуть объект.
-f Указать файл, из которого нужно прочитать данные.
-h Вывести справку по команде.
-i Игнорировать регистр символов.
-l Выполнить полноформатный вывод данных.
-n Использовать неинтерактивный (пакетный) режим.
-o Позволяет указать файл, в который нужно перенаправить вывод.
-q Выполнить скрипт в quiet-режиме.
-r Обрабатывать папки и файлы рекурсивно.
-s Выполнить скрипт в silent-режиме.
-v Выполнить многословный вывод.
-x Исключить объект.
-y Ответить «yes» на все вопросы.

# встроенный метод трассировки, указываем в шебанг +x
#!/bin/bash +x  # будет показано подробное выполнение кода, знак + показывает
  трассировочную информацию, знак + храеится в PS4, ее можно изменить:
  export PS4='$LINENO + '  # поменяли на номер строки +
  set -x  # включение трассировки в коде сценария
  set +x  # выключение трассировки, это можно присеняь прямо в скриптах в коде
    
--- Группы команд и подоболочка --------------------------------------------
# группа команд вып-ся в текущей оболочке, а подоболочка - в дочерней(копия),
 после выполнения подоболочки все ее окружение и данные уничтожаются
| -всегда выполняется в подоболочке и все переменные уничтожаются после выхода
{ com1; com2; com3; }   # группа команд в тек оболоч (пробелы и ; обязательны)
(com1; com2; com3)      # группа команд в подоболочке
{ ls -l; echo "Listing of foo.txt"; cat foo.txt; } > output.txt  # перенап-е
(ls -l; echo "Listing of foo.txt"; cat foo.txt) > output.txt
# подстановка процессов
<(список команд)    # для процессов отправляющих рез-ты на стдаут
>(список команд)    # для процессов принимающих данные на стдин
# подстановка процесов интер-ет вывод подоболочки как обычный файл
  cat <(echo "foo")  -передается как типо это файл, заменяет
  echo <(echo "foo") -выведет /dev/fd/63 -файл где сохр эхо
  read < <(echo "foo")  -сохранит foo в REPLY
# подстановка проц-ов часто исп в циклах с read:
while read myvar1 myvar2; do
    cat <<- EOF
            var1: $myvar1
            var2: $myvar2
    EOF
done < <(ls -l|tail -n +2) -вывод подоб-ки напрвл-ся на стдин цикла(read) 
# различные примеры
rm $(find . -name '*.class')    # удалить рез-ты

--- Databases --------------------------------------------------------------
# Postgres, можно разрешить sudo без пароля, будет удобнее (sudo visudo)
sudo -u postgres psql -d mydb -c "SELECT * FROM celebrities;"
# with root
psql -U postgres -d mydb -c "SELECT * FROM celebrities;"
su -c "psql -d mydb -c \"SELECT * FROM celebrities;\"" postgres
# Подключиться к БД на удаленном сервере
psql -h <IP/domen> [-p <port>] -U <username> [-d <db_name>] -W
    IP/domen - IP-адрес или доменное имя сервера
    username - имя пользователя
    port     - необяз порт(по умолчанию 5432)
    db_name  - необяз имя базы данных

# Асинхронное выполнение
wait pid  # приостановка процесса, пока не завершится pid(какой-то фон.проц) 

# Именованные каналы
mkfifo pipe1   - сознание именованного канала
ls -l > pipe1  - перенаправление в им канал
cat < pipe1    - разб-ка канала и принятие данных(можно в другом терминале)

--- Планирование запуска скриптов -------------------------------
# Linux предоставляет пару способов запуска bash-скриптов в заданное время. 
  Это команда at и планировщик заданий cron.

--- at ---------------------------------------------------------------
at -f filename 'time'   # запуск скрипта по времени
# форматы указания времени/даты в место 'time' в команде:
    Стандартный, с указанием часов и минут, например — 10:15.
    С исп индикаторов AM/PM, до или после полудня, например — 10:15PM.
    С исп спец имён, таких, как now, noon, midnight.
    Станд формат даты, по шаблонам MMDDYY, MM/DD/YY, или DD.MM.YY.
    Текстовое представление даты, например, Jul 4 или Dec 25, 
    при этом год можно указать, а можно обойтись и без него.
    Запись вида now + 25 minutes.
    Запись вида 10:15PM tomorrow.
    Запись вида 10:15 + 7 days.
atq     # список заданий, ожидающих выполнения
atrm 18 # Удалить задание, ожидающее выполнения

--- cron -----------------------------------------------------------+
/etc/crontab        # главный файл который запускает все задачи
/etc/cron.minutely  # каждую минуту
/etc/cron.hourly    # каждый час
/etc/cron.daily     # каждый день
/etc/cron.weekly    # каждую неделю
/etc/cron.monthly   # каждый месяц
run-parts ./        # запуск всех скриптов +x в тек директории фонов реж     

grep CRON /var/log/syslog # логи

# crontab -l # список задач
# crontab -r # удалить все задачи
# crontab -e # создать задачу
    минута час день месяц день_недели /путь/к/исполняемому/файлу
    все расписано в комментах в crontab -e
    rm -f /var/run/crond.pid    # при ошибке «Resource temporarily unavailable»

# Example of job definition:
     .---------------- minute (0 - 59)
     |  .------------- hour (0 - 23)
     |  |  .---------- day of month (1 - 31)
     |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
     |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) 
     |  |  |  |  |       or sun,mon,tue,wed,thu,fri,sat
     |  |  |  |  |
     *  *  *  *  * user-name command to be executed

    # every minute
     * * * * * /home/ivar/bin/test.txt
    # every Monday at 0:00...
    0 0 * * 1 echo "every monday at 0:00 $(date)" >> /tmp/test.txt
    # every 1st and 15th days of each month at 1:25
    25 1 1,15 * * echo "1, 15 days $(date)" >> /tmp/test.txt
    # every 10 minutes every hour every day...
    */10 * * * * echo "every 10 minutes $(date)" >> /tmp/test.txt
    # every every 3 days...
    0 0 */3 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # every hour(between 0 to 5) at 2:30...
    30 2 0-5 * * echo "every 3 days $(date)" >> /tmp/test.txt
    # 30 Mon-Fri 9am-5pm
    */30 5-9 * * 1-5 echo "every bla-bla-bla $(date)" >> /tmp/test.txt

# cron examples
# every minutes every hour every day...
* * * * * echo "every minutes $(date)" >> /tmp/test
# 0:30, 1:30, 2:30, 3:30 ... 
30 * * * * echo "each 30 min every hours $(date)" >> /tmp/test
# each 5:30 every day, every month...
30 5 * * * echo "each 5:30 every day $(date)" >> /tmp/test
# every 1st day in month at 5:30 every month...
30 5 1 * * echo "each 1st day in month at 5:30  $(date)" >> /tmp/test
# every feb 1st day in month at 5:30 every year`...
30 5 1 2 * echo "each 1st day in Feb at 5:30 every year $(date)" >> /tmp/test

--- anacron --------------------------------------------------------------
Anacron имеет приоритет над cron если он установлен в системе, работает не
в абсолютном времени, а относительно самой последней загрузки системы.
/etc/anacrontab     # файл с заданиями
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
HOМE=/root
LOGNAМE=root
1 5 cron.daily run-parts --report /etc/cron.daily   
7 10 cron.weekly run-parts --report /etc/cron.weekly
@monthly 15 cron.monthly run-parts --report /etc/cron.monthly
1 5     # каждый день через 5 минут после загрузки системы
7 10    # каждый седьмой день через 10 мин после загрузки системы


--- Запуск скриптов при входе в систему и при запуске оболочки -----------
# скрипты можно расположить в следующих файлах
для текущего юзера:
~/.bash_profile     # вход в систему
~/.bash_login       # вход в систему (если нет .bash_profile)
~/.profile          # вход в систему (если нет .bash_profile и .bash_login)
~/.bash_logout      # закрытие оболочки bash
~/.bashrc           # при открытии оболочки bash

для всех пользователей:
/etc/environment    # старт системы
/etc/profile        # вход в систему
/etc/profile.d/*    # вход в систему, запускаются все файлы в директории
/etc/fstab          # старт системы, монтирование дисков/устройств

    
--- locale -------------------------------------------------------------------
locale          # информация о текущем языковом окружении
locale -a       # список всех установленных языков и кодировок -v - подробно
echo $LANG      # посмотреть настройки языка и кодировки
/etc/locale.gen # Список всех поддерживаемых (доступных для установки) локалей
locale-gen      # установить все локали из /etc/locale.gen()
locale-gen de_DE.UTF-8  # установка какой-либо локали
LANG=ru_RU.utf8         # изменить локаль на текущую сессию
export LANG=en_US.utf8  # добавить в .bashrc для изменения на постоянной основе
localectl set-locale LANG=en_US.utf8  # изменить локаль по умолчанию
/etc/default/locale     # локаль по умолчанию

--- PostgreSQL server --------------------------------------------------------
1	sudo nano /etc/postgresql/12/main/postgresql.conf
	#listen_addresses = 'localhost'
	заменить на
	listen_addresses = '*'
2	sudo nano /etc/postgresql/12/main/pg_hba.conf
	допишем в конец файла
	host      mydb       myuser  all          md5
3	Рестарт сервера
	sudo service postgresql restart

--- ffmpeg -------------------------------------------------------------------
ffmpeg -i input.avi output.avi  # simplest
input/output - regular files, pipes, network streams, grabbing devices...
streams - из чего состоят input/output - video/audio/subtitle/attachment/data
options:
-c:v libx264            # codec video(mp4)
-b:v 64k                # bitrate
-r 24                   # fps
-c:a aac                # codec audio
-vf scale=320:-1        # resolution (320 x auto)
map: (упреавление потоками)
-map 0:a:1 -map 0:a:0   # выбор аудиодорожек, их порядок
-map 0:s:0              # субтитры
examples:
# car music
ffmpeg -i input.avi -b:v 120k -c:v libx264 -vf scale=320:-1 -r 24 out.mp4
# old TV
ffmpeg -i input.webm -b:v 1200k -c:v libx264 -c:a aac -r 24 out.mp4
# заменить звук во втором видео звуком из первого видео без перекодирования
ffmpeg -i a.mp4 -i b.mp4 -map 0:a -map 1:v -c copy -shortest b_result.mp4
	
--- Java -----------------------------------------
sudo dnf install java
sudo dnf install maven
sudo vim /etc/profile
    # add to end of file
    export JAVA_HOME="/usr/lib/jvm/java-8-openjdk-amd64/"
    export PATH=$JAVA_HOME/bin:$PATH
sudo reboot
# for swing
sudo vim /etc/java-8-openjdk/accessibility.properties
    #assistive_technologies=org.GNOME.Accessibility.AtkWrapper
Для сглаживания шрифтов Adding this line:
_JAVA_OPTIONS='-Dawt.useSystemAAFontSettings=on -Dswing.aatext=true'
to /etc/environment
# настройка Idea
настроить keymap->navigate: back forward
# выбрать нужную java для запуска:
sudo update-alternatives --config java
# для VSCode выбрать compiler по умолчанию вставит в user settings
"java.configuration.runtimes": [
        
        {
          "name": "JavaSE-1.8",
          "path": "/usr/lib/jvm/java-8-openjdk-amd64",
        },
        {
          "name": "JavaSE-11",
          "path": "/usr/lib/jvm/java-11-openjdk-amd64",
          "default": true
        }
      ]

--- подключить сетевую папку Windows ------------------------
sudo apt install cifs-utils
mount -t cifs -o username=user,password=pass,file_mode=0666,dir_mode=0777 //IP/dir /mnt/hui
user        - логин
pass        - пароль
IP          - ip компьютера с сетевой папкой
folder      - имя сетевой папки
umount /mnt - umount


--- fstab монтирование устройств при запуске системы -----
1. создать файл /etc/cifs-creds и добавить в него данные авторизации
    > sudo echo -e "username=username\npassword=pass" >> /etc/cifs-creds
    > sudo chomd 600 /etc/cifs-creds
2. добавить в /etc/fstab
    //172.16.0.209/MedCenter /mnt/server02/MedCenter cifs credentials=/etc/cifs-creds,file_mode=0666,dir_mode=0777 0 0
3. sudo apt install cifs-utils      # необходимые утилиты
4. sudo systemctl daemon-reload     # перезапуск демона 
5. sudo mount -a                    # тестируем маунт из fstab


--- ярлык на рабочий стол/приложения Ubuntu ---
chmod +x ~/myscript.sh                              # делаем скрипт исполняемым
vim ~/.local/share/applications/myscript.desktop    # создаем ярлык для приложений
# Копируем на рабочий стол
cp ~/.local/share/applications/myscript.desktop ~/Desktop
    [Desktop Entry]
    Version=1.0
    Type=Application
    Name=My Script
    Comment=Run my custom script
    Exec=/bin/bash ~/myscript.sh
    Icon=utilities-terminal
    Terminal=false
    Categories=Utility;
    
    Name        - название приложения, как оно будет отображаться в меню.
    Comment     - описание приложения.
    Exec        - путь к вашему скрипту.
    Icon        - иконка приложения (замените на подходящую, если нужно).
    Terminal    - открывать терминал
update-desktop-database ~/.local/share/applications # обновить кэш


--- keyboard Language ----------------------
# сменить язык клавиатуры на Shift-Alt левые
gsettings set org.gnome.desktop.wm.keybindings switch-input-source-backward "['<Shift>Alt_L']"
# сменить язык клавиатуры на Alt-Shift левые
gsettings set org.gnome.desktop.wm.keybindings switch-input-source-backward "['<Alt>Shift_L']"
# сменить язык клавиатуры на Ctrl-Shift левые
gsettings set org.gnome.desktop.wm.keybindings switch-input-source-backward "['<Ctrl>Shift_L']"


--- Maven settings ---
    Deploy:
        ~/.m2/settings.xml
        или
        /etc/maven/settings.xml
        Вставить блок:
        <servers>
        <server>
            <id>myServer</id>
            <username>tomcat</username>
            <password>*******</password>
            </server>
        </servers>

        pom.xml
        <plugin>
            <groupId>org.apache.tomcat.maven</groupId>
            <artifactId>tomcat7-maven-plugin</artifactId>
            <version>2.2</version>
            <configuration>
                <url>http://172.16.0.246:8080/manager/text</url>
                <server>naukaServer</server>
                <path>/medserver${tomcatPathSuffix}##${project.version}</path> <-+ 
            </configuration>            +                      +-----------------+
        </plugin>                       |                                        |
                                        +----------------------------------+     |
        <version>0.9.8</version>                    # меняем версию +1 >---|-----+
        mvn clean install tomcat7:redeploy -P prod  # prod - имя профиля >-+


--- настройка статического IP -------------------
sudo vim /etc/netplan/01-network-manager-all.yaml

  network:
    version: 2
    renderer: NetworkManager
    ethernets:
      enp34s0:                                  - интерфейс
        addresses:
          - 192.168.0.229/22                    - нужный ip
        gateway4: 192.168.0.248                 - шлюз
        dhcp4: false                            - откл dhcp
        nameservers:    
          addresses: [192.168.0.247, 8.8.8.8]   - DNS сервера
