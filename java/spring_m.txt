Spring Core
--- About ---
    Это фреймворк, предназначенный для более быстрого и простого
    построения Java приложений.
    Создан: 2004.
    Последняя версия: Spring 5
    site: www.spring.io

    Maven pom.xml:
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.21</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>5.3.21</version>
    </dependency>

    ApplicationContext  - контейнер/хранилище объектов(бинов).
    Bean                - сущность/объект Java класса, создаваемая, хранимая 
                          в контейнере, которую можно получить из него.

--- Inversion of Control ---
    IoC - аутсорсинг создания и управления объектами. Т.е. передача нами
    прав на создание и управление объектами нами to Spring.

    Spring Container    - создание и хранение объектов
    config file         - описывает объекты кот будет создавать Container
    MyClass             - обращается к Container для получ объекта, а 
                          не создает их самостоятельно.

    MyClass <=====> Spring Container <--- config file
                                         /     |     \
                                       Dog    Cat    ...

    Основные функции Spring Container:
    IoC     - Inversion of Control, инверсия управления.
              Создание и управление объектами.
    DI      - Dependency Injection, внедрение зависимостей.

    Способы конфигурации Spring Container:
    XML file (устаревший способ)
    Annotations + XML file (современный способ)
    Java code (современный способ)

    Spring Bean (или просто bean/бин) - объект, который создается и 
    управляется Spring Container.
   
--- ApplicationContext config with .xml file ---
    // создаем файл в директории resources(root) "applicationContext.xml"
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

        <bean id = "myPet"  // id используется при создании бина
            class = "io.github.ivan100kg.spring_intro.Dog"> // full classname
        </bean>
    </beans>

    Создать Spring Container:
    ApplicationContext - это и есть Spring Container.
    // для способа 1, с пом xml, Pet - interface for Dog,Cat..
    ClassPathXmlApplicationContext context =        // get context
            new ClassPathXmlApplicationContext("applicationContext.xml");
    Pet pet = context.getBean("myPet", Pet.class);  // get bean (id, Class)
    pet.say();                                      // call Dog method
    context.close();                                // close context
    
    Теперь мы можем получать и управлять объектом Dog через 
    Spring Container, вызывая его по id - это и есть бин, чтобы 
    изменить напр Dog на Cat, нужно просто заменить в applicationContext.xml
    аттрибут class на io.github.ivan100kg.spring_intro.Cat

    Создание бинов через фабрику:
    <factory-method> - указываем метод и нов объект будет создаваться
    не через конструктор, а через статик метод - синглтон остается синглтон

--- Dependency Injection xml ---
    DI - аутсорсинг добавления/внедрения зависимостей.
    DI делает объекты нашего приложения слабо зависимыми друг от друга.

    Способы внедрения зависимостей:
    с помощью конструктора
    с помощью сеттеров
    Autowiring
    
    Способ #1 - с помощью конструктора:
    Допустим есть класс Person, который has an another class inside(Pet):
        public Person(Pet pet) {    // конструктор принимает об другого класса
            this.pet = pet;
        }
    Допишем зависимость в наш applicationContext.xml:
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog">
        </bean>

        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <constructor-arg ref="myPet"/>  // constructor-arg - арг костр
        </bean>                             // ref - ссылка bean id
    Далее можно не создавая класс Dog/Cat создать Person:
        Person person = context.getBean("myPerson", Person.class);
        person.callYourPet();   // some method of Person
        context.close();

    Способ #2 - с помощью setter:
    Добавим метод setPet to Person:
        public void setPet(Pet pet) {
            this.pet = pet;
        }
    Изменим applicationContext.xml:
        <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
            <property name="pet" ref="myPet"/>  // свойство pet -> метод setPet
        </bean>                                 // перв буква стан заглав -> Pet
                                                // внач добав set + Pet = setPet()
    Работает все также, код менять не надо - просто др способ.

    Внедрение других значений через методы(сеттеры):
    Например в классе есть 2 поля не иниц через конструктор, но нужно вызвать
    их сеттеры:
        // поля
        private String surname;
        private int age;
        // сеттеры
        public void setSurname(String surname) { this.surname = surname; }
        public void setSurname(int age) { this.age = age; }
    // как вызвать с пом applicationContext.xml 
    // способ #1 прямо в файле applicationContext.xml 
    <bean id="myPerson"
            class="io.github.ivan100kg.spring_intro.Person">
        <property name="pet" ref="myPet"/>
        <property name="surname" value="Bond"/> // value - передать значение
        <property name="age" value="39"/>       // name - св-во age->setAge()
    </bean>
    // способ #2 с пом др файла myFile.properties:
        person.surname = Bond   // создадим файл resources/myFile.properties
        person.age = 39         // добавим эти строки в myFile.properties
    // добавим эту строку перед всеми бинами
        <context:property-placeholder location="classpath:myApp.properties"/>
        classpath - местонахождение пользовательских классов(resources там же)
    // изменим applicationContext.xml 
        <property name="surname" value="${person.surname}"/>    // подставим
        <property name="age" value="${person.age}"/>
    Вызов значений из др файла ${name}, name может быть любым, но
    парвильнее и более понятно уточнять типа person.age
        

    }

--- Bean scope xml ---
    Scope - область видимости, определяет:
        жизненный цикл бина
        возможное кол-во создаваемых бинов
    Разновидности bean scope:
        singletone      // default, если не указан scope, 1 общий бин
        prototype       // бины создаются каждый раз при обращении getBean()
        request
        session
        global-session
    
    Singletone
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="singleton">    // можно не указывать
        </bean>
    Этот бин создается сразу после прочтния контейнером конфиг файла.
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext2.xml"
        );
        bean сдесь уже создан один и для всех.
    Является общим для всех, кто запросит его у контейнера.
        // получаем ссылки на бин
        Dog dog1 = context.getBean("myPet", Dog.class);
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // true
    Подходит для stateless объектов.(не хранящих состояния)

    Prototype
        <bean id="myPet"
          class="io.github.ivan100kg.spring_intro.Dog"
          scope="prototype">    // scope
        </bean>
    Такой бин создается только после обращения к контейнеру с пом getBean()
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        Dog dog1 = context.getBean("myPet", Dog.class); // создание
    При каждом обращении создается новый бин.
        Dog dog2 = context.getBean("myPet", Dog.class);
        System.out.println(dog1 == dog2);   // false
    Подходеит для stateful объектов.(хранящих состояние, например поле имя)

--- Life Cycle of bean xml ---
    Запуск      -->  Начало работы     -->  Создание  -->  DI - внедряются
    приложения       Spring Container       бина           зависимости
                                                                  |
    Конец работы  <--  Использование  <--  Бин готов для  <--  init-method
    Spring Container  нами этого бина     использования
          |
    destroy-method  -->  Остановка
                         приложения

    init-method используется для открытия или настройки каких-либо
    ресурсов(базы данных, стримы ...). Вызывается автоматически, можно
    использовать для запуска нашего кода при создании бина. Для scope = 
    prototype - init будет вызываться для кажд создания бина.
    
    destroy-method используется для закрытия этих ресурсов. Тут пишется
    логика после окончания работы с бином, перед его уничтожением. Также 
    вызывается автоматически. Если scope=prototype то destroy НЕ вызывается.

    Использование своего кода при init-method destroy-method:
    // добавим методы в наш класс Dog(такие названия не обязательно),
    модификаторы могут быть любыми
    return-type может быть любым, но так как не исп-ся - используют void
    параметров быть не должно.
        private void init() {
            System.out.println("class Dog: init method");
        }
        private void destroy() {
            System.out.println("class Dog: destroy method");
        }
    // свяжем их в applicationContext.xml
        <bean id="myPet"
            class="io.github.ivan100kg.spring_intro.Dog"
            init-method="init"          // методы можно называть как угодно
            destroy-method="destroy">
        </bean>
    // теперь при создании и закрытии бина
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                    "applicationContext2.xml"
        );
        // тут авто вызовется init() если scope НЕ prototype
        Dog dog = context.getBean("myPet", Dog.class);
        // тут авто вызовется init() для кажд бина если scope=prototype
        dog.say();
        context.close();
        // тут авто вызовется destroy() если scope НЕ prototype

--- ApplicationContext config with annotations ---
    Это более короткий и быстрый способ.
    Процесс в 2 этапа:
        сканирование классов и поиск аннотаций @Component
        создание(регистрация) бина в Spring Container
    
    // Для сканирования необходимо указать в applicationContext.xml где сканировать:
        <context:component-scan base-package="io.github.ivan100kg"/>
        Указываем эту строку и наш главный пакет с классами.

    // Теперь пометим наш класс аннотацией @Component
    @Component("catBean")   // сдесь задаем люб имя бина, либо по дефолту будет cat
    public class Cat implements Pet{
        @Override
        public void say() {
            System.out.println("Meow-Meow");
        }
    }

    // Создадим ApplicationContext и вытянем бин
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
                "applicationContext.xml"
    );
    Cat cat = context.getBean("catBean", Cat.class);    // получим бин 
    cat.say();
    context.close();

--- Dependency Injection with annotations ---
    -- DI @Autowired
    Для внедрения зависимостей с помощью аннотаций исп @Autowired.
    Может использоваться:
        конструктор
        method
        поле
    Использовать можно любой тип, но желательно придерж одного стиля.
    
    Использование с конструктором:
    // добустим есть class Person, конструктор приним об др класса Pet,
    пометим аннотацией 2 класса, тем самым создадим бины(если scope не prototype).
    @Component("personBean")
    class Person {
        @Autowired      // пометим конструктор аннотацией @Autowired
        public Person(Pet pet) {
            System.out.println("Person bean is created");
            this.pet = pet;
        }

    // use
    Person person = context.getBean("personBean", Person.class);    // correct
    person.callYourPet();
    Как произошло внедрение:
        После сканирования нашлось 2 бина (personBean, catBean)
        далее нашлась аннотация @Autowired (На конструкторе Person)
        начался поиск бина с типом Pet(тот что в параметрах конструктора)
        нашелся подходящий бин - catBean
        внедрение зависимости

        если не найдется подходящий бин - exception
        если найдется более 1 подходящего бина(например dogBean) - exception

    Использование с методом:
    @Component("personBean")
    class Person {
        @Autowired      // пометим метод аннотацией
        public void setPet(Pet pet) {
            this.pet = pet;
            System.out.println("Pet was set in Person");
        }
    
    // use
    Person person = context.getBean("personBean", Person.class);    // correct
    person.callYourPet();
    Как произошло внедрение:
        все также как и при конструкторе происходит внедрение

    Использование с полем:
    @Component("personBean")
    public class Person {
        @Autowired
        private Pet pet;
    
    // use
    Person person = context.getBean("personBean", Person.class);
    person.callYourPet();
    Как произошло внедрение:
        все также находятся бины, @Autowired, идет подстановка,
        сдесь под капотом исп-ся Reflecnion. 

    -- DI @Qualifier
    Когда находится более чем 1 бин при @Autowired происходит exception.
    Можно предотвратить указав какой бин должен быть внедрен с пом @Qualifier
                        @Autowired
                        @Qualifier("dogBean")   // выбор бина
                        private Pet pet;
                       /                \
    @Component("catBean")                @Component("dogBean")
    public Cat implements Pet {          public Dog implements Pet {   
    
    С полем и методом работает как и @Autowired.
    С конструктором:
        @Autowired
        public Person(@Qualifier("catBean") Pet pet) {  // указываем в параметре

    -- DI @Value
    Для внедрения строк и других значений мож исп аннотацию @Value
    Нет необходимости в сеттерах как при конфиге с пом xml.
    Значения устанавливаются не с пом сеттеров, а с пом Reflection.

    способ #1 -на месте
    @Component("personBean")
    public class Person {
        private Pet pet;
        @Value("Bond")  // устанавливаем значения пямо в классе
        private String surname;
        @Value("39")    // int тоже пишется в ковычках
        private int age;
    // use 
    System.out.println(person.getSurname() + " " + person.getAge());    // correct

    способ #2 -с пом .config файла
    <context:component-scan base-package="io.github.ivan100kg"/>
    <context:property-placeholder location="myApp.properties"/> // допишем
    // в классе исправим
    @Component("personBean")
    public class Person {
        private Pet pet;
        @Value("${person.surname}") // подстановка знач из файла
        private String surname;
        @Value("${person.age}")
        private int age;
    
--- Bean scope with annotations ---
    Те же правила, но создаются так:

    @Component              @Component  
    @Scope("singleton")     @Scope("prototype")
    public class Dog        public class Cat 

--- Life Cycle of bean with annotations ---
    Правила теже, создаются с пом аннотаций.
    @PostConstruct
    @PreDestroy

    Эти методы были выведены в Java 9, поэтому добавим зависимость в pom.xml
    <dependency>
      <groupId>javax.annotation</groupId>
      <artifactId>javax.annotation-api</artifactId>
      <version>1.3.2</version>
    </dependency>

    // применение
    @PostConstruct
    private void init() {   // после создания бина
        System.out.println("class Dog: init method");
    }

    @PreDestroy
    private void destroy() {    // перед уничтожением(НЕ для prototype)
        System.out.println("class Dog: destroy method");
    }

--- ApplicationContext config without xml ---
    способ #1
    @Configuration                  // класс является конфигурацией
    @ComponentScan("spring_intro")  // пакет для скана бинов и разл аннотаций
    public class MyConfig {}        // имя класса любое

    // создать ApplicationContext, отличается от xml способа, указываем
       наш @Configuration класс. 
    AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(MyConfig.class);
    Person person = context.getBean("personBean", Person.class);
    // Dependency Injection выполняется примерно так-же
    person.callYourPet();
    context.close();

    способ #2
    Сканирование не идет, поэтому убираем в конфиг-классе @ComponentScan
    Убираем все аннотации @Component @Autowired @Qualifier в классах
    
    @Configuration
    public class MyConfig {
        @Bean                   // @Bean регулирует создание и обращ к бину
        @Scope("singleton")     // можно указ scope - только 1 объект(как обычн)
        public Cat catBean() {  // id будет как наз-е метода "catBean"
            return new Cat();   
        }
        
        @Bean
        public Person personBean() {
            return new Person(catBean());   // DI прописываем зависимость
        }
    }
    // все работает также
    AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(MyConfig.class);
    Person person = context.getBean("personBean", Person.class);
    person.callYourPet();
    context.close();

    Использование @Value из конфиг файла (для 2-ух способов):
    Для того чтобы исп аннотацию @Value и подставлять наши значения из 
    конфиг файла нужно исп аннотацию @PropertySource

    // в классе Person
    @Value("${person.surname}") // значения берутся из кофиг файла <--------+
    private String surname;                                                 |
                                                                            |
    // Config.java                                                          |
    @Configuration                                                          |
    @ComponentScan("io.github.ivan100kg.spring_intro")                      |
    @PropertySource("classpath:myApp.properties")   // наш конфиг файл  ----+
    public class MyConfig {

Spring AOP
--- AOP Aspect Oriented Programming ---
    Это парадигма программирования, основанная на идее разделения основного
    и служебного функционала. Служебный ф-л записывается в Aspect-классы.
    В основе Aspect заключена сквозная логика(cross-cutting logic).
    Сквозная логика - это не бизнес функционал, это:
        логирование
        проверка прав(security check)
        обработка транзакций
        обработка исключений
        кэширование
    Бизнес логика - это основные/target методы.
    
    // пример Aspect класса в методах которого - сквозная логика
        // aspect class             // основной функционал
        class Aspect {              class Book {
            logMethod()                 addBook()
            secureCheckMethod()         
    Итак при вызове addBook() класса Book из основной логики программы, перед
    вызовом - вызовется logMethod() и secureCheckMethod() из сквозной логики.

    AOP - это посредник/proxy между Main class программы и др основными классами.
        Main class       AOP             Library class
        вызов       -->  Proxy      -->  addBook()
        addBook()        логи/права      выполнение

    Сквозной ф-л сосредоточен в 1-м или неск классах - легко менять.
    Благодаря конфигурации аспектов легко добавлять новый сквозные работы.
    Бизнес-код(основной) избавляется от сквозного кода - чистый код.
    Spring берет на себя сам обязанности по устройству AOP.

    AOP frameworks:
        Spring AOP  - прост в использовании, самая распространенная функ-ть
        AspectJ     - сложный, вся фукциональность AOP

--- Aspect class ---
    Aspect - это Proxy класс отвечающий за сквозную функциональность.
    // Пометим наш конфиг класс (здесь используется конфиг без xml)
    @Configuration
    @ComponentScan("mypacakge") // где сканировать бины
    @EnableAspectJAutoProxy     // за кулисами используется Spring AOP Proxy
    public class MyConfig {}

    // Создадим класс Aspect, он будет отвечать за сквозную ф-ть
    // Скачаем jar AspectJ Weaver с Maven repository и подключим к проекту
    // добавим зависимость в pom
        <!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.9.1</version>
            <scope>runtime</scope>
        </dependency>
    // Aspect класс для логов, имя любое
    @Component
    @Aspect                     // пометим наш класс @Aspect
    public class LoggingAspect {
        @Before("execution(public void getBook())") // ниже описано
        public void beforeGetBookAdvice() {         // название любое
            System.out.println("beforeGetBookAdvice: trying to get the book");
        }
    }
    Advice - термин AOP, метод внутри Aspect класса, который определяет 
    что и когда должно произойти при вызове основного метода (у нас getBook)
    Pointcut - выражение, опис где должен быть применен Advice.
    Advice типы:
    Before - выполняется до метода с осеновной логикой(getBook).
    After returning - вып-ся после нормального окончания основного метода.
    After throwing - вып-ся после основного метода если было исключение.
    After/After finnaly - вып-ся после метода с основной логикой.
    Around - вып-ся до и после метода с основной логикой.
    // реализация, помечаем @Annotation("execution(method())")
    @Before("execution(public void getBook())") - читается как: должно быть 
    выполнено ДО выполнения медота getBook(), это и есть Pointcut.

    // use
    AnnotationConfigApplicationContext context =
            new AnnotationConfigApplicationContext(MyConfig.class);
    Library library = context.getBean("library", Library.class);
    library.getBook();
    context.close();
    > beforeGetBookAdvice: trying to get the book   // наш Advice
    > We are getting the book                       // основной метод

--- Pointcut ---
    Это выражение, описывающее где ложен быть применен Advice.
    Spring AOP использует AspectJ Pointcut expression language, т.е.
    определенные правила в написании выражений для создания Pointcut.
    
    @Before("execution(void getBook())")
             -------------------------  // эта часть - pointcut
    Общее правило, шаблон по которому ищется основной метод:
    execution(modifiers? return-type method-class? method-name(params) throws?)
    ? - необязательный параметр

    Пример с указанием полного имени класса, для случаев если есть такие
    же методы в других бинах(классах):
    execution(void mypackage.Myclass.myMethod())

    Use with Wildcards:
    execution(void get*())      - методы начин-ся на get
    (* getBook())               - методы getBook с любым return type
    (* *)                       - метод без параметров с люб именем, mod, ret
    (void getBook(String))      - void method getBook with 1 String param
    (void *(*))                 - any void method with 1 any type param
    (* *(..))                   - люб метод, любое кол-во любых параметров
    (void get*(mypackage.Book)) - параметр пользовательский класс 
    (* *(mypackage.Book, ..))   - первый парам - Book, далее 0 или более люб пар

    Объявление Pointcut:
    Для того чтобы не писать один и тот же pointcut для нескольких Advice
    можно объявить Pointcut, затем использовать его на Advice много раз.
    @Pointcut("pointcut_expression")    // выражение типа execution(void get*())
    private void pointcut_ref(){}       // метод-ссылка без парам и тела
    Если необходимо один и тот же pointcut использовать в разных
    классах - можно вынести объявление в отдельный класс, а метод сделать public,
    использовать такой pointcut можно по полному имени.

    Использование на Advice:
    @Before("pointcut_ref()")           // указываем тот метод-ссылку тут
    public void advice_name(){code;}    // какой-то Advice
    теперь можно использовать на множестве Advice

    Плюсы Pointcut:
    Можно использовать 1 pointcut для множества Advice и в сучае чего менять
    код только в объявлении pointcut, а не по всем Advice.
    Возможность комбинирования - удобно.

    Комбинирование Pointcut:
    Pointcut поддерживают их объединение с пом лог операторов && || !
    // example with ||
    @Pointcut("execution(void get*())")         // первый pointcut
    private void allGetMethodsFromUL() {}

    @Pointcut("execution(void return*())")      // второй pointcut
    private void allReturnMethodsFromUL() {}
    
    // || - ИЛИ. Метод подходит под первый ИЛИ под второй pointcut 
    @Pointcut("execution(void get*()) || execution(void return*())")
    private void allGetAndReturnMethods(){}

    // example with &&
    @Pointcut("execution(* io.github.ivan100kg.aop.UniversityLibrary.*(..))")
    private void allMethodsFromUL(){
    }

    @Pointcut("execution(public void returnMagazine())")
    private void returnMagazineFromUL(){}

    @Pointcut("allMethodsFromUL() && !returnMagazineFromUL()")
    private void allMethodsExceptReturnMagazineFromUL(){}

    // Advice под последний pointcut, обработ-ся все методы кроме returnMagazine()
    @Before("allMethodsExceptReturnMagazineFromUL()")
    public void beforeAllMethodsExceptReturnMagazineAdvice(){
        System.out.println("beforeAllMethodsExceptReturnMagazineAdvice: Log #4");
    }

    Порядок выполнения pointcut:
    Если один метод обрабатывают несколько Advice то порядок обработки
    может быть разным в разное время.
    Если важен порядок обработки метода - необходимо раскидать Advice по 
    разным Aspect классам и пометить классы @Order(int) - порядок, 1 в приоритете
    если @Order одинаковый - то что выпонится быстрее - рандом.

    // вынесем объявление pointcut в отдельный класс, чтобы добраться до нашего
    // другим классам - нужно будет указать полное имя
    public class MyPointcuts {
        @Pointcut("execution(* get*())")
        public void allGetMethods() {
        }
    }

    // создадим отдельные Aspect-классы для Advice обрабатывающих одинак методы
    // рассмотрим один Asp будет похож на этот
    @Component
    @Aspect
    @Order(1)   // меньше число - больше приоритет
    public class SecurityAspect {
        @Before("io.github.ivan100kg.aop.aspects.MyPointcuts.allGetMethods()")
        public void beforeGetSecurityAdvice() {
            System.out.println("beforeGetSecurityAdvice: check rights");
        }
    } 

--- Join Point ---
    Это точка/момент в выполняемой программе когда следует применять Advice.
    Это точка переплетения метода с бизнес-логикой и метода со служебным ф-м.
    Прописав Join Point в параметре метода Advice, мы получаем доступ к 
    информации о сигнатуре и параметрах метода с бизнес-логикой.

    // получить всю инфу об основном методе
    @Before("io.github.ivan100kg.aop.aspects.MyPointcuts.allAddMethods()")
    public void beforeAddLoggingAdvice(JoinPoint joinPoint) {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        System.out.println("mS: " + mS);
        System.out.println("mS.getName(): " + mS.getName());
        System.out.println("mS.getMethod(): " + mS.getMethod());
        System.out.println("mS.getParameterTypes(): " + Arrays.toString(mS.getParameterTypes()));
        System.out.println("mS.getReturnType(): " + mS.getReturnType());
        Object[] arguments = joinPoint.getArgs();   // аргументы
        System.out.println(Arrays.toString(arguments));

--- Advice Types ---
    @Before
    Выполняется до метода с основной логикой.
    @Before("execution(* getStudents())")
    public void beforeGetStudentsLoggingAdvice() {
        System.out.println("beforeGetStudentsLoggingAdvice: log #2");
    }

    @AfterReturning
    Вып-ся после нормального окончания основного метода, но до возврата 
    значения из него, поэтому можно изменять возвращаемый результат.
    // добавим в @AfterReturning через запятую именованные параметры
    // pointcut = "execution(* getStudents())" - просто именованный pointcut
    // returning = "students" - это то что возвращает основной метод
    // добавим параметр в Advice List<Student> students - то что возвращ осн метод
    // "students" должен совпадать с параметром Advice (students)
    @AfterReturning(pointcut = "execution(* getStudents())", returning = "students")
    public void afterReturningGetStudentsLoggingAdvice(List<Student> students) {
        students.remove(0); // делаем любые манипуляции с возвращаемым obj
                               после манипуляций будет возврат из основного мет
                               уже измененного объекта.
        System.out.println("afterReturningGetStudentsLoggingAdvice: log #10");
    // если необходимо можно включать JoinPoint первым параметром

    @AfterThrowing
    Вып-ся после основного метода если возникло исключение.
    // throwing = "myEx" ловим искл, должно совпадать с параметром Advice
    // метод будет прерван, исключение будет проброшено выше, мы ничего
    // не сможем предотвратить, но можем например залогировать.
    // можем первым параметром включать JoinPoint
    @AfterThrowing(pointcut = "execution(* getStudents())", throwing = "myEx")
    public void afterThrowingGetStudentsLoggingAdvice(Throwable myEx){
        System.out.println("afterThrowingGetStudentsLoggingAdvice: throws " + myEx);
    }

    @After
    Вып-ся после оконч метода с основ логикой, в любом случае(с исключ или без).
    // невозможно получить доступ к исключению, если выбросилось
    // невозможно получить доступ к return параметру
    @After("execution(* getStudents())")
    public void afterGetStudentsLoggingAdvice(){
        System.out.println("afterGetStudentsLoggingAdvice: log #12");
    }

    @Around
    Вып-ся до и после метода с основной логикой. Можно провести след действия:
        -произвести какие-либо действия до работы target метода
        -произвести какие-либо действия после работы target метода
        -получить/изменить результат работы target метода
        -предпринять какие-либо действия, если из target выбрас исключение
    // добавим в параметры метода ProceedingJoinPoint - это связь с target методом
    // ProceedingJoinPoint обладает тем же ф-м что и JoinPoint
    // изменим return type на Object который явл результатом point.proceed()
    @Around("execution(String returnBook())")
    public Object aroundLoggingAdvice(ProceedingJoinPoint point) throws Throwable {
        System.out.println("Before target method");
        Object targetResult = point.proceed();      // вызов target метода
        System.out.println("After target method");
        return targetResult;                        // результат
    }
    // можно изменить результат перед возвратом на любой
    // например можно засечь время выполнения target метода с пом @Around
        System.out.println("Before target method");
        long start = System.currentTimeMillis();
        Object targetResult = point.proceed();
        System.out.println("After target method");
        System.out.println("time: " + (System.currentTimeMillis() - start));
        return targetResult;
    При выбрасывании исключения в target методе можно делать следующее:
        -ничего не предпринимать
        -обработать исключение, завернуть point.proceed() в try-catch
        -проброс исключения дальше/выше:
        System.out.println("Before target method");
        Object targetResult = null;
        try {
            targetResult = point.proceed();
        } catch (IllegalStateException ex) {
            System.out.println("Caught: " + ex.getMessage());
            throw ex;   // проброс/rethrowing
        }
        System.out.println("After target method");
        return targetResult;

Spring MVC
--- MVC ---
    Model View Controller - шаблон проектирования web приложений.
    Model       - данные приложения и работа с ними(чаще в БД)
    View        - внешний вид отображение данных, взаимод с пользователем
    Controller  - связь между View и Model. Бизнес логика приложения.

    Spring MVC  - фреймворк для создания web-app на Java, на базе MVC.
    Можно использовать основной ф-л Spring: IoC, DI.

    Схема работы Spring MVC:
    Б  request                delegate req                handle req
    Р ---------> |Front     | -------------> |Controller| ----------> |Backend|
    А <--------- |Controller| <--model------ |__________| <---------- |_______|
    у  responce    ^    |   delegate rendering  
    З              |    |
    Е              |    |           render responce
    Р              |    +---model--> |View    |
                   +---------------- |Template|
                                    return control
    
    Front Controller(DispatcherServlet) - явл частью Spring, делегирует 
    HTTP-запросы обычным контроллерам(может быть 1+ контроллеров).
    Controller - центр управленияб моззг Spring MVC приложения.
    Model - контейнер для хранения данных.
    View - web страница, кот можно создать с пом HTML, JSP, Thymeleaf и т.д.,
    часто при отображении View используют данные из Model.

    Для создания web-страниц можно использовать:
    JSP (Java Server Page) - спецификация: HTML + Java code.
    JSTL (Java Server Pages Standart Tag Library) - расширение спец-ии JSP.
    JSP конвертируется в обычный HTML при отправки ответа.

    Состав Spring MVC приложения:
        Конфигурация Spring(обычная xml/annotations/java code)
        Описание Spring бинов(+доп аннотации)
        Web страницы

--- Configuration ---
    1. Create Maven project with archetype: "maven-archetype-webapp"
    2. Add dependencies to pom.xml [Spring Context,
                                    Spring Core, 
                                    Spring Beans,
                                    Spring Web,
                                    Spring Web MVC,
                                    JavaServlet(TM) Specification,
                                    JSTL(где больше usages)]
    3. Download Tomcat, разархивируем архив. Добавим в Idea 
       -> run -> Edit Configurations -> + -> Tomcat Server Local ->
       -> configure -> выбираем dir где tomkat -> ok -> ok -> fix ->
       -> exploded -> apply -> ok 
       запускаем: run -> run 'tomkat'
    4. Add dirs/packages
       sourse root: main/java
       my packages: main/java/io.github.ivan100kg
       my views:    webapp/WEB-INF/view
    5. Configure webapp/WEB-INF/web.xml
    6. Create+Configure webapp/WEB-INF/applicationContext.xml

    # web.xml
    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="http://xmlns.jcp.org/xml/ns/javaee"
            xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
            id="WebApp_ID" version="3.1">

    <display-name>spring-cource-mvc</display-name>

    <absolute-ordering />

    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/applicationContext.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    </web-app>

    Все стандартно кроме param-value - пишем свой конфиг файл,
                         url-pattern - / (любой url)

    # applicationContext.xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd">

        <context:component-scan base-package="io.github.ivan100kg" />

        <mvc:annotation-driven/>

        <bean
                class="org.springframework.web.servlet.view.InternalResourceViewResolver">
            <property name="prefix" value="/WEB-INF/view/" />
            <property name="suffix" value=".jsp" />
        </bean>

    </beans>
    
    Бин тут для простоты обращения к своим view, которые будут созданы 
    в /WEB-INF/view/. Например /WEB-INF/view/myView.jsp можно будет
    использовать как myView - префикс и суффикс допишется авто.

--- Controller ---
    @Controller                         // класс - контроллер (это @Component)
    public class MyController {
        @RequestMapping("/")            // связывает URL '/' c  -->--------+
        public String showFirstView(){  // люб назв, мог быть парам-ры     |
            return "first-view";        // webapp/WEB-INF/first-view.jsp <-+
        }
    }

    При обращении на сервер на корневую страницу отобразится след файл:
    # WEB-INF/view/first-view.jsp
    <!DOCTYPE html>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
        <h2>I wish you luck in Spring MVC learning</h2>
    </body>
    </html>

--- Using data in views ---
    Чтение данных из формы:
       GET url: /askDetails      C
    Б -------------------------> O
    Р                            N 
    А <------ view/page1.jsp --- T
    У                            R
    З  POST url: /showDetails    O
    Е -------------------------> L
    Р                            L              
      <------view/page12.jsp --- E
                                 R

    # MyController.java - добавим 2 обработчика
    @RequestMapping("/askDetails")          // url
    public String askDetails() {            // 
        return "ask-emp-details-view";      // view
    }

    @RequestMapping("/showDetails")
    public String showDetails() {
        return "show-emp-details-view";
    }

    # view/ask-emp-details.jsp(теги html,body.. не показаны)
    <h2>Dear Employee, Please enter your details</h2>
    <form action="showDetails" method="get">                // action go to url
        <label for="n1">Your name:</label> <br>
        <input type="text" id="n1" name="employeeName">     // employeeName -+
        <input type="submit"/>                                               |
    </form>                                                                  |
                                                                             |
    # view/show-emp-details.jsp(теги html,body.. не показаны)                |
    <h2>Dear Employee, you are WELCOME!!!</h2>                               |
    <p>Your name: ${param.employeeName}</p>                 // из формы <----+

--- Add/extract data to/from Model ---
    # 1 способ с пом HttpServletRequest
    @RequestMapping("/showDetails")
    public String showDetails(HttpServletRequest request, Model model) {
        String empName = request.getParameter("employeeName");  // параметр из 
        empName = "Mister " + empName;                             view
        model.addAttribute("nameAttr", empName);                // добавим данн
        return "show-emp-details-view";                            в модель(ключ
    }                                                              -значение)
    HttpServletRequest request  - для работы с запросом, много полезных ф-ий
    Model model                 - модель, можно добавлять различные ключи-знач
                                  ключ - String, значение - Object(люб тип)

    # 2 способ с пом @RequestParam
    @RequestMapping("/showDetails")     // URL '/showDetails'
    public String showDetails(@RequestParam("employeeName") String s, Model m) {
        s = "Mister " + s;                          |
        m.addAttribute("nameAttr", s); -->----------+-----------------------+
        return "show-emp-details-view";             |                       |
    }                                               |                       |
                                                    |                       |
    # view/ask-emp-details.jsp                      |                       |
    <form action="showDetails" method="get">        ^                       |
        <label for="name">Your name:</label> <br>   |                       |
        <input type="text" id="name" name="employeeName">                   |
        <input type="submit"/>                                              |
    </form>                                                                 |
                                                                            |
    # view/show-emp-details.jsp                                             |
    <h2>Dear Employee, you are WELCOME!!!</h2>                              |
    <p>Your name: ${nameAttr}</p>   // изъять данные по ключу из модели <---+

    @RequestParam("employeeName") - связывает поле формы(name="employeeName")
    с параметром метода из Controller(showDetails).