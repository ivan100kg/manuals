Общие понятия
Entity - Entity это легковесный хранимый объект бизнес логики (persistent domain object).
Основная программная сущность это entity класс, который так же может использовать 
дополнительные классы, который могут использоваться как вспомогательные классы или 
для сохранения состояния еntity.

DTO (Data Transfer Object) - это объект, который используется для передачи данных
между слоями приложения или между различными приложениями. Он содержит только 
необходимую информацию для передачи и обычно не содержит методов работы с данными.
DTO обычно используются для уменьшения количества данных, которые нужно передавать
по сети, и для повышения производительности.

POJO (Plain Old Java Object) - это простой Java-объект, который не зависит от 
какой-либо специфической технологии или фреймворка. POJO представляет простой 
контейнер для данных, не имеет специальной логики и не наследуется от каких-либо 
специальных классов. POJO обычно используются для абстракции данных и повышения 
гибкости и переносимости кода.

ORM (Object-Relational Mapping) - маппинг Java-объектов на SQL-запросы. 
Преобразование объекта в строку в таблице и обратное преобразование.
Каждой таблице в базе данных должен соответствовать какой-то класс в Java-приложении.
В Java приложении мы оперируем объектами, а эти объекты уже умеют сами сохранять 
себя в базу данных.

JPA (Java Persistence API) - Это именно спецификация. Она описывает, как все должно 
работать и какими аннотациями нужно отмечать различные части класса, если мы хотим, 
чтобы его объекты сохранялись в базу данных.


===========================================================================

JDBC
--- Basic ---
    Java Database Connectivity
    Работа Java с различными СУБД.

    Driver          - сущность(класс) необходимая для соединения Java с БД,
                      для разный СУБД свой драйвер.
    DriverManager   - класс с помощью которого выбирается драйвер
    // драйвер(например postgres) можно загрузить с пом maven pom.xml:
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.6</version>
    </dependency>
    // далее загрузим этот класс в JVM с пом загрузчика:
    Class.forName("org.postgresql.Driver");         // загрузка класса загрузчиком
    Class.forName(className, true, currentLoader);  // эквивалент того что выше

    В JDBC есть 3 основных интерфейса:
    Connection  - отвечает за соединение с базой данных
    Statement   - отвечает за запрос к базе данных
    ResultSet   - отвечает за результат запроса к базе данных

    --- Полный цикл ---------------------------------------------------
    -- подключение к PostgreSQL с помощью JDBC
    Connection conn = DriverManager.getConnection(
                "jdbc:postgresql://192.168.0.104:5432/mydb",    // url
                "user",                                         // user
                "password");                                    // password
    url - jdbc:protocol://IP:port/db_name

    -- запрос к БД
    Statement stmt = conn.createStatement();   // создать запрос
    
    -- выборка данных executeQuery()
       возвращает собственно данные по запросу в виде ResultSet
    ResultSet res = stmt.executeQuery("SELECT * FROM my_table;");
    
    -- изменение данных executeUpdate()
       возвращает целое число - кол-во измененных строк
       DML:INSERT/UPDATE/DELETE; DDL:CREATE/ALTER/DROP
    stmt.executeUpdate("INSERT INTO my_table (name, score) VALUES ('Lisa', 35);");

    -- обработка результата - можно получать любой тип данных (getTimestamp())
    while (resultSet.next()) {  // похож на Iterator
        int id = resultSet.getInt(1);               // выбираем поля по порядк номеру       
        String name = resultSet.getString("name");  // либо выбираем поля по имени
    }

    -- закрываем все по порядку
    stmt.close();
    conn.close();
    -------------------------------------------------------------------------

    -- PreparedStatement 
    Statement: используется для простых случаев запроса без параметров.
    PreparedStatement позволяет:
        Заранее подготовить запрос с указанием мест, где будут подставляться параметры
        Установить параметры определенного типа и выполнить после этого запрос с уже 
        установленными параметрами
    // запрос с указанием мест для параметров в виде знака "?"
    String sql = "INSERT INTO students (name, score) VALUES (?, ?);"
    PreparedStatement pstms = connection.prepareStatement(sql); // создать запрос
    // использование с нашими параметрами - типы разнообразные
    pstms.setString(1, "Bob");                                  // set params
    pstms.setInt(2, 50);
    pstms.executeUpdate();                                      // выполнить запрос,
                                                                   без параметров
    -- CallableStatement
    Используется для вызова (Call) хранимых процедур в базе данных
    CallableStatement cstmt = Connection.prepareCall();         // создать запрос
    могут возвращать значения в отличие от PreparedStatement

    -- Транзакции
    По умолчанию AutoCommit у объекта Statement = true
    Можно отключить AutoCommit и обрабатывать транзакции вручную
    Если автокоммит не отключить то на каждую вставку строки - одна транзакция,
    выходит во много раз дольше. 80000мс против 44мс
    // пример транзакции вручную
    connection.setAutoCommit(false);    // отключить автокоммит
    for (int i = 0; i < 10000; i++) {
        pstms.setString(1, "Bob" + i);
        pstms.setInt(2, 50 + i % 10);
        pstms.executeUpdate();
    }
    connection.commit();                // завершение транзакции
    connection.rollback();              // откат транзакции

    Savepoint - точка сохранения состояния базы, позволяет откатиться к этой точке
    Savepoint sp1 = connection.setSavepoint();  // create
    connection.rollback(sp1);                   // откат транзакции к точке

    -- Batching запросов
    когда необходимо сделать очень много однотипных запросов,
    можно повысить Производительность
    // пример транзакции вручную + Batching
    connection.setAutoCommit(false);    // отключить автокоммит
    for (int i = 0; i < 10000; i++) {
        pstms.setString(1, "Bob" + i);
        pstms.setInt(2, 50 + i % 10);
        pstms.addBatch();               // помещаем в буфер
    }
    pstms.executeBatch();               // выполняем все запросы разом
    connection.commit();                // завершение транзакции

    -- Example
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        try (Connection connection = DriverManager.getConnection(
                "jdbc:postgresql://localhost:5432/mydb", 
                "myuser",                                    
                "password"); 
            Statement statement = connection.createStatement()) {
            ResultSet set = statement.executeQuery("SELECT name, size FROM celebrities;");
            while (set.next()) {
                System.out.println(set.getString("name") + set.getInt("size"));
            }
            statement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
=====================================================================================

Hibernate
--- Hibernate basic ---
    Hibernate - это ORM, framework, коткоторый осуществляет CRUD между Java obj и DB.
    Hibernate - реализация спецификации JPA плюс свои фишки, совпадает на 95%.
    Использует для работы с БД под капотом JDBC.
        Java App <===> Hibernate <===> JDBC <===> Database

    CRUD
    CREATE  - INSERT
    READ    - SELECT
    UPDATE  - UPDATE
    DELETE  - DELETE
    
    Плюсы Hibernate:
    Предоставление технологии ORM
        class Animal {                              animal(table)
            int id;         <==> Hibernate <==>     INTEGER id
            String name;                            VARCHAR(..) name
            int age;                                INTEGER age
            ...                                     ...
        }
    Регулирование SQL-запросами. Нет нужды писать SQL-запросы.
        save() --> Hibernate --> INSERT INTO table ...;
        get()  <-- Hibernate <-- SELECT ...; возвращает объект Java;
    Меньшее кол-во кода по сравнению JDBC.


--- Maven dependencies ---
    Подключить Hibernate with Maven:
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>6.1.0.Final</version>
    </dependency>
    
    Подключить JDBC драйвер(например postgres):
    <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.4.0</version>
    </dependency>

    Конфиг связи между классом и таблицей:
        с пом XML - устаревший способ
        с пом Java аннотаций


--- Configuration ---
    Все настройки конфигурации делятся на 3 группы:
    1. Тип СУБД
        - Указываем диалект (тип СУБД), например, Oracle 9.0
        - Указываем имя JDBC-драйвера для работы с данной СУБД
    2. Указываем данные для авторизации в базе
        - url базы
        - username
        - password
    3. Конфигурируем движок Hibernate
        - dialect  - использовать фичи версии СУБД
        - show_sql - вывод в консоль всех запросов

    Способы которыми можно сконфигурировать Hibernate:
        - Использовать Properties-файл
        - Использовать файл hibernate.cfg.xml
        - Задать конфиги в коде при создании SessionFactory/EntityManagerFactory
        - Использовать методы бина Configuration(Spring)

    hibernate.properties
    --------------------------------------------------------------------
    hibernate.dialect= org.hibernate.dialect.Oracle9Dialect
    hibernate.connection.driver_class= oracle.jdbc.driver.OracleDriver 
    hibernate.connection.url= jdbc:oracle:thin:@localhost:1521:supershop
    hibernate.connection.username=root
    hibernate.connection.password=secret
    hibernate.show_sql=true

    hibernate.cfg.xml
    ---------------------------------------------------------------------
    <hibernate-configuration>	
      <session-factory>                
        <property name="dialect">org.hibernate.dialect.Oracle9Dialect</property>  	
        <property name="connection.driver_class">oracle.jdbc.driver.OracleDriver</property> 	
        <property name="connection.url">jdbc:oracle:thin:@localhost:1521:supershop</property>  	
        <property name="connection.username">root</property>  	
        <property name="connection.password">secret</property>
        <property name="hibernate.show_sql ">true</property>        
      </session-factory>	
    </hibernate-configuration>


--- SessionFactory / EntityManagerFactory ---
    SessionFactory          - создается один раз при запуске приложения, применяет конфигурации
                              и используется для создания сессий Hibernate
    Session                 - используется для CRUD операций с БД(под капотом используется JDBC)
    EntityManagerFactory    - создается один раз при запуске приложения, применяет конфигурации
                              и используется для создания менеджеров EntityManager
    EntityManager           - управляет жизненным циклом entity и выполняет CRUD операции                      
    
    EntityManagerFactory and EntityManager  - соответствует стандату JPA
    SessionFactory and Session              - Hibernate специфика(доп фичи)
    Конвертация Session из EntityManager
    Session session = entityManager.unwrap(Session.class);


--- Использование конфигурации ---
    1. конфигурация с помощью hibernate.properties или кастомного .properties
    SessionFactory sessionFactory = new Configuration().buildSessionFactory();

    ClassLoader classLoader = Thread.currentThread().getClassLoader();
    Properties properties = new Properties();
    properties.load(classLoader.getResourceAsStream("hibernate-dev.properties"));
    SessionFactory sessionFactory = new Configuration()
                .addProperties(properties)              // кастомный .properties
                .addPackage("com.javarush.data")        // пакет с entity
                .buildSessionFactory();

    2. конфигурация с помощью hibernate.cfg.xml или кастомного .xml
    SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
    SessionFactory sessionFactory = new Configuration()
                .configure("hibernate-dev.cfg.xml")     // кастомный .xml
                .addPackage("com.javarush.data")        // пакет где искать entity
                .buildSessionFactory();

    3. конфигурации в коде с пом SessionFactory
    Properties properties = new Properties();                       // спец класс Hibernate
    properties.put(Environment.DRIVER, "org.postgresql.Driver");
    properties.put(Environment.URL, "jdbc:postgresql://localhost:5432/mydb");
    properties.put(Environment.DIALECT, "org.hibernate.dialect.PostgreSQL10Dialect");
    properties.put(Environment.USER, "root");
    properties.put(Environment.PASS, "password");
    SessionFactory sessionFactory = new Configuration()             // применяем конфиг
                .setProperties(properties)
                .addAnnotatedClass(Person.class)                    // указать классы
                .buildSessionFactory();
    
    4. конфигурации в коде с пом EntityManagerFactory
    Map<String, String> dbProperties = new HashMap<>();             // мэпка с конфигом
    dbProperties.put("hibernate.connection.url", "jdbc:mysql://localhost:3306/supershop");
    dbProperties.put("hibernate.connection.driver_class", "com.mysql.jdbc.Driver");
    dbProperties.put("hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
    dbProperties.put("hibernate.default_schema", "APP");
    dbProperties.put("hibernate.connection.username", "nbuser");
    dbProperties.put("hibernate.connection.password", "12345");
    EntityManagerFactory managerFactory = Persistence               // применяем конфиг
                .createEntityManagerFactory("WorkflowPU", dbProperties);


--- Mapping class-table ---
    Аннотации класса:
    @Entity         - класс объекты которого нужно хранить в базе данных
    @Table          - связь класса с таблицей, аттрибуты:
                      name      - String, имя таблицы, если совпадает можно опустить
    @Column         - настройки поля класса и связь его с полем таблицы:
                      name      - String, имя колонки таблицы для поля класса(если имена
                                  совпадают можно опустить)
                      unique    - boolean, все значения поля должны быть уникальны
                      nullable  - boolean, поле может принимать значение null
                      length    - int, максимальная длина (для строк)
                      insertable- bollean, не инсертить
                      updatable - boolean, не апдейтить
    @Id             - первичный ключ, задавать обязательно над полем класса
    @GeneratedValue - автоинкремент первичного ключа, размещаем под @Id,
                      можно указать по каким правилам идет автоинкремент с пом аттрибута:
                      strategy  - стратегия автоинкремента:
                      GenerationType.IDENTITY - автоинкремент по правилам БД (лучший выбор)
                      GenerationType.SEQUENCE - полагается на работу Sequence, созданного в БД
                      GenerationType.TABLE    - полагается на знач столбца таблицы БД(плох выбор)
                      GenerationType.AUTO     - автовыбор - лучше не ставить

    Состояния POJO классов:
    Все взаимодействия делаются с пом Session, после откр транзакции.
    Чтобы связать объект с БД нужно его сохранить - save(obj), persist(obj)
    Чтобы вытащить объект из БД  - get(obj.getClass(), id)
    После связи можно апдейтить прямо сам класс с пом сеттеров obj.setNum="10"
    Удалять объект из БД - remove(obj), delete(obj)
    Отвязать можно так detach(obj)
    Обновить БД, если кто-то из вне изменил БД - refresh(obj)
    Откатить удаление до закр транзакции - merge(obj)


--- Жизненный цикл Hibernate Entity-объектов ---
    Состояния:
    Transient   - (прозрачный) новый созданный POJO, не влияет ни на что
                  Client <==> POJO
    Persistent  - объекты, связанные с Hibernate, 2 способа получить:
                    - загрузить объект из Hibernate
                    - сохранить объект в Hibernate
                  Client <==> POJO <==> Session <==> DB +--+ POJOTable
    Detached    - объект был отсоединен от сессии, закрылась сессия, либо 
                  завершилась транз, Hiber больше не следит за объектом. 
                  session.close();          // закрылась сессия
                  session.evict(entity);    // явно отсоединить объект
                  Client <==> POJO  DB +--+ POJOTable
    Removed     - состояние объекта, на котором вызван метод remove()
                  запись из BD удалена, Java-объект перех в это состояние
                  session.remove(employee); // у объекта состояние Removed
                  Client <==> POJO
    
    Employee employee = session.load(Employee.class, 1);    // Persisted
    session.remove(employee);                               // Removed
    session.persist(employee);                              // Persisted
    session.close();                                        // Detached
    session.merge(employee);                                // Persisted
    Employee emp = new Employee();                          // Transient
    session.persist(emp);                                   // Persisted
                    

                                         Detached
                                          ^   |
                                detach()  |   |
                                evict()   |   | merge()
                                clear()   |   | update()
                                close()   |   |
                                          |   |                           D
                            persist()     |   v     find() get() load()   a
    New POJO --> Transient -----------> Persistent <--------------------- t
                            save()        |   ^  \----------------------> a
                                          |   |           flush()         b
                                          |   | persist()                 a
                                 remove() |   | save()             +----> s
                                          v   |                    |      e
                                         Removed ------------------+
                                                       flush()



--- Entity Annotations ---
    Индексы
    @Table (name = "demo_annotated" , indexes = {
    @Index (name = "name_idx" , columnList = "name" ),          // индекс
    @Index (name = "id_name_idx" , columnList = "id, name" ),   // 2 столбца
    @Index (name = "unique_name_idx" , columnList = "name" , unique = true )
    })

    @Column 
    Отвечает за настройки столбца в таблице. С помощью параметра 
    name указывается имя столбца в которое будет записано значение поля. 
    Для "ручного" формирования запроса с помощью которого будет построен 
    столбец можно воспользоваться параметром columnDefinition.
    Здесь же можно указать ограничение NOT NULL (nullable = false). 
    Чтобы запретить изменение значение какого-либо столбца updatable = false.
    @Column (name = "manual_def_str" , columnDefinition = "VARCHAR(50) NOT NULL
    UNIQUE CHECK (NOT substring(lower(manual_def_str), 0, 5) = 'admin')" )
    String manualDefinedString ;
    @Column (name = "short_str" , nullable = false , length = 10 ) // varchar(10)
    String shortString ;
    @Column (name = "created_at" , updatable = false )
    LocalDateTime createdAt ;

    @Column(name = "gen_uuid" , insertable = false, updatable = false )
    private UUID gen_uuid;              // не инсертить и не обновлять

    @Transient                          // не сохраняется в бд   
    public Integer total;

    @Formula(value = " wid * height ")  // тоже не сохранять в бд а при
    public Integer total;               // чтении вычислять значение

    @Temporal(TemporalType.TIMESTAMP)   // поле для хан времени(DATE, TIME, ...)
    @CreationTimestamp                  // созд при созд записи
    @UpdateTimestamp                    // обновляемая отметка времени
    @Basic                              // поле должно быть обработано автоматически

    Валидаторы, можно создавать свои - @Constraint
    @Email
    @NotNull
    @Size(min=1, max=9)

    @Version    // Оптимистическое управление параллельным доступом

    
--- Transaction/Транзакции ---
    Если Hibernate выполняет запрос на получение данных, то явно транзакцию открывать не нужно
    Hibernate сам это сделает, если посчитает нужным: у него есть его настройки, 
    а также настройки SQL-сервера.
    Для остальных операций открываем-закрываем транзакции вручную
    Transaction transaction = session.beginTransaction();   // открыть транзакцию
    transaction.commit();                                   // выполняем транзакцию
    transaction.rollback();                                 // либо откатываем


--- HQL (Hibernate Query Language) ---
    это SQL переделанный под написание запросов в Hibernate для удобства
    Вместо имени таблицы используется имя entity класса, 
    вместо полей БД используются именя полей класса
    
    Native                                            | HQL
    --------------------------------------------------+---------------------------------------
    SELECT * FROM employee                            | FROM Employee
    SELECT * FROM employee WHERE first_name = 'Inna'; | FROM Employee WHERE firstName = 'Inna'
    SELECT name FROM employee;                        | SELECT name FROM Employee
    UPDATE employee SET salary = 0;                   | UPDATE Employee SET salary = 0;
    DELETE employee WHERE name='Inna'                 | DELETE Employee WHERE name='Inna'
    WHERE field IS NOT TRUE;                          | WHERE field IS NULL OR field = FALSE;
    ...JOIN employee ON task.employee = employee.id;  | FROM Task WHERE employee.name = 'Igor'
    ...JOIN employee ON task.employee = employee.id;  | SELECT employee FROM Task where id = 2
    в джоинах обращаемся к полям связной таблицы через точку


--- CRUD with Hibernate ---
    Query - интерфейс, с помощью которого получаем запрос к БД:
        Query<Employee> query = session.createQuery("from Employee", Employee.class);
    Для обработки запроса используются различные методы:
        query.getResultList();      // все записи запроса
        query.getSingleResult();    // 1 запись запроса
        query.getResultStream();    // все записи в виде потока(стрима)
        query.executeUpdate();      // выполнить запрос на изменение БД(не SELECT)
        query.scroll();             // позволяет перемещаться по списку результатов
    
    Подстановка параметров:
    // именованные параметры
    session.createQuery("DELETE Employee WHERE name = :name AND age = :age")
            .setParameter("name", myName)   // ---------^              ^
            .setParameter("age", myAge)     // ------------------------+
    // вхождение в список IN
    session.createQuery("FROM Entity WHERE id IN (:idList)")
            .setParameterList("idList", myIdList)

    SELECT:
    // явно транзакцию открывать не нужно, Hibernate сам откроет если нужно
    // выбрать все записи в список
    Query<Person> query = session.createQuery("FROM Person", Person.class); // запрос SELECT *
    List<Person> people = query.list();                                     // результат
    List<Person> people = query.getResultList();                            // результат JPA std

    // выбрать 1 запись по id (find и getSingleResult - стандарт JPA)
    person = session.get(Person.class, id);
    person = session.find(Person.class, id);
    person = session.createQuery("FROM Person WHERE id = :id", Person.class).uniqueResult();
    person = session.createQuery("FROM Person WHERE id = :id", Person.class).getSingleResult();

    // выбрать отдельное поле(можно с distinct)
    List<String> names = session.createQuery("SELECT name FROM Person", String.class);

    // выбрать DTO лучше с помощью getResultStream() или обработать обычный список с entity
    forEach(person -> personDTOS.add(new PersonDTO(person.getName(), person.getAge())));

    // LIMIT OFFSET
    query.setFirstResult(10);   // аналог OFFSET
    query.setMaxResults(1);     // аналог LIMIT
    query.getResultList();      // далее делаем выборку
    
    INSERT:
    Transaction transaction = session.beginTransaction();
    session.persist(person);                        // инсертит новую запись в связанную таблицу
    transaction.commit();                           // выполняем транзакцию и саму вставку

    UPDATE:


    REMOVE:
    Transaction transaction = session.beginTransaction();
    session.remove(person);                         // удалить из базы связанную запись с person
    transaction.commit();
    

--- SQL Injection ---
    Атака на веб-приложение, которая позволяет злоумышленнику внедрять 
    вредоносный SQL-код в запросы к базе данных

    Правильный подход добавлять переменные в виде параметров:
    String hql = "from EmployeeTask where employee.name = :username";   // правильно
    Query<EmployeeTask> query = session.createQuery( hql, EmployeeTask.class);
    query.setParameter("username", "Иван Иванович");                    // правильно

    Нельзя склеивать запрос из нескольких частей !!!
    String hql = "from EmployeeTask where employee.name = " + myName;   // так делать нельзя!
    Query<EmployeeTask> query = session.createQuery( hql, EmployeeTask.class);
    Потому что в myName может попасть не ожидаемая строка, например
    myName = "'Иван;' DROP TABLE user;";    // удалит еще и таблицу user


--- Named Queries ---
    Hibernate позволяет хранить именованные запросы в виде аннотаций, можно обращаться к ним из кода
    Аннотации можно добавить перед любым Entity-классом: имена запросов не привяз ни к какому Entity

    @org.hibernate.annotations.NamedQueries({                   // список запросов
            @org.hibernate.annotations.NamedQuery(              // 1 именов запрос
                    name = "Person_GetById",                    // имя запроса
                    query = "FROM Person WHERE id = :id"),      // SQL запрос
            @org.hibernate.annotations.NamedQuery(              // 2 именов запрос
                    name = "Person_GetByName",
                    query = "FROM Person WHERE name = :name",
                    timeout = 1,                                // доп параметры
                    fetchSize = 10,
                    cacheable = true,
                    cacheMode = CacheModeType.GET)
    })

    // использование в коде, просто вместо стринг запроса используем имя запроса
    session.createNamedQuery("Person_GetById", Person.class).setParameter("id", id).getSingleResult();


--- NativeQuery ---
    Нативные запросы на SQL

    // так же можно хранить именованные запросы на SQL
    @org.hibernate.annotations.NamedNativeQueries(
            @org.hibernate.annotations.NamedNativeQuery(name = "Employee_GetAll",
                    query = "select * from employee",
                    resultClass = Employee.class)
    )

    // использование, получаем объект запроса NativeQuery(можно Query) и обрабатываем результат
    NativeQuery<Employee> query = session.createNativeQuery("select * from employee", Employee.class);
    List<Employee> resultLIst = query.list();   // те же методы обработки что и для Query


--- One-to-One ---
    Uni-directional associations - отношения когда одна сторона не знает о них.
    Bi-directional associations - обе стороны имеют ссылки друг на друга.

    public enum CascadeType {   // виды каскадов
        ALL,
        PERSIST,
        MERGE,
        REMOVE,
        REFRESH,
        DETACH

    Uni
    Employee --> Details(детали не знают о существовании Employee)

    // Поле 'details_id' в табл employees которое является внешним ключем на
       поле 'id' таблицы details.
    // Добавим в класс Employee поле - внешний ключ на Detail(табл details)
    // Естесственно в БД должны быть соотв таблицы и настроенный связи.
    @OneToOne(cascade = CascadeType.ALL)// тип отношений, cascade -типа как в БД
                                        // при del/upd в связ таблице тоже удал
    @JoinColumn(name = "details_id")    // столбец кот осущ связь с др таблицей
    private Detail empDetail;           // тип - класс кот связан с др таблицей

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)    // добавим еще класс
                .buildSessionFactory()); 
            Session session = factory.getCurrentSession() {
            
            Employee emp = new Employee("Ivan", "Bond", "IT", 750);
            Detail detail = new Detail("Samara", "+70096", "ivan@gmail.com");
            emp.setEmpDetail(detail);
            session.beginTransaction();

            // в итоге транзакции создадутся записи как в employees так и 
               запись в details автоматом(из за cascade = CascadeType.ALL)
            session.save(emp);
            // так можно получить запись из таблицы через др таблицу         
            session.get(Employee.class, 9).getEmpDetail()
            // так удалятся данные работника + автоматом детали
            Employee emp = session.get(Employee.class, 10);
            session.delete(emp);

            session.getTransaction().commit();
        }
    }

    Bi
    Employee <==> Detail, оба класса знают друг о друге.
    // добавим в Detail поле 
    @OneToOne(mappedBy = "empDetail",   // указыаем уже готовую связь one-to-one
              cascade = CascadeType.ALL)// также делаем зависимости 
    private Employee employee;     

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)
                .buildSessionFactory();
            Session session = factory.getCurrentSession()) {
            Employee emp = new Employee("Petr", "Pacman", "Security", 260);
            Detail detail = new Detail("Samara", "+79172076", "oleg@gmail.com");

            emp.setEmpDetail(detail);
            detail.setEmployee(emp);

            session.beginTransaction();
            session.save(detail);   // создается записи в 2-х таблицах
            session.getTransaction().commit();

            // удаление и получение данных как и в Uni, только можно работать
               с обоими классами, так как они связаны как Bi.
        }
    }

    Если необходимо удалить только записи в одной таблице, но не удалять
    автоматом запись из другой:
    @OneToOne(mappedBy = "empDetail",   // меняем CascadeType с ALL на неск-ко
              cascade = {CascadeType.PERSIST, CascadeType.REFRESH}) 
    // далее получаем детали, получаем работкника и обнуляем ссылку на детали
    detail detail = session.get(Detail.class, 1);
    detail.getEmployee().setEmpDetail(null);    // обнуляем ссылку на Detail
    session.delete(detail); 

--- One-to-Many ---
    Bi-directional
    Employee1 <=\ 
    Employee2 <==> Department
    Employee3 <=/ 
    Работников много к 1 департаменту
    Двусторонняя связь, можно получать департамент через работников, так и
    работников через департамент, при удалении/изменении можно настроить
    по разному - как угодно.

    // Employee, внешний ключ на 1 Department(departments table)
    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "department_id")
    private Department department;

    // Department, может иметь список работников
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "department")
    private List<Employee> employees;
    // плюс создадим метод для добавления работника в департамент
    // и установка у этого работника выбранного департамента
    public void addEmployeeToDepartment(Employee employee) {
        if (employees == null) {
            employees = new ArrayList<>();
        }
        getEmployees().add(employee);
        employee.setDepartment(this);
    }

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Department.class)
                .buildSessionFactory();
            Session session = factory.getCurrentSession()) {
            session.beginTransaction();
            // создадим департамент
            Department department1 = new Department("IT",1500, 300);
            // созд работников
            Employee employee1 = new Employee("Ivan", "Bond", 1300);
            Employee employee2 = new Employee("Efim", "Bird", 980);
            // добавим в департамент
            department1.addEmployeeToDepartment(employee1);
            department1.addEmployeeToDepartment(employee2);
            
            // сохраняем департамент и он и работники авто добавятся в БД
            session.save(department1);

            // также можно получить связ записи одной таблицы через другую
            // причем в обе стороны так как Bi
            Department department = session.get(Department.class, 1);
            System.out.println(department);
            System.out.println(department.getEmployees());
            Employee employee = session.get(Employee.class, 12);
            System.out.println(employee.getDepartment());

            // удалятся запись работника, департамента и всех работников деп
            session.delete(employee);
            // перенастроим каскады(уберем REMOVE)
            @ManyToOne(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
            @JoinColumn(name = "department_id")
            private Department department;

            @OneToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE}, mappedBy = "department")
            private List<Employee> employees;


            session.getTransaction().commit();
        }
    }

    Uni-directional
    Employee1 <-\ 
    Employee2 <-- Department
    Employee3 <-/
    Работников много к 1 департаменту
    Через работников нельзя получить данные департамента, также при удалениии
    работника - в табл departments ничего не произойдет. 
    Через департамент можно получить работников, при удалении департамента
    каскадом удаляются все его работники.

    // Employee - убираем поле(внешний ключ на departsments) department
       в самой таблице ничего не переделываем - department_id остается

    // Department - добавляем @JoinColumn с внешн ключом с таблицы из которой
       ссылаются на эту таблицу(из employees), т.е. "department_id", из 
       за того что связь @OneToMany, еслли бы @ManyToOne - то указали бы
       внеш ключ из своей же таблицы.
    @OneToMany(cascade = {CascadeType.ALL})
    @JoinColumn(name = "department_id") // ссылка на поле в таблице employees
    private List<Employee> employees;

--- Many-to-One ---
    // все в примере One-to-Many выше
    // в ManyToOne располагается внешний ключ на связ таблицу
    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "department_id")
    private Department department;

    // варианты в случае возникновения ошибки EntityNotFoundException
    @ManyToOne(fetch = FetchType.EAGER)         // заменить LAZY на EAGER

    @ManyToOne(optional = false)                // прописать optional

    @ManyToOne(fetch = FetchType.LAZY)
    @NotFound(action = NotFoundAction.IGNORE)   // добавить IGNORE

--- Many-to-Many ---
    Кружок1 \  / Ребенок1
    Кружок2 <==> Ребенок2
    Кружок3 /  \ Ребенок3

    Join Table - 3-я таблица, отображающая связь между строками 2-х таблиц.
    Столбцы Join Table - это Foreign Key, которые ссылаются на Primary Key
    связываемых таблиц.

    Создадим 3 таблицы в БД: children, section, child_section

    // class Child, поле - внешний ключ, список секций
    @ManyToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
    @JoinTable(name = "child_section",  // имя 3-й связной таблицы/Join Table
            joinColumns = @JoinColumn(name = "child_id"),   // sourse PK 
            inverseJoinColumns = @JoinColumn(name = "section_id") // target PK
    )
    private List<Section> sections;

    // class Section, список детей, все то же, но поменять колонки местами
    @ManyToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
    @JoinTable(name = "child_section",
            joinColumns = @JoinColumn(name = "section_id"),         // <=+
            inverseJoinColumns = @JoinColumn(name = "child_id")     // <=+
    )
    private List<Child> children;

    // Example
    public static void main(String[] args) {
        try (
                SessionFactory factory = new Configuration()
                        .configure("hibernate.cfg.xml")
                        .addAnnotatedClass(Child.class)
                        .addAnnotatedClass(Section.class)
                        .buildSessionFactory();
                Session session = factory.getCurrentSession()) {
            session.beginTransaction();

            // добавление детей и секций по секции
            Section section = new Section("Football");
            Child child1 = new Child("Ivan", 6);
            Child child2 = new Child("Egor", 9);
            Child child3 = new Child("Olga", 7);
            section.addChildToSection(child1);
            section.addChildToSection(child2);
            section.addChildToSection(child3);
            session.persist(section);   // если CascadeType не вкл REMOVE
                                           persist - каскадное сохранение
            // добавление детей и секций по ребенку
            Section section1 = new Section("Math");
            Section section2 = new Section("Chess");
            Section section3 = new Section("Dance");
            Child child = new Child("Inna", 5);
            child.addSectionToChild(section1);
            child.addSectionToChild(section2);
            child.addSectionToChild(section3);
            session.persist(child);     // если CascadeType не вкл REMOVE
                                           persist - каскадное сохранение
            // получение детей/секций через секцию/ребенка
            Section section = session.get(Section.class, 1);
            section.getChildren().forEach(System.out::println);
            Child child = session.get(Child.class, 4);
            child.getSections().forEach(System.out::println);

            // удалить ребенка и связ с ним записи
            Child child = session.get(Child.class, 4);
            child.getSections().forEach(System.out::println);
            session.remove(child);      // каскадное удаление

            session.getTransaction().commit();
            System.out.println("Done!");
        }
    }

--- Eager/Lazy ---
    Типы выборки данных:
    Eager(нетерпеливая) загрузка - связанные сущности загружаются сразу
    вместе с загрузкой основ сущ. Допустим департамент и лист работников.
    Один SELECT на все сущности. После закрытия сессии все связ сужности 
    будут подгружены.
    
    Lazy(ленивая) загрузка - связанные сущ НЕ загруж сразу вместе с осн
    сущ. Связ сущ-ти загружаются при первом обращении к ним. Разные SELECT
    на сущности. После commit нельзя посмотреть связ сущности, так как сессия
    закрыта, если нужны связ сущ - грузите их до коммита.

    Default:
    One-to-One      Eager   // одна запись - нетелпеливая - легко
    One-to-Many     Lazy    // может быть много связей - поэтому ленивая
    Many-to-One     Eager   // одна связь - нетерпеливая - просто
    Many-to-Many    Lazy    // может быть много связей - поэтому ленивая

    // меняем default type
    @OneToMany(cascade = CascadeType.ALL,
            mappedBy = "department",
            fetch = FetchType.EAGER)    // так менять тип выборки
    private List<Employee> employees;

--- EntityManager vs SessionFactory
// сравнение методов
save()      - лучше использовать persist()
              не требует транзакции, сохраняет или обновляет объект в базе данных
              если объект является новым и не имеет идентификатора, он будет сохранен в базе данных.
              если у объекта уже есть идентификатор, Hibernate выполнит обновление объекта в базе данных.
              Возвращает Serializable, id строки(тип id по спецификации может быть любым)
persist()   - (JPA) инсертит новую запись согласно объекту, требует активной транзакции,
              не работает с Detached объектами, объект не должен иметь id
              После выполнения persist() объекту автоматом присваивается id
update()    - обновляет запись в бд уже существующего объекта, не меняет текущий объект
              работает только с Persisted и Detached объектами
              не возвращает ничего 
merge()     - (JPA)также обновляет запись в бд объекта, не меняет текущий объект
              Может работать с Transient(без id) объектами - создает новую запись - persist()
              Может работать с Detached объектами - обновляет запись
              возвращает измененный объект
saveOrUpdate- Обновить существующий объект, либо создать новый, если объект Transient
              всегда используют вместо методов save() и update(), но лучше исп merge()
remove()    - (JPA) удаляет запись из БД, сам объект не меняется, не возвращает значения
              можно использовать как внутри, так и вне транзакции
delete()    - удаляет запись из БД, сам объект не меняется, возвращает удаленную сущность 
              или null если сущность не найдена, требует наличия активной транзакции
              
     
