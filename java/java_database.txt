Общие понятия
Entity - это объект, который представляет определенную таблицу в базе данных.
Он содержит поля, сответствующие столбцам таблицы, и методы для работы с этими
данными, такие как получение, обновление, удаление и создание записей. Обычно 
класс Entity содержит аннотации для маппинга с таблицей базы данных.

DTO (Data Transfer Object) - это объект, который используется для передачи данных
между слоями приложения или между различными приложениями. Он содержит только 
необходимую информацию для передачи и обычно не содержит методов работы с данными.
DTO обычно используются для уменьшения количества данных, которые нужно передавать
по сети, и для повышения производительности.

POJO (Plain Old Java Object) - это простой Java-объект, который не зависит от 
какой-либо специфической технологии или фреймворка. POJO представляет простой 
контейнер для данных, не имеет специальной логики и не наследуется от каких-либо 
специальных классов. POJO обычно используются для абстракции данных и повышения 
гибкости и переносимости кода.

JDBC
--- JDBC ---
    Java Database Connectivity
    Работа Java с различными СУБД.

    Driver - сущность(класс) необходимая для соединения Java с БД,
    для разный СУБД свой драйвер.
    // драйвер(например postgres) можно загрузить с пом maven pom.xml:
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.6</version>
    </dependency>
    // далее загрузим этот класс в JVM с пом загрузчика:
    Class.forName("org.postgresql.Driver");         // загрузка класса загрузчиком
    Class.forName(className, true, currentLoader);  // эквивалент того что выше

    Connection      - класс для настройки подключения к БД
    DriverManager   - the basic service for managing a set of JDBC drivers.
    Connection conn = DriverManager.getConnection(
                "jdbc:postgresql://192.168.0.104:5432/mydb",    // url
                "user",                                         // user
                "password");                                    // password
    
    Statement       - объект с пом которого выполняются запросы к БД
    ResultSet       - результат запроса из БД (AutoCloseable)
    Statement stmt = conn.createStatement();   // получить obj Statement
    // SELECT
    ResultSet res = stmt.executeQuery("SELECT * FROM my_table;");
    // DML:INSERT/UPDATE/DELETE; DDL:CREATE/ALTER/DROP
    stmt.executeUpdate("INSERT INTO my_table (name, score) VALUES ('Lisa', 35);");

    // вывод результата
    while (resultSet.next()) {  // похож на Iterator
        String name = resultSet.getString("name");  // выбираем поля
        int size = resultSet.getInt("size");
        String country = resultSet.getString("country");
        System.out.printf("%s\t%d\t%s", name, size, country);
    }

    // закрываем все по порядку
    stmt.close();
    conn.close();

    PreparedStatement   - подготовленный запрос, подходит если есть параметры,
    происх прекомпилляция запроса.
    Statement: используется для простых случаев запроса без параметров.
    PreparedStatement: предварительно компилирует запрос, который может содержать
    входные параметры и выполняться несколько раз с разным набором этих параметров.
    При повторном использовании с одним или несколькими наборами параметров 
    позволяет получить преимущества заранее прекомпилированного и кэшированного 
    запроса, помогая при этом избежать SQL Injection.
    // создание
    PreparedStatement preparedStatement;
    preparedStatement = connection.prepareStatement(
                "INSERT INTO students (name, score) VALUES (?, ?);");
    // использование с нашими параметрами
    preparedStatement.setString(1, "Bob");
    preparedStatement.setInt(2, 50);
    preparedStatement.setObject(3, obj) // если тип неизвестен
    preparedStatement.executeUpdate();  // добавить в БД

    Транзакции
    Скорость вставки нескольких значений,
    если автокоммит не отключить то на каждую вставку строки - одна транзакция,
    выходит во много раз дольше. 80000мс против 44мс
    connection.setAutoCommit(false);    // отключить автокоммит
    for (int i = 0; i < 10000; i++) {
        preparedStatement.setString(1, "Bob" + i);
        preparedStatement.setInt(2, 50 + i % 10);
        preparedStatement.executeUpdate();
    }
    connection.commit();                // завершение транзакции

    Savepoint - точка сохранения состояния базы, позволяет откатиться к этой точке.
    Savepoint sp1 = connection.setSavepoint();  // create
    connection.rollback(sp1);                   // откат

    Example:
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        try (Connection connection = DriverManager.getConnection(
                "jdbc:postgresql://localhost:5432/mydb", 
                "myuser",                                    
                "password"); 
            Statement statement = connection.createStatement()) {
            ResultSet set = statement.executeQuery("SELECT name, size FROM celebrities;");
            while (set.next()) {
                System.out.println(set.getString("name") + set.getInt("size"));
            }
            statement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

Hibernate
--- Hibernate basic ---
    Hibernate - это ORM, framework, коткоторый осуществляет CRUD между Java obj и DB.
    Hibernate - реализация спецификации JPA плюс свои фишки.
    Использует для работы с БД под капотом JDBC.
        Java App <===> Hibernate <===> JDBC <===> Database

    CRUD
    CREATE  - INSERT
    READ    - SELECT
    UPDATE  - UPDATE
    DELETE  - DELETE
    
    Плюсы Hibernate:
    Предоставление технологии ORM(Object-to-Relational Mapping) - преобразование
    объекта в строку в таблице и обратное преобразование.
        class Animal {                              animal(table)
            int id;         <==> Hibernate <==>     INTEGER id
            String name;                            VARCHAR(..) name
            int age;                                INTEGER age
            ...                                     ...
        }
    Регулирование SQL-запросами. Нет нужды писать SQL-запросы.
        save() --> Hibernate --> INSERT INTO table ...;
        get()  <-- Hibernate <-- SELECT ...; возвращает объект Java;
    Меньшее кол-во кода по сравнению JDBC.

--- Include Hibernate with Maven ---
    Подключить Hibernate with Maven:
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>6.1.0.Final</version>
    </dependency>
    
    Подключить JDBC драйвер(например postgres) пом maven pom.xml:
    <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.4.0</version>
    </dependency>

    Создать файл(если не создался) в ресурсах hibernate.cfg.xml
    <!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    <hibernate-configuration>
        <session-factory>
                <property name="hibernate.connection.driver_class">org.postgresql.Driver</property>
                <property name="hibernate.connection.username">bestuser</property>
                <property name="hibernate.connection.password">bestuser</property>
                <property name="hibernate.connection.url">jdbc:postgresql://localhost:5432/my_db</property>

                <property name="current_session_context_class">thread</property>
                <property name="show_sql">true</property>
                <property name="hibernate.dialect">org.hibernate.dialect.PostgreSQL95Dialect</property>

            </session-factory>
        </hibernate-configuration>

    Конфиг связи между классом и таблицей:
        с пом XML - устаревший способ
        с пом Java аннотаций
    
--- Entity class ---
    Entity class - Java class, который отображает инфо определенной таблицы в БД.
    Entity class - POJO class, в кот исп-ся опред Hibernate аннотации для связии 
    класса с БД.
    POJO (Plain Old Java Object) - класс должен удовлетв след условиям:
        @Id поле                    *                        
        private поля                *
        all getters/setters         *
        Constructor() without args  *
        Constructor with args (exclude PK 'id') - для создания записей без id
        toString                                - для удобства

    JPA(Java Persistence API) - стандартная спецификация, которая описывает систему
    для уравления сохранением Java объектов в таблицы БД.   
    javax.persistence.*         // пакет для всех аннотаций
    jakarta.persistence.*       // тоже работает(если верхний не пашет)

    @Entity                     // класс имеет отображение в БД
    @Table(name="employees")    // имя таблицы БД, если совпадает можно опустить
    public class Employee {
        @Id                     // Primary Key
        @Column(name = "id")    // имя столбца в БД(если такое же можно опустить)
        @GeneratedValue(strategy = GenerationType.IDENTITY) // автоинкремент по 
        private int id;                                     // правилам БД

        @Column()
        private String name;

        ...

        public Employee() {     // без параметров
        }

        public Employee(String name, String surname, String department, int salary) {
            this.name = name;
            this.surname = surname;
            this.department = department;
            this.salary = salary;
            // id будет генерироваться автоматически
        }

        ... 
        // далее все геттеры, сеттеры на все поля
    }
    GenerationType.IDENTITY     // автоинкремент по правилам БД (лучший выбор)
    GenerationType.SEQUENCE     // полагается на работу Sequence, созданного в БД
    GenerationType.TABLE        // полагается на знач столбца таблицы БД(плох выбор)
    GenerationType.AUTO         // автовыбор - лучше не ставить.

    Состояния POJO классов:
    Все взаимодействия делаются с пом Session, после откр транзакции.
    Чтобы связать объект с БД нужно его сохранить - save(obj), persist(obj)
    Чтобы вытащить объект из БД  - get(obj.getClass(), id)
    После связи можно апдейтить прямо сам класс с пом сеттеров obj.setNum="10"
    Удалять объект из БД - remove(obj), delete(obj)
    Отвязать можно так detach(obj)
    Обновить БД, если кто-то из вне изменил БД - refresh(obj)
    Откатить удаление до закр транзакции - merge(obj)

--- Entity Annotations ---
    Индексы
    @Table (name = "demo_annotated" , indexes = {
    @Index (name = "name_idx" , columnList = "name" ),          // индекс
    @Index (name = "id_name_idx" , columnList = "id, name" ),   // 2 столбца
    @Index (name = "unique_name_idx" , columnList = "name" , unique = true )
    })

    @Column 
    Отвечает за настройки столбца в таблице. С помощью параметра 
    name указывается имя столбца в которое будет записано значение поля. 
    Для "ручного" формирования запроса с помощью которого будет построен 
    столбец можно воспользоваться параметром columnDefinition.
    Здесь же можно указать ограничение NOT NULL (nullable = false). 
    Чтобы запретить изменение значение какого-либо столбца updatable = false.
    @Column (name = "manual_def_str" , columnDefinition = "VARCHAR(50) NOT NULL
    UNIQUE CHECK (NOT substring(lower(manual_def_str), 0, 5) = 'admin')" )
    String manualDefinedString ;
    @Column (name = "short_str" , nullable = false , length = 10 ) // varchar(10)
    String shortString ;
    @Column (name = "created_at" , updatable = false )
    LocalDateTime createdAt ;

    @Column(name = "gen_uuid" , insertable = false, updatable = false )
    private UUID gen_uuid;              // не инсертить и не обновлять

    @Formula("SELECT AVG(cost)...")     // поле кот авто считается при get запис

    @Temporal(TemporalType.TIMESTAMP)   // поле для хан времени(DATE, TIME, ...)
    @CreationTimestamp                  // созд при созд записи
    @Column(name="created",             // не обновляемое
            updatable=false)    

    @UpdateTimestamp                    // обновляемая отметка времени

    Валидаторы, можно создавать свои - @Constraint
    @Email
    @NotNull
    @Size(min=1, max=9)

    @Version    // Оптимистическое управление параллельным доступом

--- CRUD with Hibernate ---
    Первое что необходимо - создать сессию:
    SessionFactory - фабрика по производству сессий.
    SessionFactory читает файл hibernate.cfg.xml для создания опред-х сессий.
    SessionFactory достаточно указать 1 раз - потом переиспользовать.
    Session/сессия - обертка вокруг JDBC для подключ к базе.
    Session/сессия - основа для работы с БД.
    Жизненный цикл сессии небольшой - получаем сессию, делаем операции, закрыв.

    Добавить Entity в SessionFactory можно либо через конфиг в коде как
    ниже, либо можно добавить классы в hibernate.cfg.xml в <session-factory>
    <mapping class="my_package.MyEntity"/>

    public static void main(String[] args) {
        Employee emp = new Employee("Igor", "Bob", "IT", 450);
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)  // 1 или неск Entity
                .buildSessionFactory(); 
            Session session = factory.getCurrentSession()) {
            
            // открытие и закрытие транзакции - обязательны
            session.beginTransaction();                     // BEGIN transaction
            session.save(emp);                              // INSERT
            Employee emp2 = session.get(Employee.class, 3); // SELECT id=3;
            emp.setSalary(750);                             // UPDATE 1 поле
            session.delete(emp);                            // DELETE 1 запись
            session.getTransaction().commit();              // COMMIT
        }
    }

--- HQL (Hibernate Query Language) CRUD ---
    Используется для вз-ия с БД.
    Общий синтаксис:
    session.createQuery("Query", Class); // запрос + класс нашего Entity

    // SELECT * FROM employees;
    List<Employee> emps = session.createQuery("FROM Employee", Employee.class)
            .getResultList();   // получить список объектов Employee из БД
    "from Employee" // Employee - название класса привяз к таблице
    // SELECT * FROM employees WHERE name = 'Inna';
    "FROM Employee WHERE = 'Inna'"
    // SELECT * FROM employees WHERE  salary > 100 ORDER BY salary DESC;
    "FROM Employee WHERE salary > 100 ORDER BY salary DESC"

    // UPDATE employees SET SET salary=salary+10 WHERE name LIKE '%nn%';
    session.createQuery("UPDATE Employee SET salary=100 WHERE name LIKE '%nn%'",
            Employee.class)
            .executeUpdate();   // изменить несколько полей

    // DELETE employees WHERE name='Inna';
    session.createQuery("DELETE Employee WHERE name='Inna'", Employee.class)
            .executeUpdate();   // удалить несколько записей

    // подставить свои значения
    String name = "Inna";
    session.createQuery("DELETE Employee WHERE name = :name")       <-+
            .setParameter("name", name) // подставим свое знач name --+
            .executeUpdate();           // удалить несколько записей
    
--- One-to-One ---
    Uni-directional associations - отношения когда одна сторона не знает о них.
    Bi-directional associations - обе стороны имеют ссылки друг на друга.

    public enum CascadeType {   // виды каскадов
        ALL,
        PERSIST,
        MERGE,
        REMOVE,
        REFRESH,
        DETACH

    Uni
    Employee --> Details(детали не знают о существовании Employee)

    // Поле 'details_id' в табл employees которое является внешним ключем на
       поле 'id' таблицы details.
    // Добавим в класс Employee поле - внешний ключ на Detail(табл details)
    // Естесственно в БД должны быть соотв таблицы и настроенный связи.
    @OneToOne(cascade = CascadeType.ALL)// тип отношений, cascade -типа как в БД
                                        // при del/upd в связ таблице тоже удал
    @JoinColumn(name = "details_id")    // столбец кот осущ связь с др таблицей
    private Detail empDetail;           // тип - класс кот связан с др таблицей

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)    // добавим еще класс
                .buildSessionFactory()); 
            Session session = factory.getCurrentSession() {
            
            Employee emp = new Employee("Ivan", "Bond", "IT", 750);
            Detail detail = new Detail("Samara", "+70096", "ivan@gmail.com");
            emp.setEmpDetail(detail);
            session.beginTransaction();

            // в итоге транзакции создадутся записи как в employees так и 
               запись в details автоматом(из за cascade = CascadeType.ALL)
            session.save(emp);
            // так можно получить запись из таблицы через др таблицу         
            session.get(Employee.class, 9).getEmpDetail()
            // так удалятся данные работника + автоматом детали
            Employee emp = session.get(Employee.class, 10);
            session.delete(emp);

            session.getTransaction().commit();
        }
    }

    Bi
    Employee <==> Detail, оба класса знают друг о друге.
    // добавим в Detail поле 
    @OneToOne(mappedBy = "empDetail",   // указыаем уже готовую связь one-to-one
              cascade = CascadeType.ALL)// также делаем зависимости 
    private Employee employee;     

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Detail.class)
                .buildSessionFactory();
            Session session = factory.getCurrentSession()) {
            Employee emp = new Employee("Petr", "Pacman", "Security", 260);
            Detail detail = new Detail("Samara", "+79172076", "oleg@gmail.com");

            emp.setEmpDetail(detail);
            detail.setEmployee(emp);

            session.beginTransaction();
            session.save(detail);   // создается записи в 2-х таблицах
            session.getTransaction().commit();

            // удаление и получение данных как и в Uni, только можно работать
               с обоими классами, так как они связаны как Bi.
        }
    }

    Если необходимо удалить только записи в одной таблице, но не удалять
    автоматом запись из другой:
    @OneToOne(mappedBy = "empDetail",   // меняем CascadeType с ALL на неск-ко
              cascade = {CascadeType.PERSIST, CascadeType.REFRESH}) 
    // далее получаем детали, получаем работкника и обнуляем ссылку на детали
    detail detail = session.get(Detail.class, 1);
    detail.getEmployee().setEmpDetail(null);    // обнуляем ссылку на Detail
    session.delete(detail); 

--- One-to-Many ---
    Bi-directional
    Employee1 <=\ 
    Employee2 <==> Department
    Employee3 <=/ 
    Работников много к 1 департаменту
    Двусторонняя связь, можно получать департамент через работников, так и
    работников через департамент, при удалении/изменении можно настроить
    по разному - как угодно.

    // Employee, внешний ключ на 1 Department(departments table)
    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "department_id")
    private Department department;

    // Department, может иметь список работников
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "department")
    private List<Employee> employees;
    // плюс создадим метод для добавления работника в департамент
    // и установка у этого работника выбранного департамента
    public void addEmployeeToDepartment(Employee employee) {
        if (employees == null) {
            employees = new ArrayList<>();
        }
        getEmployees().add(employee);
        employee.setDepartment(this);
    }

    public static void main(String[] args) {
        try(SessionFactory factory = new Configuration()
                .configure("hibernate.cfg.xml")
                .addAnnotatedClass(Employee.class)
                .addAnnotatedClass(Department.class)
                .buildSessionFactory();
            Session session = factory.getCurrentSession()) {
            session.beginTransaction();
            // создадим департамент
            Department department1 = new Department("IT",1500, 300);
            // созд работников
            Employee employee1 = new Employee("Ivan", "Bond", 1300);
            Employee employee2 = new Employee("Efim", "Bird", 980);
            // добавим в департамент
            department1.addEmployeeToDepartment(employee1);
            department1.addEmployeeToDepartment(employee2);
            
            // сохраняем департамент и он и работники авто добавятся в БД
            session.save(department1);

            // также можно получить связ записи одной таблицы через другую
            // причем в обе стороны так как Bi
            Department department = session.get(Department.class, 1);
            System.out.println(department);
            System.out.println(department.getEmployees());
            Employee employee = session.get(Employee.class, 12);
            System.out.println(employee.getDepartment());

            // удалятся запись работника, департамента и всех работников деп
            session.delete(employee);
            // перенастроим каскады(уберем REMOVE)
            @ManyToOne(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
            @JoinColumn(name = "department_id")
            private Department department;

            @OneToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE}, mappedBy = "department")
            private List<Employee> employees;


            session.getTransaction().commit();
        }
    }

    Uni-directional
    Employee1 <-\ 
    Employee2 <-- Department
    Employee3 <-/
    Работников много к 1 департаменту
    Через работников нельзя получить данные департамента, также при удалениии
    работника - в табл departments ничего не произойдет. 
    Через департамент можно получить работников, при удалении департамента
    каскадом удаляются все его работники.

    // Employee - убираем поле(внешний ключ на departsments) department
       в самой таблице ничего не переделываем - department_id остается

    // Department - добавляем @JoinColumn с внешн ключом с таблицы из которой
       ссылаются на эту таблицу(из employees), т.е. "department_id", из 
       за того что связь @OneToMany, еслли бы @ManyToOne - то указали бы
       внеш ключ из своей же таблицы.
    @OneToMany(cascade = {CascadeType.ALL})
    @JoinColumn(name = "department_id") // ссылка на поле в таблице employees
    private List<Employee> employees;

--- Many-to-One ---
    // все в примере One-to-Many выше
    // в ManyToOne располагается внешний ключ на связ таблицу
    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "department_id")
    private Department department;

    // варианты в случае возникновения ошибки EntityNotFoundException
    @ManyToOne(fetch = FetchType.EAGER)         // заменить LAZY на EAGER

    @ManyToOne(optional = false)                // прописать optional

    @ManyToOne(fetch = FetchType.LAZY)
    @NotFound(action = NotFoundAction.IGNORE)   // добавить IGNORE

--- Many-to-Many ---
    Кружок1 \  / Ребенок1
    Кружок2 <==> Ребенок2
    Кружок3 /  \ Ребенок3

    Join Table - 3-я таблица, отображающая связь между строками 2-х таблиц.
    Столбцы Join Table - это Foreign Key, которые ссылаются на Primary Key
    связываемых таблиц.

    Создадим 3 таблицы в БД: children, section, child_section

    // class Child, поле - внешний ключ, список секций
    @ManyToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
    @JoinTable(name = "child_section",  // имя 3-й связной таблицы/Join Table
            joinColumns = @JoinColumn(name = "child_id"),   // sourse PK 
            inverseJoinColumns = @JoinColumn(name = "section_id") // target PK
    )
    private List<Section> sections;

    // class Section, список детей, все то же, но поменять колонки местами
    @ManyToMany(cascade = {CascadeType.PERSIST,
            CascadeType.DETACH,
            CascadeType.REFRESH,
            CascadeType.MERGE})
    @JoinTable(name = "child_section",
            joinColumns = @JoinColumn(name = "section_id"),         // <=+
            inverseJoinColumns = @JoinColumn(name = "child_id")     // <=+
    )
    private List<Child> children;

    // Example
    public static void main(String[] args) {
        try (
                SessionFactory factory = new Configuration()
                        .configure("hibernate.cfg.xml")
                        .addAnnotatedClass(Child.class)
                        .addAnnotatedClass(Section.class)
                        .buildSessionFactory();
                Session session = factory.getCurrentSession()) {
            session.beginTransaction();

            // добавление детей и секций по секции
            Section section = new Section("Football");
            Child child1 = new Child("Ivan", 6);
            Child child2 = new Child("Egor", 9);
            Child child3 = new Child("Olga", 7);
            section.addChildToSection(child1);
            section.addChildToSection(child2);
            section.addChildToSection(child3);
            session.persist(section);   // если CascadeType не вкл REMOVE
                                           persist - каскадное сохранение
            // добавление детей и секций по ребенку
            Section section1 = new Section("Math");
            Section section2 = new Section("Chess");
            Section section3 = new Section("Dance");
            Child child = new Child("Inna", 5);
            child.addSectionToChild(section1);
            child.addSectionToChild(section2);
            child.addSectionToChild(section3);
            session.persist(child);     // если CascadeType не вкл REMOVE
                                           persist - каскадное сохранение
            // получение детей/секций через секцию/ребенка
            Section section = session.get(Section.class, 1);
            section.getChildren().forEach(System.out::println);
            Child child = session.get(Child.class, 4);
            child.getSections().forEach(System.out::println);

            // удалить ребенка и связ с ним записи
            Child child = session.get(Child.class, 4);
            child.getSections().forEach(System.out::println);
            session.remove(child);      // каскадное удаление

            session.getTransaction().commit();
            System.out.println("Done!");
        }
    }

--- Eager/Lazy ---
    Типы выборки данных:
    Eager(нетерпеливая) загрузка - связанные сущности загружаются сразу
    вместе с загрузкой основ сущ. Допустим департамент и лист работников.
    Один SELECT на все сущности. После закрытия сессии все связ сужности 
    будут подгружены.
    
    Lazy(ленивая) загрузка - связанные сущ НЕ загруж сразу вместе с осн
    сущ. Связ сущ-ти загружаются при первом обращении к ним. Разные SELECT
    на сущности. После commit нельзя посмотреть связ сущности, так как сессия
    закрыта, если нужны связ сущ - грузите их до коммита.

    Default:
    One-to-One      Eager   // одна запись - нетелпеливая - легко
    One-to-Many     Lazy    // может быть много связей - поэтому ленивая
    Many-to-One     Eager   // одна связь - нетерпеливая - просто
    Many-to-Many    Lazy    // может быть много связей - поэтому ленивая

    // меняем default type
    @OneToMany(cascade = CascadeType.ALL,
            mappedBy = "department",
            fetch = FetchType.EAGER)    // так менять тип выборки
    private List<Employee> employees;

--- EntityManager vs SessionFactory
EntityManagerFactory and EntityManager  - соответствует стандату JPA
SessionFactory and Session              - hibernate специфика(доп фичи)
// можно получить хибер сессию из манагера 
Session session = entityManager.unwrap(Session.class);
Все медоты EntityManager есть и в Session, всегда используй EntityManager,
Sesseion нужен для специфических функций, которые врятли понадобятся